% !TeX root = ./5-handout.tex

\setcounter{section}{4}
\section{Metalogic for STD}

\begin{frame}
%\large

\scriptsize{\tableofcontents}

\end{frame}

\subsection{Big Picture Stuff}

\begin{frame}
\frametitle{Trees as a Shortcut, provided that...}
%\large

\begin{itemize}[<+->]

\item As we have seen, trees provide a shortcut for demonstrating that a set of sentences is inconsistent (i.e. unsatisfiable): construct a tree whose root is these sentences s.t. all branches close

\item Underwrites further shortcuts for demonstrating:

\begin{enumerate}[1.)]

\item that an argument is valid \\ (its premises and negated conclusion are unsatisfiable)

\item that a sentence is a tautology (its negation is unsatisfiable)

\item that two sentences are logically equivalent 

\end{enumerate}

\item But our shortcuts are justified only if system STD is \textit{sound}

\item And guaranteed to have a shortcut only if system STD is \textit{complete}



\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A Tale of Two Turnstiles: the syntactic one}
%\large

\begin{itemize}[<+->]

\item Recall that the single turnstile `$\vdash_{STD}$' stands for provability \\ (aka derivability) within our proof system STD

\item ``$\Gamma \vdash_{STD} \Theta$'' means that we can derive $\Theta$ from $\Gamma$, within STD. \\ The argument with premises $\Gamma$ and conclusion $\Theta$ is `\emph{tree-valid}'

\item Equivalently, this means that $\Gamma \cup \{\enot \Theta\}$ is \emph{tree-inconsistent}: \\ There is a tree with this set as the root s.t. \emph{all branches close}

\item Throughout, `$\Gamma$' is a \textit{finite} set of SL sentences

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A Tale of Two Turnstiles: the semantic one}
%\large

\begin{itemize}[<+->]

\item Recall that the double turnstile `$\entails$' stands for semantic entailment (aka logical consequence) within (classical) sentential logic SL. 

\item ``$\Gamma \entails \Theta$'' means that $\Gamma$ logically entails $\Theta$ \\ Whenever the premises in $\Gamma$ are true, the conclusion $\Theta$ is true 

\item Equivalently: there is no truth-value assignment (TVA) s.t. \\ $\Gamma$ is satisfied while $\Theta$ is false

\item Equivalently, this means that $\Gamma \cup \{\enot \Theta\}$ is logically inconsistent: \\ no TVA satisfies the premises and negated conclusion  

\end{itemize}
\end{frame}



\begin{frame}
\frametitle{Promises Made, Promises Kept}
%\large

% % It's perhaps interesting to think about why we do not have to demonstrate soundness and completeness results for truthtables. It is almost as if the syntax for truthtables is constitutive of the semantics.

% Could also make some verbal remarks about the notion of mathematical rigor, and how this has evolved over time. And how it might still be contested today, and issues of how rigorous physics ought to be remain highly relevant. Different methodological styles in physics and mathematical physics

\begin{itemize}[<+->]

\item By proving that our tree system is \textit{sound}, we show that these shortcut arguments are rigorous (they never lead us astray)

\medskip 

\bi

\item \emph{Sound}: If $\Gamma \vdash_{STD} \Theta$, then $\Gamma \entails \Theta$
%Single turnstile entails Double Turnstile 

\item (syntactic to semantic: i.e. we chose `good' rules!)

\ei

\bigskip 

\item By proving that our tree system is \textit{complete}, we will show that we never need truth tables: trees suffice

\medskip 

\bi

\item \emph{Complete}: If $\Gamma \entails \Theta$, then $\Gamma \vdash_{STD} \Theta$
%Double Turnstile entails  Single turnstile  

\item (semantic notions are fully covered by our syntactic rules)

\item (Means: we wrote down \textit{enough} rules!)

\ei

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Basic Proof Strategy}
%\large

\begin{itemize}[<+->]

\item Notice that both soundness and completeness are if-then statements (i.e. of the form $P \eif Q$):

\begin{itemize}

\item \emph{Sound}: If $\Gamma \vdash_{STD} \Theta$, then $\Gamma \entails \Theta$

\item \emph{Complete}: If $\Gamma \entails \Theta$, then $\Gamma \vdash_{STD} \Theta$

\end{itemize}

\bigskip

\item Hence, they are logically equivalent to their contrapositives: 

\bi

\item Contrapositive of ($P \eif Q$) is ($\enot Q \eif \enot P$)

\item \emph{Soundness}: If $\Gamma \nentails \Theta$, then $\Gamma \nvdash_{STD} \Theta$ 

\item \emph{Completeness}: If $\Gamma \nvdash_{STD} \Theta$, then $\Gamma \nentails \Theta$

\ei 

\bigskip

\item We will prove the contrapositives, using induction! Wooooo!


\end{itemize}
\end{frame}








\iffalse %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\fi %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Soundness of System STD}

\begin{frame}
\frametitle{Sounding out Soundness}
%\large

\begin{itemize}[<+->]

\item \emph{Sound}: If $\Gamma \vdash_{STD} \Theta$, then $\Gamma \entails \Theta$

\item \emph{$Sound_{contra}$}: If $\Gamma \nentails \Theta$, then $\Gamma \nvdash_{STD} \Theta$ 

\item As always: ask what this means, based on the definitions:

\item ``$\Gamma \nentails \Theta$'' means that \textit{it is not the case that} the set $\Gamma$ entails $\Theta$, \\ i.e. there is a TVA where $\Gamma$ is true but $\Theta$ is false. 

\bigskip

\begin{itemize}

\item So on this TVA, $\enot \Theta$ is true $\Rightarrow$ $\Gamma \cup \{\enot \Theta \}$ is \textcolor{OGlyallpink}{CONSISTENT}

\end{itemize}

%\bigskip

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Analyzing Key Definitions Continued}
%\large

\begin{itemize}[<+->]

\item \emph{$Sound_{contra}$}: If $\Gamma \nentails \Theta$, then $\Gamma \nvdash_{STD} \Theta$ 

\item ``$\Gamma \nvdash_{STD} \Theta$'' means that \textit{it is not the case that} the argument from \\ $\Gamma$ to $\Theta$ is  \emph{tree-valid}

% % Note that the following is actually false! For to say that an argument is tree-invalid simply requires the existence of a single tree with an open branch. Whereas we need the stronger claim that there are no trees (with the given route) that have all closed branches. False statement: Means that the argument from $\Gamma$ to $\Theta$ is \textcolor{OGlyallpink}{\textbf{tree-invalid}}

\bigskip

\begin{itemize}

\item i.e., \textit{it is not the case that} there exists a tree with root $\Gamma \cup \{\enot \Theta \}$ that possesses \emph{all closed branches}

\item \textcolor{OGlyallpink}{Equivalently}: ANY tree with root $\Gamma \cup \{\enot \Theta \}$ possesses \\ \phantom{\emph{Equivalently}:}  \textbf{at least one \textcolor{OGlyallpink}{complete open branch}}

\item (Aside: this is NOT the same as saying that the argument is \textcolor{OGlyallpink}{\textbf{tree-invalid}}, since that only requires the existence of a single tree with a complete open branch) 

%\item for all we know right now, tree-invalidity does not preclude tree-validity

%\item I.e., there is a tree with root $\Gamma \cup \{\enot \Theta \}$ that possesses a \textcolor{OGlyallpink}{complete open branch}

\end{itemize}

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Putting these Two Pieces Together}
%\large

\begin{itemize}[<+->]

\item Assume $\Gamma \nentails \Theta$, i.e. assume that $\Gamma \cup \{\enot \Theta \}$ is \textcolor{OGlyallpink}{CONSISTENT}

\bigskip

\begin{itemize}

\item Then, there is a TVA that makes the premises true and the conclusion false. Call this TVA \; `$\mathcal{I}$', which we'll use throughout

\end{itemize}

\item Need to Show: ANY tree with root $\Gamma \cup \{\enot \Theta \}$ possesses a \textcolor{OGlyallpink}{complete open branch} (i.e. the argument is NOT tree-valid)

\item Equivalently, we are showing that if the root is consistent, then any tree with that root possesses a complete open branch 

\item (i.e. whenever the root is satisfiable, the tree will not close)
%%this last statement is what the book proof shows

%but do we need to show this FOR ALL such trees??? 
%showing that it is not tree-valid, so there is NO tree where all the branches close; maybe that's a better way of putting things? 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Key Facts about our TVA \metav{I}}
%\large

\begin{itemize}[<+->]

\item By definition, \metav{I} makes $\Theta$ false but everything in \GA true

\item As a TVA, \metav{I} assigns either `true' or `false' (exclusive-or) to every atomic sentence letter appearing in the sentences of \GA and \THA

\item Hence, \metav{I} determines a truth value for any wff built from these atomic sentences

\item for any such wff $\Psi$, \metav{I} makes \PS true if and only if it makes \enot\PS false
% $\Gamma$ true \G \P\PS\THA

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Some Convenient Definitions to Streamline our Inductive Proof}
%\large

\begin{itemize}[<+->]

\item Call a tree \emph{good} if its root contains only \enot\THA and the wff in \GA

\item Say that a branch in a good tree is an \emph{\metav{I}-branch} if every wff on it is \metav{I}-true, i.e. true according to \metav{I}

\item Note that each \metav{I}-branch is open, since \metav{I} cannot make true both a wff and its negation (so an \metav{I}-branch can't be closed!)

\item \textbf{Proof plan}: show that every \emph{good} tree contains an \emph{\metav{I}-branch}

\item This will include all the completed good trees, which will have a \textit{complete} open branch, which is what we want to show
% % still a little hazy on the logic here...since some trees just aren't completed. so my earlier claim that we are showing that ANY tree w/ the given root has a complete open branch seems false. really need to say that ANY such tree has a COMPLETABLE open branch, or something like that. how does book handle this? 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Set-Up for Induction}
%\large

\begin{itemize}[<+->]

\item Trees have a recursive structure (they `grow' by nine rules), \\ $\Rightarrow$ we can perform proof by induction (wooooooooo)!

\item We'll do complete induction over the \textit{number of nodes}! \\ (could also do ordinary induction on \# of times we apply a rule) 

%or could do it on the `node-level' where this counts how many ROWS-of-nodes we are, which should match the number of rules we've applied? but actually i guess not, if we have two separate open branches and resolving different formulae on each 

\item \emph{Base case}: the smallest good tree (1 node)

\item \emph{Induction hypothesis}: Assume that every good tree with $n$-many nodes, where $1 \leq n < k$, contains an \metav{I}-branch
%fix some $k$ of interest, $k>1$. 

%assume that every good tree with $n$ nodes contains an \metav{I}-branch. 

\item Induction Step: show that an arbitrary good tree with $k$ nodes also contains an \metav{I}-branch (where $k > 1$)
%given an arbitrary good tree with $n$ nodes

% The point is that starting out with this arbitrary $n+1$-many-rules-applied tree, we know that it must've come from an $n$-many-rules-applied tree by application of one our nine rules. So it suffices to show that applying each rule to an I-branch leads to an I-branch (and this is the recursive structure part! i.e. at this point, we are `building up' but logically we technically start w/ `breaking down')

% % Maybe it was also false to say that every node has either 1 or 2 formulae, since if we apply a rule when there are multiple open branches, we apply it at each branch, and this can lead to 2\times number of open branches formulae...

%but it does seem that GB lecture 6 defines node as having 1 or two formulae! so seems that the nodes are NOT everything we add when applying a rule. some rules introduce two nodes, e.g. the splitting rules. 

%so I should really do COMPLETE induction, since we don't have control over how many nodes the prior step had; not in general. just know that it is less than n, but could be like n-4 if there were four open branches. 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Getting this Party Started: the Base Case}
%\large

\begin{itemize}[<+->]

\item \emph{Base case}: consider a good tree with one node

\item This is just the root $\GA \cup \{\enot \THA\}$

\item By definition, the TVA \metav{I} satisfies the root 

\item $\Rightarrow$ root is an \metav{I}-branch, i.e. every wff on it is true according to \metav{I}

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Keeping the Party Going}
%\large

\begin{itemize}[<+->]

\item Consider an arbitrary good tree `Theodore' with $k$ nodes ($k > 1$)

\item Then there must be a good tree `Theo'  with $1 \leq n < k$ nodes such that `Theodore' results from applying one of our nine STD rules to `Theo'. Call this rule `Ruby' $\in \{\enot, \eand, \eor, \eif, \eiff, \enot\eand, \enot\eor, \enot\eif, \enot\eiff \}$

\item Since `Theo' falls within the scope of our induction hypothesis, `Theo' has at least one \metav{I}-branch, called `Ida' 

\item Case a) Ruby extends a different open branch than Ida. Then Theodore still has \metav{I}-branch Ida, and so has an \metav{I}-branch

\item Case b) Ruby extends Ida into branchlet(s). We need to show that for any rule, at least one of the branchlets is an \metav{I}-branch

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The Simple way of Putting Case b)}
%\large

\begin{itemize}[<+->]

\item We have to show the following: if a good tree Theo contains an \metav{I}-branch, then so do all the trees that can be built from it by applying a single tree rule \\ (all the possible Theodore's, from all the possible Ruby's) 

\item i.e., each of our nine rules preserves the property of having at least one \metav{I}-branch (i.e. a branch that satisfies the root)

\item The book's induction step basically begins here at `Case b'. \\ We've just justified why it's okay to jump right to Case b. 

%so the book proof illustrates well why this lazy schema technically misses some cases: it leaves out all the case i) scenarios where the rule extends SOME other branch! but of course these cases are harmless. but it's important to be able to show that rigorously. 

\item This mirrors our lazy induction schema for SL: where we start with two arbitrary wffs \PH and \PS that have the property, and show that any application of the SL recursion clause preserves the property 

\end{itemize}
\end{frame}

\subsubsection{Working through some (sub)cases}

\begin{frame}
\frametitle{Subcase i) Ruby is Double Negation (\enot)}
%\large

\begin{itemize}[<+->]

\item Suppose Theo's \metav{I}-branch Ida contains \enot\enot\PS

\item Ruby extends Ida to `Idaho' by adding \PS

\item By assumption, \enot\enot\PS is true according to \metav{I}

\medskip

\begin{itemize}

\item[] $\Rightarrow$ \PS is also true according to \metav{I}

\item (Since otherwise, \enot \PS would be \metav{I}-true, but then \enot\enot\PS would be \metav{I}-false, which would contradict our assumption)

\item So Idaho is also an \metav{I}-branch, this time of Theodore

\end{itemize}

\bigskip


\item Hence, our beloved Theodore contains an \metav{I}-branch



\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Subcase iii) Ruby is Negated Conjunction (\enot \eand)}
%\large

\begin{itemize}[<+->]

\item Suppose Theo's \metav{I}-branch Ida contains \enot(\metaA{}\eand\metaB{})
%\enot (

\item Ruby extends Ida by splitting her into a branchlet with \enot \metaA{} and a branchlet with \enot \metaB{}

\item By assumption, \enot(\metaA{}\eand\metaB{}) is true according to \metav{I}

\medskip

\begin{itemize}

\item So \metav{I} cannot assign $0$ to both \enot \metaA{} and \enot \metaB{}, for if it did, then it would assign $1$ to both \metaA{} and \metaB{}, and hence $0$ to \enot(\metaA{}\eand\metaB{}) \\ (which would contradict our assumption)

\item So \metav{I} must make at least one of \enot \metaA{} or \enot \metaB{} true

\item So \textbf{\textcolor{OGlyallpink}{at least one}} of our two branchlets must be an \metav{I}-branch

%\item So either the branch with \enot \metaA{} or the branch with \enot \metaB{} 

%\item So Idaho is also an \metav{I}-branch, this time of Theodore

\end{itemize}

\bigskip


\item Hence, Theodore contains at least one \metav{I}-branch



\end{itemize}
\end{frame}


\subsection{Testing Alternative Rules: Soundness}

\begin{frame}
\frametitle{Modifying system STD}
%\large

\begin{itemize}[<+->]

\item What if we had chosen an alternative rule(s)? 

\item Simplest case: we swap out one of our nine rules for a different rule, i.e. for a given connective or negated connective. 

\item Call our modified system `$STD^{\ast}$'%E.g. the following:

%\end{itemize}


%\begin{itemize}[<+->]

\item Would our modified system $STD^{\ast}$ remain Sound?

\item Would our modified system $STD^{\ast}$ remain Complete?

\end{itemize}
\end{frame}



\begin{frame}
\frametitle{Checking Soundness: ``top-down" reasoning}
%\large

\begin{itemize}[<+->]

\item \emph{Heuristic for Soundness checking}: consider an \emph{arbitrary} truth value assignment (TVA) that satisfies the sentence being resolved (i.e. \textit{makes true} the sentence `at the top' of the rule)

\item Ask whether this TVA guarantees that \emph{at least one} node below is satisfied, i.e. the sentences on that node are all made true

\item If `\emph{yes}', then the rule preserves soundness: proceed to extend our soundness proof for this case (reasoning in terms of a TVA `\metav{I}'). 

\item If `\textbf{\textcolor{OGlyallpink}{no}}', then the rule BREAKS soundness: \\ proceed to \textbf{\textcolor{OGlyallpink}{construct a counter-example}} using the rule. 

\end{itemize}
\end{frame}

\iffalse %not happy with the following justification; need to be more precise, based on the soundness proof 
\begin{frame}
\frametitle{Why `top down' reasoning works for Soundness}
%\large

\begin{itemize}[<+->]

\item Given an open branch, we ask whether applying the rule preserves the existence of an open branch

\item Semantically: given a satisfiable set of sentences, we ask whether the rule preserves the existence of a satisfiable set

\item Sound rules take us from trees with open branches to trees with open branches

\end{itemize}
\end{frame}

\fi 



\begin{frame}
\frametitle{Counterexamples to Soundness}
%\large

\begin{itemize}[<+->]

\item To show soundness fails, it is NECESSARY to provide a CONCRETE counterexample, using SL sentences
% % in saying this, am I endorsing a constructivist norm on rigor? For what would prevent someone from being satisfied with a more abstract argument by contradiction, where we do not construct a concrete counterexample? 

\bi

\item Further heuristic reasoning about TVAs is not enough!

\ei

\bigskip

\item What you need for a counterexample to soundness:

\begin{enumerate}[1.)]

\item Choose a satisfiable root, i.e. a \textbf{\textcolor{OGlyallpink}{consistent}} set of sentences

\item Apply the modified rule in the tree; you may also use other rules that we've already shown preserve soundness

\item Show that the tree \emph{closes} (i.e. NO \textcolor{OGlyallpink}{complete open branches})

\end{enumerate}

\end{itemize}
\end{frame}



\begin{frame}
\frametitle{Why such Counterexamples work}
%\large

\begin{itemize}[<+->]

\item \emph{Sound}: If $\Gamma \vdash_{STD^{\ast}} \Theta$, then $\Gamma \entails \Theta$

\item Counterexample: $\Gamma \vdash_{STD^{\ast}} \Theta$ but $\Gamma \nentails \Theta$:


\bi

\item `$\Gamma \vdash_{STD^{\ast}} \Theta$' means tree with root $\Gamma \cup \{\enot \Theta \}$ \emph{CLOSES} \\ (i.e. is tree-valid in system $STD^{\ast}$)

\item `$\Gamma \nentails \Theta$' means that $\Gamma \cup \{\enot \Theta \}$ is \textbf{\textcolor{OGlyallpink}{CONSISTENT}} (i.e. satisfiable) \\ (i.e. there exists a TVA that makes the premises $\Gamma$ true \\ but the conclusion $\Theta$ false) 

\ei 

\bigskip

\item If our system \textit{were} sound, then whenever a tree closes, it \textit{would} correspond to a semantically valid argument. 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Liberal Conditional and Conservative Biconditional}
%\large

\begin{multicols}{2}

$STD^{\ast}$: replace rule (\eif) with: \\ 


\begin{center}
\textit{Liberal Conditional} (L\eif) \vspace{1em}
\begin{prooftree}
{line numbering, single branches}
[\metaA{}\eif\metaB{}, line no override={m}
[\vdots, vdotsline={\\[-0.55em] \vdots}, grouped
	[\enot\metaA{}, line no override={j}, just={m L\eif}]
	[\metaB{} \eor \metaA{}]
]
]
\end{prooftree}
\end{center}

\columnbreak

 \uncover<2->{$STD^{\dagger}$: replace rule (\eiff) with: \\


\begin{center}
\textit{Conservative Biconditional} (C\eiff) \vspace{1em}
\begin{prooftree}
{line numbering, single branches}
[\metaA{}\eiff\metaB{}, line no override={m}
[\vdots, vdotsline={\\[-0.55em] \vdots}, grouped
	[\metaA{}, line no override={j}, just={m C\eiff}
		[\metaB{}, grouped, line no override={j+1}]
	]
]
]
\end{prooftree}
\end{center}
}

\end{multicols}

\end{frame}

\begin{frame}
\frametitle{Liberal Conditional: Heuristic Reasoning}
%\large

\begin{itemize}[<+->]

\item The following is `heuristic reasoning' using our rule; it is NOT a formal answer to the question:

\item Reason from the top-down: $\metaA{}\eif\metaB{}$ is logically equivalent to $\enot \metaA{}\eor  \metaB{}$ 

\item The sentences across the two nodes are logically equivalent to $(\enot \metaA{}) \eor (\metaB{} \eor \metaA{})$

\item So note that the top entails the (disjunction of the) bottom! So given an interpretation that satisfies  $\metaA{}\eif\metaB{}$, it must satisfy the sentence in at least one branch below. 

\item Next, proceed to formally extend our soundness proof!



\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Liberal Conditional: Formal Answer}

\begin{itemize}[<+->]

\item \emph{Formally}: assume $\metaA{}\eif\metaB{}$ is true according to \metav{I}. 

\item Then \metav{I} assigns 0 to \metaA{} or 1 to \metaB{} (or both). 

\item In the first case, \metav{I} assigns 1 to $\enot \metaA{}$, satisfying the left branch. 

\item In the second case, \metav{I} makes $(\metaB{} \eor \metaA{})$ true, so it satisfies the right branch. 

\item Either way, \metav{I} satisfies the new sentences on \textbf{\textcolor{OGlyallpink}{at least one}} branch. 

\item Hence, Liberal Conditional does not break soundness 

%\item \emph{Formally}: assume $\metaA{}\eif\metaB{}$ is true according to \metav{I}. Then \metav{I} assigns 0 to \metaA{} or 1 to \metaB{} (or both). Either way, \metav{I} assigns 1 to $(\enot \metaA{}) \eor (\metaB{} \eor \metaA{})$. 

%entails at least one branch below (indeed, it entails both!)


% (L\eif)  preserves soundness: applying our 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Conservative Biconditional}

\begin{itemize}[<+->]

\item Reason from the top-down: \\ $\metaA{}\eiff\metaB{}$ is logically equivalent to $(\metaA{} \eand \metaB{}) \eor (\enot \metaA{} \eand \enot \metaB{})$ 

\item The node below is logically equivalent to $(\metaA{} \eand \metaB{})$

\item Note that the top does NOT entail the bottom! Given an interpretation that satisfies  $\metaA{}\eiff\metaB{}$, it is NOT guaranteed to satisfy the sentence(s) in at least one branch below. 

\item Hence, \emph{to the counterexample!} \\ (note that the problem REQUIRES this! can't stop won't stop!) 

%\emph{Formally}: assume $\metaA{}\eif\metaB{}$ is true according to \metav{I}. Then \metav{I} assigns 0 to \metaA{} or 1 to \metaB{} (or both). Either way, \metav{I} assigns 1 to $(\enot \metaA{}) \eor (\metaB{} \eor \metaA{})$. 

%entails at least one branch below (indeed, it entails both!)


% (L\eif)  preserves soundness: applying our 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Counterexample to Soundness of $STD^{\dagger}$}
%\large

\begin{itemize}[<+->]

\item For a counterexample, need: $\Gamma \vdash_{STD^{\dagger}} \Theta$ but $\Gamma \nentails \Theta$

%\end{itemize}

\medskip

 \uncover<2->{$STD^{\dagger}$: replace rule (\eiff) with \textit{Conservative Biconditional} (C\eiff): \\ 


\begin{center}
\begin{prooftree}
{line numbering, single branches}
[P\eiff P, just=Premise (PR)
[\enot P, grouped, just={\enot Conclusion}
	[P, just={1 C\eiff}
		[P, grouped, close={2, 3, so tree-valid in $STD^{\dagger}$}]
	]
]
]
\end{prooftree}
\end{center}
}

%\begin{itemize}[<+->]

\medskip

\item<3-> But $(P \eiff P) \nentails P$ because  $\{(P \eiff P), \; \enot P\}$ is consistent! \\ Assign `P' false! N.B.: your counterexample MUST use actual sentences of SL; not meta-variables!

\end{itemize}



\end{frame}



%\iffalse





















\subsection{Completeness of System STD}

\begin{frame}
\frametitle{Basic Proof Strategy for Completeness}

\begin{itemize}[<+->]

\item By proving that our tree system is \textit{complete}, we will show that we never need truth tables: trees suffice

\medskip 

\bi

\item \emph{Complete}: If $\Gamma \entails \Theta$, then $\Gamma \vdash_{STD} \Theta$
%Double Turnstile entails  Single turnstile  

\item (semantic notions are fully covered by our syntactic rules)

\item (Means: we wrote down \textit{enough} rules!)

\ei

\bigskip

\item We will prove the contrapositive, using induction: 

%logically equivalent to their contrapositives
\item \emph{Complete}: If $\Gamma \nvdash_{STD} \Theta$, then $\Gamma \nentails \Theta$

\item ``if an argument is not tree-valid, then it's not semantically valid''

%\item \emph{Complete}: If $\Gamma \entails \Theta$, then $\Gamma \vdash_{STD} \Theta$

\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Fleshing out the Proof Idea}
%\large

\begin{itemize}[<+->]

\item ``Not tree-valid" means that EVERY tree with root $\Gamma \cup \{ \enot \Theta \}$ remains \textbf{\textcolor{OGlyallpink}{open}} (i.e. never closes, even after resolving every sentence)

\item Call this open branch `\textbf{\textcolor{OGlyallpink}{Oprah}}' (or `$O$' for short)

\item Use Oprah to define a TVA `\metav{I}' that makes true every wff on $O$

\item So in particular, \metav{I} will make true the sentences in the root, showing they are \textbf{\textcolor{OGlyallpink}{consistent}} $\Rightarrow$ argument is semantically invalid: \\ i.e. \metav{I} makes $\Gamma$ true and $\enot \Theta$ true, i.e. $\Theta$ FALSE

\item This will prove: \emph{Completeness}: If $\Gamma \nvdash_{STD} \Theta$, then $\Gamma \nentails \Theta$

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Starting the Completeness Proof!}
%\large

\begin{itemize}[<+->]

\item Consider an arbitrary argument with premise set $\Gamma$ and putative conclusion $\Theta$

\item Construct a tree with root $\Gamma \cup \{ \enot \Theta \}$ 

\item Assume that this argument is NOT tree valid: so every such tree is open and extends to a complete open tree

\item Hence, there must be at least one complete open branch: $O$

\item Notice that $O$ must end with atomic sentences or negations of these in its last node

\item (So we see that we could do induction, starting `from the bottom' of our tree) 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Setting up the Induction (HW question!)}
%\large

\begin{itemize}[<+->]

\item At this point, we would need to (i) decide what we want to do induction over

\item (ii) Handle the base case(s)

\item (iii) State the induction hypothesis

\item (iv) Proceed to handle all cases in the induction step (coming from a recursive definition(s) ) 

\item We'll leave this to an optional HW question and proceed casually %to (iv)  

\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Using Oprah to define \metav{I}}
%\large

\begin{itemize}[<+->]

\item Since Oprah is open, no wff and its negation ever appear on it

\item Hence, we can define a TVA `\metav{I}' as follows:

\bigskip

\bi
\item \metav{I} assigns `False' to an atomic sentence if and only if its negation appears by itself on a node of $O$

\item Hence, \metav{I} assigns `True' to every atomic sentence appearing by itself on one of $O$'s nodes
\ei

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Idea: show \metav{I} makes true every wff on $O$}
%\large

\begin{itemize}[<+->]

\item Consider an arbitrary wff $\Delta$ on Oprah

\item If $\Delta$ is an atomic sentence or negated atomic sentence, then \metav{I} makes it true by definition 

\item Otherwise, there must exist wff $\alpha$ and $\beta$ that compose $\Delta$ according to our recursive definition of SL sentences
%$\Delta$ must be 

\item Since Oprah is complete, $\Delta$ must be resolved according to one of our nine tree rules, leading to sentences on the `child nodes', \\ and one of these child nodes must lie on Oprah

\item By induction, we assume that the child node on $O$ is satisfied by \metav{I}

\item Given this, we aim to show that \metav{I} makes $\Delta$ true, \emph{no matter which} child node lies on Oprah and is satisfied by \metav{I}

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{What we can conclude AFTER the subcases:}
%\large

\begin{itemize}[<+->]

\item Assuming we complete our heroic quest, we get to conclude that \metav{I} makes $\Delta$ true

\item But $\Delta$ was an arbitrary wff on Oprah

\item So we'll have shown that \metav{I} makes each sentence in the root true

\item By showing that the root is \textbf{\textcolor{OGlyallpink}{satisfiable}}, \metav{I} shows that the argument is \textbf{\textcolor{OGlyallpink}{semantically invalid}}, which is what we wanted to show! 

\item We'll have used Oprah to define a TVA that makes the premises true but the conclusion false

\end{itemize}
\end{frame}





\subsubsection{Becoming complete}

\begin{frame}
\frametitle{Reasoning from the `Bottom Up'}
%\large

\begin{itemize}[<+->]

\item Notice that we are reasoning from the sentences \textit{below} the resolved sentence, back up the tree

\item We need to show that \textit{for \emph{EACH} child node}, if \metav{I} satisfies it, \\ then \metav{I} makes the resolved sentence $\Delta$ true

\item Effectively, we are showing that each child node separately entails the resolved sentence

\item There are nine cases to consider, coming from our nine tree rules

\end{itemize}
\end{frame}




\begin{frame}
\frametitle{Subcase i) $\Delta$ is resolved by Double Negation (\enot)}
%\large

\begin{multicols}{2}

\textit{Double Negation} (\enot) %\vspace{1em}
\begin{center}
\begin{prooftree}
{line numbering}
[\enot\enot\metaA{}, line no override={m}
[\vdots, vdotsline={\\[-0.55em] \vdots}, grouped
	[\metaA{}, line no override={j}, just={m \enot}
	]
	]
]
\end{prooftree}
\end{center}

\columnbreak

\begin{itemize}[<+->]

\item Only one child node $\Rightarrow$ \metaA{} lies on $O$

\item By induction hypothesis, \metav{I} makes \metaA{} true

\item Hence, \metav{I} must assign true to \enot\enot\metaA{}, which in this case is $\Delta$

\item So \metav{I} satisfies $\Delta$

\item On to the next one!

\end{itemize}

\end{multicols}

\end{frame}




\begin{frame}
\frametitle{Subcase iii) $\Delta$ is resolved by Negated Conjunction (\enot \eand)}
%\large

\begin{multicols}{2}

\textit{Negated Conjunction} (\enot \eand) %\vspace{1em}
\begin{center}
\begin{prooftree}
{line numbering, single branches}
[\enot(\metaA{}\eand\metaB{}), line no override={m}
[\vdots,vdotsline={\\[-0.55em] \vdots}, grouped
	[\enot\metaA{}, line no override={j}, just={m \enot \eand}]
	[\enot\metaB{}]
]
]
\end{prooftree}
\end{center}

\columnbreak

\begin{itemize}[<+->]

\item Exactly one child node lies on $O$, but we don't know which one (so we must show \metav{I} satisfies $\Delta$ either way!)

\item a) If $\enot\metaA{}$ lies on $O$, then \metav{I} makes \enot\metaA{} true (by induction hypothesis) 

\item[] $\Rightarrow$  \metav{I} makes \metaA{} false 

\item[] $\Rightarrow$  \metav{I} makes $(\metaA{}\eand\metaB{})$ false, and hence makes $\Delta$ true 

\item b) Likewise if $\enot\metaB{}$ lies on $O$...

\item Either way, \metav{I} satisfies $\Delta$

%\item On to the next one!

\end{itemize}

\end{multicols}

\end{frame}








\begin{frame}
\frametitle{Subcase v) $\Delta$ is resolved by Negated Disjunction (\enot \eor)}
%\large

\begin{multicols}{2}

\textit{Negated Disjunction} (\enot \eor) %\vspace{1em}
\begin{center}
\begin{prooftree} %NEGATED DISJUNCTION 
{line numbering, single branches}
[\enot(\metaA{}\eor\metaB{}), line no override={m}
[\vdots, vdotsline={\\[-0.55em] \vdots}, grouped
	[\enot\metaA{}, line no override={j}, just={m \enot \eor}
	[\enot\metaB{}, grouped,  line no override={j+1}
	]
	]
]
]
\end{prooftree}
\end{center}

\columnbreak

\begin{itemize}[<+->]

\item Only one child node $\Rightarrow$ both \enot \metaA{} and \enot \metaB{} lie on $O$

\item By induction hypothesis, \metav{I} makes both children wff true 

\item Hence, \metav{I} must make false both \metaA{} and \metaB{}

\item[] $\Rightarrow$  \metav{I} makes false $(\metaA{}\eor\metaB{})$ 

\item[] $\Rightarrow$  \metav{I} makes true $\enot(\metaA{}\eor\metaB{})$ 

\item So \metav{I} satisfies $\Delta$

%\item On to the next one!

\end{itemize}

\end{multicols}

\end{frame}

\subsubsection{A Key fact from Our Construction}

\begin{frame}
\frametitle{A Key fact about Complete Open Trees}
%\large

\begin{itemize}[<+->]

\item A complete open tree has at least one complete open branch

\item A complete open branch never contains both a sentence $\metaA{}$ and its negation $\enot \metaA{}$

\item In a `partially complete system', \emph{our construction above lets us define a TVA `\metav{I}' that makes true each sentence on a complete open branch}, including the root

%\item In a `partially complete system', we can use our construction above such that for any complete open branch, we can define a TVA `\metav{I}' that makes true each sentence on that branch, including the root

%\item We could generalize our construction above such that for any complete open branch, we can define a TVA `\metav{I}' that makes true each sentence on that branch, including the root
%idea here is that we won't get into conflict, if no contradictions appear on the branch. can do this consistently, even if a bit ad hoc if the rules are weird!  

%\item This generalized construction would not require the tree system to be complete (so with weird rules \metav{I} could be a bit ad hoc)

\item Upshot: if an argument is tree-invalid (i.e. has at least one complete open tree) in a `partially complete' system , then there is a truth-value assignment that satisfies the root (so $\Gamma \nentails \Theta$)

\item If the system is also SOUND, one could then conclude that the argument is \textit{not} tree-valid. 

%\item We have just seen how to use any complete open branch to define a TVA \metav{I} that makes true each sentence on that branch 

%\item This fact from our construction does not require a tree system to be complete
% % but maybe it does: we seemingly require that the more complex sentences are built from atomic sentences and their negations. But that is already required by the recursive structure of SL. But we seemingly need the rules to respect this, e.g. no random rules such as A\eandB resolves into P stacked on Q.  

% % Idea for generalizing the construction: if you are working with a perverse rule such that its components have not been assigned truth values, then just define the TVA such that it makes true the given sentence. 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{What are the `partially complete' systems?}
%\large

\begin{itemize}[<+->]

\item Our construction of a TVA that satisfies each wff on the complete open branch just requires that \textit{for the rules we use}, the sentences on each child node entail the sentence being resolved. 

\item Call systems ``partially complete" if they have this property

\item Note that the system $STD^{conj}$ which has only the rules (\enot), (\eand), and (\enot \eand) is partially complete in this sense: 

\item for the sentences that \textit{can be} completely resolved with these limited rules, we can turn any complete open branch into a TVA that satisfies all wff on the branch. 

\end{itemize}
\end{frame}

\iffalse 

\begin{frame}
\frametitle{Constructing this Generalization}
%\large

\begin{itemize}[<+->]

\item I realized that there are counterexamples to the general construction. For instance, introduce a destructive rule for conjunction, that resolves A & B into two branches, one with ~A, ~B, the other with A, B. Then this rule is sound, but if the left branch is the complete open one, then we can't make A&B true by an interpretation that makes ~A and ~B true. So our construction fails! 

\item Try to think of weakest condition where the construction succeeds: maybe in any system where the child nodes entail the sentence above. Then given that a tree IS complete, (i.e. everything is resolved), the construction will work. Even if the system as a whole is not complete, e.g. b/c we don't have rules for resolving certain sentences, e.g. missing rule for disjunction. 

\item As before, partially define \metav{I} such that it assigns `False' to an atomic sentence iff its negation appears by itself on the complete open branch $O$

\item Moving up the tree, if $\Delta$ consists of wff that appear below, then the recursive structure of SL will force \metav{I} to make $\Delta$ true (as in our proof)

\item If $\Delta$ is complex but does NOT consist of wff that appear below (e.g. because we are considering a tree system with strange rules), then extend \metav{I} such that it makes $\Delta$ true. 
%a negated atomic sentence is true iff it appears on the complete open branch $O$

\end{itemize}
\end{frame}

\fi 

\subsection{Testing Alternative Rules: Completeness}


\iffalse
\begin{frame}
\frametitle{Modifying system STD}
%\large

\begin{itemize}[<+->]

\item What if we had chosen an alternative rule(s)? 

\item Simplest case: we swap out one of our nine rules for a different rule, i.e. for a given connective or negated connective. 

\item Call our modified system `$STD^{\ast}$'%E.g. the following:

%\end{itemize}


%\begin{itemize}[<+->]

\item Would our modified system $STD^{\ast}$ remain Sound?

\item Would our modified system $STD^{\ast}$ remain Complete?

\end{itemize}
\end{frame}
\fi 



\begin{frame}
\frametitle{Checking Completeness: ``bottom-up" reasoning}
%\large

\begin{itemize}[<+->]

\item \emph{Heuristic for Completeness checking}: ask whether \textbf{EACH} child node (below) individually entails the sentence being resolved \\ (i.e. the sentence `up top', in the `parent-node')
%consider an \emph{arbitrary} truth value assignment (TVA) that satisfies 
%the sentence being resolved (i.e. \textit{makes true} the sentence `at the top' of the rule)

%\item For each child node, consider an arbitrary TVA that satisfies its sentences. Ask whether this TVA guarantees that the sentence being resolved is satisfied

\item If `\emph{yes}', then the rule preserves completeness: \\ proceed to extend our completeness proof for this case (reasoning in terms of arbitrary TVA's, one for each child node). 

\item If `\textbf{\textcolor{OGlyallpink}{no}}', then the rule BREAKS completeness: \\ proceed to \textbf{\textcolor{OGlyallpink}{construct a counter-example}} using the rule. 

\end{itemize}
\end{frame}

\iffalse %not happy with the following justification; need to be more precise, based on the soundness proof 
\begin{frame}
\frametitle{Why `bottom-up' reasoning works for Completeness}
%\large

\begin{itemize}[<+->]

\item Given an open branch, we ask whether applying the rule preserves the existence of an open branch

\item Semantically: given a satisfiable set of sentences, we ask whether the rule preserves the existence of a satisfiable set

\item Sound rules take us from trees with open branches to trees with open branches

\end{itemize}
\end{frame}

\fi 



\begin{frame}
\frametitle{Counterexamples to Completeness}
%\large

\begin{itemize}[<+->]

\item To show completeness fails, it is NECESSARY to provide a CONCRETE counterexample, using SL sentences
% % in saying this, am I endorsing a constructivist norm on rigor? For what would prevent someone from being satisfied with a more abstract argument by contradiction, where we do not construct a concrete counterexample? 

\bi

\item Further heuristic reasoning about TVAs is not enough!

\ei

\bigskip

\item What you need for a counterexample to completeness:

\begin{enumerate}[1.)]

\item Choose an \emph{UNsatisfiable root}, i.e. an INconsistent set of sentences

\item Apply the modified rule in the tree; you may also use other rules that we've already shown preserve completeness

\item Show that the tree has a \textbf{\textcolor{OGlyallpink}{complete open branch}}, \\ i.e. does NOT close
% (i.e. complete open branches)

\end{enumerate}

\end{itemize}
\end{frame}



\begin{frame}
\frametitle{Why such Counterexamples work}
%\large

\begin{itemize}[<+->]

%%need to fix this! since the PS5 result requires partial completeness. so here maybe we're doing a kind of reductio: IF the system were complete, then every unsatisfiable root would have to close. but by constructing a tree w/ unsatisfiable root that remains open, we show a counterexample! 


\item \emph{Complete}: If $\Gamma \entails \Theta$, then $\Gamma \vdash_{STD^{\ast}} \Theta$

\item Counterexample: $\Gamma \entails \Theta$ but $\Gamma \nvdash_{STD^{\ast}} \Theta$

%\item Counterexample: If $\Gamma \nvdash_{STD} \Theta$, then $\Gamma \nentails \Theta$



\bi

\item `$\Gamma \entails \Theta$' means that $\Gamma \cup \{\enot \Theta \}$ is INconsistent (i.e. UNsatisfiable) \\ (i.e. any TVA that makes $\Gamma$ true makes the conclusion $\Theta$ true) 

\item `$\Gamma \nvdash_{STD^{\ast}} \Theta$' means that it is NOT the case that the argument is tree-valid in $STD^{\ast}$ (a claim about ALL trees)

\item From completeness proof, we know that if the system \textit{were} complete, then we could use any \textbf{\textcolor{OGlyallpink}{complete open branch}} to construct a TVA that \textbf{\textcolor{OGlyallpink}{satisfies}} the root

\item Hence, if we construct a \textbf{\textcolor{OGlyallpink}{complete open tree}} with an \emph{unsatisfiable root}, this is a reductio of completeness

\end{itemize}

%\item So then it suffices to construct a complete open tree

% % Perhaps Another way of putting the reductio: by the PS5 result, if the system were complete, then any tree-invalid argument could not be tree valid. So assume system is complete, for reductio. Then construct a tree-invalid argument. This would entail it's not valid. which then is the desired counterexample to completeness. But the logic here is a bit less clear for some reason...

%\item Note: the following argument fails, since the PS5 result requires the system in question to be `partially complete': Technically this is a claim about ALL trees, but we typically help ourselves to soundness, in which case \\ tree-invalid $\Rightarrow$ not tree-valid (see PS5 question). 



%%but maybe it's the case that with our simple counterexamples, we basically consider ALL such trees or come close to it. so actually COULD reason about all such trees w/ the given root. often just two premises, so could permute. 

% tree with root $\Gamma \cup \{\enot \Theta \}$ CLOSES \\ (i.e. is tree-valid in system $STD^{\ast}$)



%\bigskip

%\item actually not sure if the following is an accurate rendition, since again a claim about tree-validity is technically just a claim about the existence of a single tree. If our system \textit{were} complete, then whenever the root is unsatisfiable, the tree would close. 

 %a tree is complete and open, it \textit{would} correspond to a semantically valid argument. 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Liberal Conditional and Conservative Biconditional}
%\large

\begin{multicols}{2}

$STD^{\ast}$: replace rule (\eif) with: \\ 


\begin{center}
\textit{Liberal Conditional} (L\eif) \vspace{1em}
\begin{prooftree}
{line numbering, single branches}
[\metaA{}\eif\metaB{}, line no override={m}
[\vdots, vdotsline={\\[-0.55em] \vdots}, grouped
	[\enot\metaA{}, line no override={j}, just={m L\eif}]
	[\metaB{} \eor \metaA{}]
]
]
\end{prooftree}
\end{center}

\columnbreak

$STD^{\dagger}$: replace rule (\eiff) with: \\


\begin{center}
\textit{Conservative Biconditional} (C\eiff) \vspace{1em}
\begin{prooftree}
{line numbering, single branches}
[\metaA{}\eiff\metaB{}, line no override={m}
[\vdots, vdotsline={\\[-0.55em] \vdots}, grouped
	[\metaA{}, line no override={j}, just={m C\eiff}
		[\metaB{}, grouped, line no override={j+1}]
	]
]
]
\end{prooftree}
\end{center}

\end{multicols}

\end{frame}

\begin{frame}
\frametitle{Liberal Conditional (now from the bottom up!)}

\begin{itemize}[<+->]

\item Reason from the bottom-up, handling each child node separately 

\item \enot \metaA{} entails $\metaA{}\eif\metaB{}$

\item $(\metaB{} \eor \metaA{})$ does NOT entail $\metaA{}\eif\metaB{}$, since \metaA{} doesn't entail it

%The sentences across the two nodes are logically equivalent to $(\enot \metaA{}) \eor (\metaB{} \eor \metaA{})$ 

\item (Remember: $\metaA{}\eif\metaB{}$ is equivalent to $\enot \metaA{}\eor  \metaB{}$)

\item Hence, we \emph{proceed to counterexample!} 

%

%by induction hypothesis, $\metaA{}\eif\metaB{}$ is true according to \metav{I}. Then \metav{I} assigns 0 to \metaA{} or 1 to \metaB{} (or both). Either way, \metav{I} assigns 1 to $(\enot \metaA{}) \eor (\metaB{} \eor \metaA{})$. 

%assume $\metaA{}\eif\metaB{}$ is true according to \metav{I}. Then \metav{I} assigns 0 to \metaA{} or 1 to \metaB{} (or both). Either way, \metav{I} assigns 1 to $(\enot \metaA{}) \eor (\metaB{} \eor \metaA{})$. 

%entails at least one branch below (indeed, it entails both!)


% (L\eif)  preserves soundness: applying our 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Counterexample to Completeness of $STD^{\ast}$}
%\large

\begin{itemize}[<+->]

%\item For a counterexample, need: $\Gamma \entails \Theta$ but $\Gamma \nvdash_{STD^{\ast}} \Theta$ 

\item Counterexample: find \textcolor{OGlyallpink}{complete open tree} with \textcolor{highlightA}{unsatisfiable root}: 

%\end{itemize}


%$STD^{\ast}$: replace rule (\eif) with Liberal Conditional (L\eif): \\ 

\begin{center}
 \uncover<2->{\begin{prooftree}
{line numbering, single branches}
[P\eif Q, checked
[P, grouped
[\enot Q, grouped, just={\enot Conclusion}
	[\enot P, just={1 L\eif}, close={:!uu, !c}]
	[Q \eor P, checked 
		[Q, close={:!uu, !c}, just={4 \eor}]
		[P, open]
	]
]
]
]
\end{prooftree}}
\end{center}

%\begin{itemize}[<+->]

\item<3-> Note that $\{P\eif Q, \; P \} \entails Q$ but \textbf{\textcolor{OGlyallpink}{tree-invalid}} in $STD^{\ast}$

\item<4-> \footnotesize{If $STD^{\ast}$ \textit{were} complete, the complete open branch would lead to a TVA that satisfies the root. Contradiction $\Rightarrow$ not complete} 

\end{itemize}



% % Note that we can't obviously/directly conclude that this argument is also not tree-invalid. Since we haven't considered every possible tree. So we haven't shown that every possible tree with the given root fails to close. But we can still run our reductio on completeness: if the system were complete, then we could turn this complete open branch from our tree-invalid argument into a TVA that satisfies the root. But that is impossible, since the root is unsatisfiable. 


%\begin{itemize}[<+->]

%\item But $(P \eiff P) \nentails P$ because  $\{(P \eiff P), \; \enot P\}$ is consistent! \\ Assign `P' false! N.B.: your counterexample MUST use actual sentences of SL; not meta-variables!

%\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A Common Mistake to Avoid!!!!}
%\large

\begin{itemize}[<+->]

\item You are very liable to forget to COMPLETE YOUR open branch!!!

\item You only have a counterexample to completeness if you have a COMPLETE open branch with an unsatisfiable root

\item So make sure you FULLY RESOLVE every sentence on the open branch, until you can write that coveted up arrow `$\uparrow$'! 

\item When in doubt, just complete the whole tree 


\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Conservative Biconditional (bottoms up!)}

\begin{itemize}[<+->]

\item Reason from the bottom up: there is only one child node. So we only need its sentences to entail $\metaA{}\eiff\metaB{}$

\item Sentences on bottom are equivalent to $(\metaA{} \eand \metaB{})$, which DOES entail $\metaA{}\eiff\metaB{}$. So we proceed to formally extend our completeness proof: 

\bigskip 

\bi 

\item \emph{Formally}: since only one child node, both $\metaA{}$ and $\metaB{}$ lie on the complete open branch $O$. 

\item By induction hypothesis, both are true according to \metav{I}. 

\item Hence, $\metaA{}\eiff\metaB{}$ is true on \metav{I}, which is what we needed to show. 

\ei 

%\item \emph{Formally}: assume $(\metaA{} \eand \metaB{})$ is true according to \metav{I}. Then \metav{I} must assign 1 to both \metaA{} and \metaB{}. Hence, $\metaA{}\eiff\metaB{}$ is true on \metav{I}. 

\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Some Fun Questions to Ponder}
%\large

\begin{itemize}[<+->]

\item What is the least number of tree rules required for soundness? For completeness?
%a system could have while remaining complete?

\bi

\item We'll return to this question if we ever get around to discussing the ``expressive adequacy" of a given set of connectives

\ei

\bigskip

\item When assessing how a modification affects soundness, do we need to know anything about the other rules? 
%do the rules `interact'?

\item When assessing how a modification affects completeness, do we need to know anything about the other rules? 

\end{itemize}
\end{frame}

%\fi 

\iffalse

\begin{frame}
\frametitle{Recall STD:}

  \begin{itemize}[<+->]
    \item d
    \emph{d} ($\enot$, $\eor$, $\eand$, $\eif$, $\eiff$)
  
  \begin{block}{blah}
    \begin{itemize}[<+->]
      \item[] d

  \item[] d

  \item[] d
\end{itemize} 
\end{block}

  \begin{definition}
  d
  \end{definition}


\end{itemize}
\end{frame}

\fi 