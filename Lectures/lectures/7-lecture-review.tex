% !TeX root = ./7-handout-review.tex

\setcounter{section}{6}

\section{Midterm Review!}

\begin{frame}
%\large

\scriptsize{\tableofcontents}

\end{frame}

\subsection{Recursive Definitions}

\begin{frame}
\frametitle{Recursive Definitions have THREE clauses}

\begin{itemize}[<+->]

\item Consider an arbitrary recursively-defined set \metav{S}

\bigskip

\begin{enumerate}
\item {\emph{Base clause}}: typically the smallest element(s) of your set, e.g. the atomic sentences

\item {\emph{Recursion clause}}: If $s$ is an element in \metav{S}, then so is $s$ acted on by some basic operation(s) resulting in \\ elements of \textit{the next biggest \emph{allowed} size}. 
%$a*s*a$, \phantom{vvvvvvvvvvvvvv} $b*s*b$, and $c*s*c$ are recursive palindromes

\item {\emph{Closure clause}}: Nothing else is an element of \metav{S}
\end{enumerate}

\end{itemize} 
\end{frame}

\begin{frame}
\frametitle{Palindromes  semordnilaP}

\begin{itemize}[<+->]
\item A \emph{palindrome} is a string of letters that reads the same way backwards and forwards e.g. ``racecar". 

\item  some trivial cases: ``I", ``a" (we're thinkin `base case material!')
%For bookkeeping purposes let's count the empty string $\epsilon$ as a string of symbols. Then it's a palindrome also.

\item Consider the set of all strings in the alphabet $\{a,b,c\}$ %, to study palindromes there

%I will \textit{not} let you!''?)

\end{itemize} 
\end{frame}

\begin{frame}
\frametitle{Recursively Defining Palindromes}

\begin{itemize}[<+->]
%\item This mind-blowing fact lets us recursively define ``palindrome"

\item Define the set of palindromes using a recursive definition: 

\item Call a string over $\{a,b,c\}$ a \emph{recursive palindrome} if it satisfies the three conditions:

\begin{enumerate}
\item {\emph{Base clause}}: `$a$', `$b$', `$c$', `$aa$', `$bb$', `$cc$'  are recursive palindromes

\item {\emph{Recursion clause}}: If $s$ is a recursive palindrome, then $a*s*a$, \phantom{vvvvvvvvvvvvvv} $b*s*b$, and $c*s*c$ are recursive palindromes

\item {\emph{Closure clause}}: Nothing else is a recursive palindrome in $\{a,b,c\}$
\end{enumerate}

\end{itemize} 
\end{frame}

\begin{frame}
\frametitle{What happens if we place restrictions on palindromes?}
%\large

\begin{itemize}[<+->]

%$veooev teaaet  tieeit

\item Consider the alphabet $\{i, e, t\}$

\item Informally define the ``$tieeit$-palindromes" as all those palindromes with `$tieeit$' in the middle, with string-length divisible by 6, starting with `t', with `e' as every third letter until the middle $tieeit$, and no consecutive i's or triple t's or e's, or instances of `iee' or `ite'. \\ Recursively define these bad boys:

%, and with no more than two t's or e's appearing in every group of three letters. 
%counting from the left. 
%the third letter from the left, with no tripple t's, tripple e's, or double i's. 

\begin{enumerate}
\item {\emph{Base clause}}: `$tieeit$' is a $tieeit$-palindrome

\item {\emph{Recursion clause}}: If $s$ is a $tieeit$-palindrome, then $tie*s*eit$, \phantom{vvvvv} $tee*s*eet$, and $tte*s*ett$, are $tieeit$-palindromes.
%problem: we could have teeeeetieeiteeeeet and that's not covered by our recursion clause! 
%, $tii*s*iit$, and $ttt*s*ttt$ are recursive palindromes

%choices: if i didn't restrict to starting with t, would be 3*3*3=27 cases in recursion clause. by restricting to starting with t, we get 4 choices from e or i in middle; going to have `tit' which seems bad....

\item {\emph{Closure clause}}: Nothing else is a $tieeit$-palindrome (I hope!)
% palindrome in $\{a,b,c\}$
\end{enumerate}



\end{itemize}
\end{frame}


\subsection{Induction on Strings}

\begin{frame}
\frametitle{Complete Induction (a.k.a. `strong induction')}
%\large

\begin{itemize}[<+->]

\item We do induction on string length, considering members from a recursively defined set (e.g. palindromes over some alphabet)

\item[] \emph{Base Case}: Prove the property holds in the base case(s) (of the recursive definition---elements of shortest string length(s))

\item[] \emph{Induction Hypothesis}: Assume that the property holds for members of length $n$, where base-case-index $ \leq n < k$. 

\item[] \emph{Induction Step}: Consider an arbitrary member $\Delta$ of length $k > $base case length(s). Show that $\Delta$ has the property of interest. 

\item Note that there must be a smaller string $\delta$ such that $\Delta = blah * \delta * blah'$, where the `blah's arise from the recursion clause. (all the ways of making a longer $\Delta$ from a shorter $\delta$)

\item Remember to note that since $\delta$ has length $<k$, it falls within the induction hypothesis and hence has the property of interest. 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Example: Prove by induction that...}
%\large

\begin{itemize}[<+->]

\item Show: any $tieeit$-palindrome has string length divisible by 6. 
%begins and ends with the letter `t'

\item[] \emph{Base Case}: the base case has a single element, namely `$tieeit$' of string length 6, which is clearly divisible by 6. 
%it begins and ends with the letter `t`

\item[] \emph{Induction Hypothesis}: Assume that every $tieeit$-palindrome of length $n$, where $6 \leq n < k$, has the property, i.e. is divisible by 6. Show that the property holds for any $tieeit$-palindrome of length $k > 6$. 

%begins and ends with `t'. Show that the property holds for any $tieeit$-palindrome of length $k > 6$. 

\item[] \emph{Induction Step}: consider an arbitrary $tieeit$-palindrome $\Delta$ of length $k > 6$. Then there must exist a shorter $tieeit$-palindrome $\delta$ such that $\Delta$ equals either $tie*\delta*eit$, $tee*\delta*eet$, or $tte*\delta*ett$. Since $\delta$ has length $<k$, the string length of $\delta$ is divisible by 6 by the induction hypothesis. In each case, we add 6 letters to $\delta$ to form $\Delta$. Hence, the string length of $\Delta$ is also divisible by 6.

%Note that the string length of $\delta$ has length $<k$, by the induction hypothesis,

%Note that in each case, $\Delta$ begins and ends with the letter `t'. 
\end{itemize}
\end{frame}




\subsection{Induction on SL Sentences}

\begin{frame}
\frametitle{Special Induction Schema for the language {\it{SL}}}

\begin{itemize}[<+->]

\item Recall that for SL, we can use a special induction schema: 

\item If you want to prove that \emph{ALL} sentences (wffs) of SL have a particular property, it suffices to show the following:

\begin{enumerate}[<+->]

\item All \emph{atomic} sentences have that property (`\textbf{base case}')

\item If \metaA{} and \metaB{} are two \emph{arbitrary wffs} with that property, then so are the sentences built out of them by adding a connective \\ \hspace{4em} `\textbf{Induction step}' (There are five cases to consider:) 

\begin{enumerate}[(i)]
  \item $\enot \metaA{}$
  \item $(\metaA{}\eand\metaB{})$ 
  \item $(\metaA{}\eor\metaB{})$ 
  \item $(\metaA{}\eif\metaB{})$
  \item $(\metaA{}\eiff\metaB{})$

\end{enumerate}

%\item \textit{Induction Step}: assume antecedent of point 2

\end{enumerate}

%\item I want to give an example of complete induction for a claim about the language {\it{SL}} for sentential logic, since we'll be doing a bunch of that in the coming weeks.

%That is, it's just the part of {\it{SL}} that has atomic sentences, parentheses, and ``\&".

\end{itemize} 
\end{frame}

\iffalse

\begin{frame}
\frametitle{Complete Induction for the language {\it{SL}}}

\begin{itemize}[<+->]
\item Implicitly, this special schema is Complete Induction over the string length $k$ of an SL sentence

\item To simplify, let's use a fragment of {\it{SL}} that contains just atomic sentences and sentences whose only connective is ``$\&$''

\item We can use induction because this rudimentary part of {\it{SL}} has a recursive definition:

\begin{enumerate}
\item {\emph{Base clause}}: Every atomic sentence is a sentence of {\it{SL}}

\item {\emph{Recursion clause}}: If \metav{P} and \metav{Q} are sentences of {\it{SL}}, then $(\metav{P} \eand \metav{Q})$ is a sentence of {\it{SL}}

\item {\emph{Closure clause}}: Nothing else is a sentence of (our fragment of) {\it{SL}}
%unless it results from application of the recursion clause to the expressions specified in the base case.
%, except what you get by beginning with $aab$ and repeatedly applying the Recursion Clause
\end{enumerate}

\end{itemize} 
\end{frame}

\fi 

\frame{\frametitle{Example: Induction on SL, using disjunctive syllogism}
\large

Prove the following by induction on wffs of SL. Don't forget to explicitly state the \textbf{base case} and the \textbf{induction step}! 

\begin{enumerate}[<+->]

%\item No wff begins or ends with a binary connective

%\item No wff contains two consecutive binary connectives (i.e. with no symbols between them)
%note that proof of these presupposes claim 1

\item If a wff doesn't contain any binary connectives, then it is contingent. %\\ \normalsize{

\item hint: say that a wff is \textit{baller} if it either contains a binary connective or is contingent. \\ -- Use induction to show that every wff is baller. 

\item Final step (disjunctive syllogism): if (i) every wff is baller and (ii) a given wff doesn't contain any binary connectives, then (iii) it must be baller in virtue of being contingent. 

% Proof sketch: basecase: an arbitrary atomic formula is contingent (true if assigned true; false when assigned false). Then, consider two arbitrary well-formed formula that have the property, i.e. are Baller. If $Phi$ is contingent, then so is its negation (its negation is true whenever phi is false and false whenever phi is true). If Phi has a binary connective, then so does its negation. Then, consider the four cases coming from connecting Phi and psi with a binary connective. Clearly, each of these has a binary connective, and so is Baller. Hence, every formula is Baller. Hence, if a well-formed formula does not contain any binary connectives, since it is still Baller, it must be contingent (disjunctive syllogism)

\end{enumerate}
}

\begin{frame}
\frametitle{Baller Induction: Base Case}
%\large

\begin{itemize}[<+->]

\item[] \textbf{Base case}: this comprises the atomic sentences. So consider an arbitrary atomic sentence. 

\item Note that it is contingent: there exists a TVA where it is true, and a distinct TVA where it is false. 

\item Hence, every member in the base case is baller

%\item[] \textbf{Induction Step} (using our `lazy SL' schema): consider two arbitrary well-formed formula \metaA{} and \metaB{} that have the property, i.e. are baller. Show that any way of forming a more complex wff from these two also has the property. 


\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Baller Induction: Induction Step}
%\large

\begin{itemize}[<+->]

\item[] \textbf{Induction Step} (using our `lazy SL' schema): consider two arbitrary well-formed formula \metaA{} and \metaB{} that have the property, i.e. are baller. Show that any way of forming a more complex wff from these two also has the property. 

\bi

\item[i.] (a) If \metaA{} is contingent, then so is its negation (its negation is true whenever \metaA{} is false and false whenever \metaA{} is true). \\ (b) If \metaA{} has a binary connective, then so does its negation $\enot \metaA{}$.

\item[ii.--v.] Then, consider the four cases coming from connecting \metaA{} and \metaB{} with a binary connective (\eand, \eor, \eif, or \eiff). Clearly, each of these wffs has a binary connective and so is baller. 

\item Hence, every wff is baller. 
\ei

\item Hence, if a well-formed formula does not contain any binary connectives, since it is still baller, it must be contingent (disjunctive syllogism)

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Non-lazy Induction Schema for SL}
%\large

\begin{itemize}[<+->]

\item[] \textbf{Induction Hypothesis}: assume that every SL wff of string-length $n$, where $1 \leq n < k$ has the property, i.e. is baller. Show that an arbitrary wff of length $k$ is baller. 



\item[] \textbf{Induction Step}: Consider an arbitrary SL wff $\Delta$ of length $k$. Then by the recursive definition of SL wffs, there must exist shorter wffs \metaA{} and \metaB{} such that $\Delta$ equals either (i) $\enot  \metaA{}$, (ii) $\metaA{} \eand \metaB{}$, (iii) $\metaA{} \eor \metaB{}$, (iv) $\metaA{} \eif \metaB{}$, or (v) $\metaA{} \eiff \metaB{}$. 

\item Proceed to show that in each case, $\Delta$ has the property, i.e. is baller. 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Key Fact about Conditionals}
%\large

\begin{itemize}[<+->]

\item Consider a conditional $P \eif Q$. If a truth value assignment satisfies the consequent $Q$, then it satisfies the conditional (regardless of the truth value of $P$)



\end{itemize}
\end{frame}

\subsection{Trees}

\begin{frame}
\frametitle{Tree-contradictions and Tree-tautologies}
%\large

 \begin{block}{\emph{Tree-contradiction}}
    \begin{itemize}[<+->]
      \item A sentence $\Phi$ is a tree-contradiction if there is a tree that starts with $\Phi$ that has only closed branches

  \item (definition only requires the existence of a single such tree)

  \item (it says nothing about \textit{all} trees starting with $\Phi$)
\end{itemize} 
\end{block}

\begin{block}<4->{\emph{Tree-tautology}}
    \begin{itemize}[<+->]
      \item A sentence $\Psi$ is a tree-tautology if there is a tree that starts with $\enot \Psi$ that has only closed branches

\item i.e., provided that $\enot \Psi$ is a tree-contradiction

\item In this case, we write `$\vdash_{STD} \Psi$'

  \item (again: this definition requires the existence of single such tree)

 % \item (it says nothing about all trees starting with $\Psi$)
\end{itemize} 
\end{block}



% \uncover<8->{Notice that these definitions leave open the possibility that a sentence could be both a tree-contradiction and a tree-tautology}

\end{frame}

\begin{frame}
\frametitle{Tree-valid vs. Tree-invalid}
%\large

\begin{itemize}[<+->]

\item Consider an argument with premises given by a set $\Gamma$ of wffs and conclusion $\Phi $ (i.e. $\Gamma$ could be multiple sentences)

\item Construct a tree with the following root: all sentences in $\Gamma$ along with $\enot \Phi $ (i.e. the NEGATION of the conclusion)

\item Next, apply the tree-rules until either

\bigskip

\begin{enumerate}[1.)]

\item \emph{Each branch closes}, in which case the argument is \emph{tree-valid}

\medskip $\bullet$ In this case, we write $\Gamma \vdash_{STD} \Phi $

\bigskip

\item You have \textcolor{OGlyallpink}{a complete open branch}, in which case the argument is \textcolor{OGlyallpink}{\textbf{tree-invalid}}

%\medskip $\bullet$ In this case, we write $\Gamma \nvdash_{STD}  \Phi $ \\ (at least, we can write this once we've shown STD is sound)
%note that I actually SHOULDN'T say this, since later we'll use this symbol to mean `it's not the case that an argument is tree-valid', and just knowing that an argument is tree-invalid DOES NOT on its own entail that it is not tree-valid 

\end{enumerate}


\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Using trees to check for Validity}
%\large

Since most homework problems follow this pattern, let's make it really explicit!

\begin{enumerate}[<+->]

\item Add each premise to the root (number each line)

\item Add the \textbf{NEGATION} of the conclusion to the root

\item Resolve sentences until either:

\medskip

\begin{itemize}

\item \emph{Each branch closes}, in which case the argument is \emph{valid}

\item You have \textcolor{OGlyallpink}{a complete open branch} $\Rightarrow$ the argument is \textcolor{OGlyallpink}{\textbf{invalid}}

\end{itemize}

\end{enumerate}

Don't forget to \emph{justify each new node} by citing the line you are resolving and the rule you are applying

\uncover<7->{Remember that a branch closes whenever a sentence and its negation appear in its nodes (these need not be atomic sentences)}

\end{frame}

\begin{frame}
\frametitle{Using trees to check Tautologies}
%\large

Likewise for whether a sentence is a tautology:

\begin{enumerate}[<+->]

%\item Add each premise to the root (number each line)

\item Add the \textbf{NEGATION} of the sentence to the root

\item Resolve sentences until either:

\medskip

\begin{itemize}

\item \emph{Each branch closes}, in which case the sentence is \emph{tautologous} \\ (semantic aside: it's impossible to make the sentence false)

\item You have \textcolor{OGlyallpink}{a complete open branch}, in which case the sentence is NOT a tautology \\ (semantic aside: it is possible to satisfy the sentence's negation, so it's possible to make the sentence in question false)
% \textcolor{OGlyallpink}{\textbf{invalid}}

\end{itemize}

\end{enumerate}

\end{frame}

\begin{frame}
\frametitle{Trees: easy things to forget}
%\large

\begin{itemize}[<+->]

\item Remember to number each line, i.e. each horizontal row of sentences gets its own line number

\item Remember to justify each child node by citing the line number of the sentence you are resolving and listing the rule you are using

\item Remember to justify any closed branches ($\times$) by citing the line numbers of a sentence and its negation on that branch

\item Don't apply any semantic equivalencies! e.g. to resolve $\enot (\enot D \eor E)$ you write $\enot \enot D$ stacked on $\enot E$. You cannot immediately write `$D$'. To get $D$, you would have to apply the double negation rule to $\enot \enot D$



\end{itemize}
\end{frame}

\subsection{Trees Metalogic: Testing Alternative Rules}

\begin{frame}
\frametitle{Soundness vs. completeness}
%\large

\begin{itemize}[<+->]

\item Both soundness and completeness are if-then statements (i.e. of the form $P \eif Q$):

\begin{itemize}

\item \emph{Sound}: If $\Gamma \vdash_{STD} \Theta$, then $\Gamma \entails \Theta$

\item \emph{Complete}: If $\Gamma \entails \Theta$, then $\Gamma \vdash_{STD} \Theta$

\end{itemize}

\bigskip

\item Hence, they are logically equivalent to their contrapositives: 

\bi

\item Contrapositive of ($P \eif Q$) is ($\enot Q \eif \enot P$)

\item \emph{Soundness}: If $\Gamma \nentails \Theta$, then $\Gamma \nvdash_{STD} \Theta$ 

\item \emph{Completeness}: If $\Gamma \nvdash_{STD} \Theta$, then $\Gamma \nentails \Theta$

\ei 

%\bigskip

%\item We will prove the contrapositives, using induction! Wooooo!


\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Some Definitions}
%\large

\begin{itemize}[<+->]

\item ``$\Gamma \nvdash_{STD} \Theta$'' means that \textit{it is not the case that} the argument from \\ $\Gamma$ to $\Theta$ is  \emph{tree-valid}

\item i.e., \textit{it is not the case that} there exists a tree with root $\Gamma \cup \{\enot \Theta \}$ that possesses \emph{all closed branches}

\item \textcolor{OGlyallpink}{Equivalently}: ANY tree with root $\Gamma \cup \{\enot \Theta \}$ possesses \\ \phantom{\emph{Equivalently}:}  \textbf{at least one \textcolor{OGlyallpink}{complete open branch}}

\item (Aside: this is NOT the same as saying that the argument is \textcolor{OGlyallpink}{\textbf{tree-invalid}}, since that only requires the existence of a single tree with a complete open branch) 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Modifying system STD}
%\large

\begin{itemize}[<+->]

\item What if we had chosen an alternative rule(s)? 

\item Simplest case: we swap out one of our nine rules for a different rule, i.e. for a given connective or negated connective. 

\item Call our modified system `$STD^{\ast}$'%E.g. the following:

%\end{itemize}


%\begin{itemize}[<+->]

\item Would our modified system $STD^{\ast}$ remain Sound?

\item Would our modified system $STD^{\ast}$ remain Complete?

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Some Study Advice}
%\large

\begin{itemize}[<+->]

\item I recommend writing out on a `cheat sheet' the following steps for checking whether a modified rule preserves (i) soundness or \\ (ii) completeness

\item In each case, note on your sheet the method for extending the \\ (i) soundness or (ii) completeness proof

\item Note the method for constructing a counterexample, i.e. what it would take to have (i) a counterexample to soundness or \\ (ii) a counterexample to completeness

\item You probably want to have this information right in front of you during the exam, rather than to be scrambling looking for it


\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Checking Soundness: ``top-down" reasoning}
%\large

\begin{itemize}[<+->]

\item \emph{Heuristic for Soundness checking}: consider an \emph{arbitrary} truth value assignment (TVA) that satisfies the sentence being resolved (i.e. \textit{makes true} the sentence `at the top' of the rule)

\item Ask whether this TVA guarantees that \emph{at least one} child-node is satisfied, i.e. the sentences on that child-node are all made true

\item If `\emph{yes}', then the rule preserves soundness: proceed to extend our soundness proof for this case (reasoning in terms of a TVA `\metav{I}'). 

\item If `\textbf{\textcolor{OGlyallpink}{no}}', then the rule BREAKS soundness: \\ proceed to \textbf{\textcolor{OGlyallpink}{construct a counter-example}} using the rule 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Counterexamples to Soundness}
%\large

\begin{itemize}[<+->]

\item To show soundness fails, it is NECESSARY to provide a CONCRETE counterexample, using SL sentences
% % in saying this, am I endorsing a constructivist norm on rigor? For what would prevent someone from being satisfied with a more abstract argument by contradiction, where we do not construct a concrete counterexample? 

\bi

\item Further heuristic reasoning about TVAs is not enough!

\ei

\bigskip

\item What you need for a counterexample to soundness:

\begin{enumerate}[1.)]

\item Choose a satisfiable root, i.e. a \textbf{\textcolor{OGlyallpink}{consistent}} set of sentences

\item Apply the modified rule in the tree; you may also use other rules that we've already shown preserve soundness

\item Show that the tree \emph{closes} (i.e. NO \textcolor{OGlyallpink}{complete open branches})

\end{enumerate}

\end{itemize}
\end{frame}



\begin{frame}
\frametitle{Why such Counterexamples work}
%\large

\begin{itemize}[<+->]

\item \emph{Sound}: If $\Gamma \vdash_{STD^{\ast}} \Theta$, then $\Gamma \entails \Theta$

\item Counterexample: $\Gamma \vdash_{STD^{\ast}} \Theta$ but $\Gamma \nentails \Theta$:


\bi

\item `$\Gamma \vdash_{STD^{\ast}} \Theta$' means tree with root $\Gamma \cup \{\enot \Theta \}$ \emph{CLOSES} \\ (i.e. is tree-valid in system $STD^{\ast}$)

\item `$\Gamma \nentails \Theta$' means that $\Gamma \cup \{\enot \Theta \}$ is \textbf{\textcolor{OGlyallpink}{CONSISTENT}} (i.e. satisfiable) \\ (i.e. there exists a TVA that makes the premises $\Gamma$ true \\ but the conclusion $\Theta$ false) 

\ei 

\bigskip

\item If our system \textit{were} sound, then whenever a tree closes, it \textit{would} correspond to a semantically valid argument. 

\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Checking Completeness: ``bottom-up" reasoning}
%\large

\begin{itemize}[<+->]

\item \emph{Heuristic for Completeness checking}: ask whether \textbf{EACH} child node (below) individually entails the sentence being resolved \\ (i.e. the sentence `up top', in the `parent-node')
%consider an \emph{arbitrary} truth value assignment (TVA) that satisfies 
%the sentence being resolved (i.e. \textit{makes true} the sentence `at the top' of the rule)

%\item For each child node, consider an arbitrary TVA that satisfies its sentences. Ask whether this TVA guarantees that the sentence being resolved is satisfied

\item If `\emph{yes}', then the rule preserves completeness: \\ proceed to extend our completeness proof for this case (reasoning in terms of arbitrary TVA's, one for each child node). 

\item If `\textbf{\textcolor{OGlyallpink}{no}}', then the rule BREAKS completeness: \\ proceed to \textbf{\textcolor{OGlyallpink}{construct a counter-example}} using the rule. 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Counterexamples to Completeness}
%\large

\begin{itemize}[<+->]

\item To show completeness fails, it is NECESSARY to provide a CONCRETE counterexample, using SL sentences
% % in saying this, am I endorsing a constructivist norm on rigor? For what would prevent someone from being satisfied with a more abstract argument by contradiction, where we do not construct a concrete counterexample? 

\bi

\item Further heuristic reasoning about TVAs is not enough!

\ei

\bigskip

\item What you need for a counterexample to completeness:

\begin{enumerate}[1.)]

\item Choose an \emph{UNsatisfiable root}, i.e. an INconsistent set of sentences

\item Apply the modified rule in the tree; you may also use other rules that we've already shown preserve completeness

\item Show that the tree has a \textbf{\textcolor{OGlyallpink}{complete open branch}}, \\ i.e. does NOT close
% (i.e. complete open branches)

\end{enumerate}

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Why such Counterexamples work}
%\large

\begin{itemize}[<+->]

%%need to fix this! since the PS5 result requires partial completeness. so here maybe we're doing a kind of reductio: IF the system were complete, then every unsatisfiable root would have to close. but by constructing a tree w/ unsatisfiable root that remains open, we show a counterexample! 


\item \emph{Complete}: If $\Gamma \entails \Theta$, then $\Gamma \vdash_{STD^{\ast}} \Theta$

\item Counterexample: $\Gamma \entails \Theta$ but $\Gamma \nvdash_{STD^{\ast}} \Theta$

%\item Counterexample: If $\Gamma \nvdash_{STD} \Theta$, then $\Gamma \nentails \Theta$



\bi

\item `$\Gamma \entails \Theta$' means that $\Gamma \cup \{\enot \Theta \}$ is INconsistent (i.e. UNsatisfiable) \\ (i.e. any TVA that makes $\Gamma$ true makes the conclusion $\Theta$ true) 

\item `$\Gamma \nvdash_{STD^{\ast}} \Theta$' means that it is NOT the case that the argument is tree-valid in $STD^{\ast}$ (a claim about ALL trees)

\item From completeness proof, we know that if the system \textit{were} complete, then we could use any \textbf{\textcolor{OGlyallpink}{complete open branch}} to construct a TVA that \textbf{\textcolor{OGlyallpink}{satisfies}} the root

\item Hence, if we construct a \textbf{\textcolor{OGlyallpink}{complete open tree}} with an \emph{unsatisfiable root}, this is a reductio of completeness

\end{itemize}

%\item So then it suffices to construct a complete open tree

% % Perhaps Another way of putting the reductio: by the PS5 result, if the system were complete, then any tree-invalid argument could not be tree valid. So assume system is complete, for reductio. Then construct a tree-invalid argument. This would entail it's not valid. which then is the desired counterexample to completeness. But the logic here is a bit less clear for some reason...

%\item Note: the following argument fails, since the PS5 result requires the system in question to be `partially complete': Technically this is a claim about ALL trees, but we typically help ourselves to soundness, in which case \\ tree-invalid $\Rightarrow$ not tree-valid (see PS5 question). 



%%but maybe it's the case that with our simple counterexamples, we basically consider ALL such trees or come close to it. so actually COULD reason about all such trees w/ the given root. often just two premises, so could permute. 

% tree with root $\Gamma \cup \{\enot \Theta \}$ CLOSES \\ (i.e. is tree-valid in system $STD^{\ast}$)



%\bigskip

%\item actually not sure if the following is an accurate rendition, since again a claim about tree-validity is technically just a claim about the existence of a single tree. If our system \textit{were} complete, then whenever the root is unsatisfiable, the tree would close. 

 %a tree is complete and open, it \textit{would} correspond to a semantically valid argument. 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A Common Mistake to Avoid!!!!}
%\large

\begin{itemize}[<+->]

\item You are very liable to forget to COMPLETE YOUR open branch!!!

\item You only have a counterexample to completeness if you have a COMPLETE open branch with an unsatisfiable root

\item So make sure you FULLY RESOLVE every sentence on the open branch, until you can write that coveted up arrow `$\uparrow$'! 

\item When in doubt, just complete the whole tree 


\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Liberal Conditional and Conservative Biconditional}
%\large

\begin{multicols}{2}

$STD^{\ast}$: replace rule (\eif) with: \\ 


\begin{center}
\textit{Liberal Conditional} (L\eif) \vspace{1em}
\begin{prooftree}
{line numbering, single branches}
[\metaA{}\eif\metaB{}, line no override={m}
[\vdots, vdotsline={\\[-0.55em] \vdots}, grouped
	[\enot\metaA{}, line no override={j}, just={m L\eif}]
	[\metaB{} \eor \metaA{}]
]
]
\end{prooftree}
\end{center}

\columnbreak

 \uncover<2->{$STD^{\dagger}$: replace rule (\eiff) with: \\


\begin{center}
\textit{Conservative Biconditional} (C\eiff) \vspace{1em}
\begin{prooftree}
{line numbering, single branches}
[\metaA{}\eiff\metaB{}, line no override={m}
[\vdots, vdotsline={\\[-0.55em] \vdots}, grouped
	[\metaA{}, line no override={j}, just={m C\eiff}
		[\metaB{}, grouped, line no override={j+1}]
	]
]
]
\end{prooftree}
\end{center}
}

\end{multicols}

\end{frame}

\begin{frame}
\frametitle{Conservative Biconditional}

\begin{itemize}[<+->]

\item Reason from the top-down: \\ $\metaA{}\eiff\metaB{}$ is logically equivalent to $(\metaA{} \eand \metaB{}) \eor (\enot \metaA{} \eand \enot \metaB{})$ 

\item The node below is logically equivalent to $(\metaA{} \eand \metaB{})$

\item Note that the top does NOT entail the bottom! Given an interpretation that satisfies  $\metaA{}\eiff\metaB{}$, it is NOT guaranteed to satisfy the sentence(s) in at least one branch below. 

\item Hence, \emph{to the counterexample!} \\ (note that the problem REQUIRES this! can't stop won't stop!) 

%\emph{Formally}: assume $\metaA{}\eif\metaB{}$ is true according to \metav{I}. Then \metav{I} assigns 0 to \metaA{} or 1 to \metaB{} (or both). Either way, \metav{I} assigns 1 to $(\enot \metaA{}) \eor (\metaB{} \eor \metaA{})$. 

%entails at least one branch below (indeed, it entails both!)


% (L\eif)  preserves soundness: applying our 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Counterexample to Soundness of $STD^{\dagger}$}
%\large

\begin{itemize}[<+->]

\item For a counterexample, need: $\Gamma \vdash_{STD^{\dagger}} \Theta$ but $\Gamma \nentails \Theta$

%\end{itemize}

\medskip

 \uncover<2->{$STD^{\dagger}$: replace rule (\eiff) with \textit{Conservative Biconditional} (C\eiff): \\ 


\begin{center}
\begin{prooftree}
{line numbering, single branches}
[P\eiff P, just=Premise (PR)
[\enot P, grouped, just={\enot Conclusion}
	[P, just={1 C\eiff}
		[P, grouped, close={2, 3, so tree-valid in $STD^{\dagger}$}]
	]
]
]
\end{prooftree}
\end{center}
}

%\begin{itemize}[<+->]

\medskip

\item<3-> But $(P \eiff P) \nentails P$ because  $\{(P \eiff P), \; \enot P\}$ is consistent! \\ Assign `P' false! N.B.: your counterexample MUST use actual sentences of SL; not meta-variables!

\end{itemize}



\end{frame}


\begin{frame}
\frametitle{Conservative Biconditional (bottoms up!)}

\begin{itemize}[<+->]

\item Reason from the bottom up: there is only one child node. So we only need its sentences to entail $\metaA{}\eiff\metaB{}$

\item Sentences on bottom are equivalent to $(\metaA{} \eand \metaB{})$, which DOES entail $\metaA{}\eiff\metaB{}$. So we proceed to formally extend our completeness proof: 

\bigskip 

\bi 

\item \emph{Formally}: since only one child node, both $\metaA{}$ and $\metaB{}$ lie on the complete open branch $O$. 

\item By induction hypothesis, both are true according to \metav{I}. 

\item Hence, $\metaA{}\eiff\metaB{}$ is true on \metav{I}, which is what we needed to show. 

\ei 

%\item \emph{Formally}: assume $(\metaA{} \eand \metaB{})$ is true according to \metav{I}. Then \metav{I} must assign 1 to both \metaA{} and \metaB{}. Hence, $\metaA{}\eiff\metaB{}$ is true on \metav{I}. 

\end{itemize}
\end{frame}



\subsection{Translation/Symbolization in SL}

\begin{frame}
\frametitle{Unless}
%\large

\begin{itemize}[<+->]

\item Translate `unless' as `or' (unless you want to make things needlessly complicated for yourself!)

\item Example: I am not going to not Vote in the midterms, unless a meteor Destroys my polling place and the city of Cambridge does not give me an Alternative location.

\item $\enot \enot V \eor (D \eand \enot A)$

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Provided that; lonely if; given: these flip the order!}
%\large

\begin{itemize}[<+->]

\item `Q provided that P' is `If P, then Q'

\item So just like the ``lonely if''!

\item `Q if P' is `If P, then Q'

\item Likewise for `Q given P': `If P, then Q' 

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Only if}
%\large

\begin{itemize}[<+->]

\item `P only if Q' is `If P, then Q'

\item so order is preserved:

\item Intuition: `P only if Q' means `If not Q, then not P', which is `$\enot Q \eif \enot P$', i.e. a contrapositive

\item A contrapositive is logically equivalent to its conditional: $P \eif Q$

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Just in Case}
%\large

\begin{itemize}[<+->]

\item Translate ``just in case'' as ``if and only if"

\item Example: I will do Well in this class just in case I do not Party every night.

\item $W \eiff \enot P$

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{`Although' and `But'}
%\large

\begin{itemize}[<+->]

\item both `although' and `but' are translated as `and'

\item i.e. schematized as $\eand$

\item Example: Although I Meditate every day, I remain an Anxious person, but I Hope to overcome this in the future.

\item $(M \eand A) \eand H$ 


\end{itemize}
\end{frame}



\subsection{Truth Tables: (In)Validity and (In)Equivalence}

\begin{frame}
\frametitle{Proving an argument is Valid}
%\large

\begin{itemize}[<+->]

\item To use a truth table to prove that an argument is valid, one must:

\item Complete the entire truth table!

\item One must show that there is no truth value assignment that makes all of the premises true while making the conclusion false \\ (i.e. no counterexamples to validity)

\item Equivalently: every TVA that makes the premises true makes the conclusion true 

\item (note that this `every' claim is vacuously true if your conclusion is a tautology, since a tautology is not false on any TVA)

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Proving an argument is Invalid}
%\large

\begin{itemize}[<+->]

\item To prove that an argument is invalid, it suffices to:

\item Identify at least one truth value assignment that makes the premises true but the conclusion false

\item In this case, unnecessary to complete the entire truth table

\item \textit{Carnap} will let you enter the relevant TVA as a counterexample to validity (make sure you understand the syntax for this!)


\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Proving that two sentences are Equivalent}
%\large

\begin{itemize}[<+->]

\item Using a truth table, to prove that two sentences are equivalent:

\item You must complete the entire table!

\item You must show that the two sentences receive the same truth value for every possible truth value assignment (i.e. every row of the truth table)

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Proving that two Sentences are Inequivalent}
%\large

\begin{itemize}[<+->]

\item Suffices to identify a single TVA where the sentences have different truth values

\item In this case, unnecessary to complete the entire truth table

\item \textit{Carnap} will let you enter the relevant TVA as a counterexample to equivalence

\end{itemize}
\end{frame}

\subsection{Natural Deduction}

\begin{frame}
\frametitle{Some rules to Definitely Understand}
%\large

\begin{itemize}[<+->]

\item Disjunction Elimination

\item Conditional Introduction

\item Negation introduction; Negation Elimination

\item Understand when and how to start a subproof

\item For rules that cite a subproof, remember to use a HYPHEN between line numbers in the justification (you are citing the ENTIRE subproof, even in those cases where the sub proof is itself only 2 lines long)

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Using Conditional Introduction $\eif I$}
%\large

\begin{itemize}[<+->]

\item If you need to construct a conditional, typically you assume the antecedent, starting a subproof (tab in and write :AS after the antecedent)

\item Derive the consequent within the subproof

\item Exit the subproof by writing the conditional and justifying with $\eif I$


\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Common Mistake with Negation Rules}
%\large

\begin{itemize}[<+->]

\item Don't forget that you need both a sentence \metaB{} and $\enot \metaB{}$ WITHIN the subproof, i.e. under the assumption line

\item Often, if you are using a sentence that has already occurred as one of the \metaB{} or $\enot \metaB{}$, you will need to reiterate it on a line within the subproof

\item  \textit{Carnap} seems to be a bit fussy: the  \metaB{} and $\enot \metaB{}$ cannot themselves be separated by a subproof within your subproof 



\end{itemize}
\end{frame}