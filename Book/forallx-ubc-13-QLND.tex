%!TEX root = forallx-ubc.tex
\chapter{Natural Deduction in QL$^=$}
\label{ch.QLND}


% Trees employ a kind of `brute force' strategy for proving entailment claims.
% When the logical structure of the relevant sentences is rather simple, as it is in SL and in some QL cases, it can be an effective strategy.
% But in other cases, trees become tedious and complex.
% It is useful to have a proof system that allows one to reason in a more targeted way --- especially if you already have an intuitive understanding of why a given argument should be expected to turn out valid.

This chapter extends our system SD to provide a natural deduction system for QL$^=$ which we will refer to as QD.
% Like our natural deduction system for SL, our system can only be used to demonstrate that an argument \emph{is} valid since natural deduction systems do not demonstrate that an argument is \emph{invalid}.
% In this respect natural deduction differs from trees.
We won't go through the proof in this book, but QD is both sound and complete with respect to the semantics for QL$^=$.
That means that there are natural deduction proofs corresponding to all and only the valid arguments in QL$^=$.

Our QL system will include the same introduction and elimination rules that we provided for the sentential connectives included in SL, but now we will add introduction and elimination rules for the quantifiers and identity, deriving a number of new rules.



\section{Substitution Instances}

%to reformat the substitution instances, see the commands \unisub and \freesub in the style file. 

Consider the following claims:

\begin{earg}
  \item[\ex{I1}] Kin loves everything.
  \item[\ex{I2}] Kin loves Cassandra.
  \item[\ex{I3}] Kin loves something.
\end{earg}

Sentence \ref{I2} is referred to as an \textit{instance} of both sentences \ref{I1} and \ref{I3}. % since it is about something particular.
We will define what it is to be an instance below, but for now you can think of the instances of a general claim as being about a particular.
Whereas sentence \ref{I1} makes a universal claim about everything, sentence \ref{I2} makes a particular claim about one thing, and sentence \ref{I3} makes an existential claim about something.
It is important to distinguish between all three types of sentences, where one way to do this is to appeal to their logical strength, i.e., which sentences entail which.
Specifically, sentence \ref{I1} entails sentence \ref{I2} but not \textit{vice versa}, and sentence \ref{I2} entails sentence \ref{I3} but not \textit{vice versa}.
Similarly, sentence \ref{I1} entails sentence \ref{I3} but not \textit{vice versa}.
It is worth nothing that this entailment would not hold if we permitted the domain to be empty since, given an empty domain, sentence \ref{I1} could be true while sentence \ref{I3} is false.

% We will refer to sentence \ref{I2} as an \define{instance} of sentence \ref{I1}, and refer to \ref{I3} as an \define{existential generalisation} of \ref{I2}.

We may regiment the sentences above with the following symbolization key:

\begin{multicols}{2}
  
\begin{ekey}
  \item[Lxy:] $x$ loves $y$ 
  \item[k:] Kin
  \item[c:] Cassandra
\end{ekey}

\begin{earg}
  \item[\ex{I4}] $\forall xLkx$.
  \item[\ex{I5}] $Lkc$.
  \item[\ex{I6}] $\exists xLkx$.
\end{earg}

\end{multicols}

Given that sentence \ref{I4} entails sentence \ref{I5} and sentence $\ref{I5}$ entails sentence $\ref{I6}$, we should expect a complete logic for QL$^=$ to include rules by which to derive sentence $\ref{I6}$ from sentence $\ref{I5}$, and to derive sentence $\ref{I5}$ from sentence $\ref{I4}$. 
In order to state these rules in a sufficiently general way we will need to make use of the notion of substitution from before.
In particular, recall the following definition from $\S\ref{sec:Quantities}$ where $\alpha$ and $\beta$ are any singular terms:

\factoidbox{
  $\beta$ is \define{free for} $\alpha$ in $\metaA$ just in case there is no free occurrence of $\alpha$ in $\metaA$ in the scope of a quantifier that binds $\beta$.
}

Roughly speaking, $\beta$ is free for $\alpha$ just in case $\beta$ can replace $\alpha$ without resulting in any extra binding.
Whereas $z$ is free for $x$ in `$\qt{\forall}{y}(Fxy \supset Fyx)$' since replacing `$x$' with `$z$' would yield `$\qt{\forall}{y}(Fzy \supset Fyz)$', the variable $y$ is not free for $x$ in `$\qt{\forall}{y}(Fxy \supset Fyx)$' since replacing `$x$' with `$y$' yields `$\qt{\forall}{y}(Fyy \supset Fyy)$' where the quantifier `$\forall y$' ends up binding an extra variable.

If $\beta$ is a constant, it follows that $\beta$ is free for any $\alpha$ in any wff $\metaA$. 
Given this definition, we may define substitution as in $\S\ref{sec:Quantities}$, where $\alpha$ and $\beta$ are any singular terms of the language.

\factoidbox{
   If $\beta$ is free for $\alpha$ in $\metaA$, then the \define{substitution} $\metaA\unisub{\beta}{\alpha}$ is the result of replacing all free occurrences of $\alpha$ in $\metaA$ with $\beta$. 
}

We may read `$\metaA\unisub{\beta}{\alpha}$' as `$\beta$ for $\alpha$ in $\metaA$'.
For instance, $\qt{\forall}{y}(Fxy \supset Fyx)\unisub{z}{x}$ is the wff $\qt{\forall}{y}(Fzy \supset Fyz)$ and $\qt{\forall}{y}(Fxy \supset Fyx)\unisub{y}{x}$ is undefined since $y$ is not free for $x$.
We may also observe that $\qt{\forall}{y}(Fxy \supset Fyx)\unisub{y}{z}$ and $\qt{\forall}{y}(Fxy \supset Fyx)\unisub{z}{y}$ are both $\qt{\forall}{y}(Fxy \supset Fxy)$.

This new vocabulary permits us to define the substitution instances of both universal and existential generalisations of the form $\qt{\forall}{\alpha}\metaA$ and $\qt{\exists}{\alpha}\metaA$.
In particular, consider the following:

\factoidbox{
  $\metaA\unisub{\beta}{\alpha}$ is a \define{substitution instance} of $\qt{\forall}{\alpha}\metaA$ and $\qt{\exists}{\alpha}\metaA$ if $\beta$ is a constant. 
}

Since $\beta$ is a constant, the requirement that $\beta$ is free for $\alpha$ in $\metaA$ is satisfied.
In particular, $Fxc \supset Fcx$ is an instance of $\qt{\forall}{y}(Fxy \supset Fyx)\unisub{z}{x}$ which is the result of stripping off the quantifier binding $y$ and replacing all free occurrences of $y$ with $c$. 
Nothing forced us to choose the constant $c$.
Instead, we could have used $d$, producing the instance $Fxd \supset Fdx$.
Both of these are instances, and in general, there will be a different instance for every constant in the language.
By contrast, the instances of $\qt{\forall}{y}(Fxy \supset \qt{\exists}{y}Fyx)$ include such wffs as $Fxc \supset \qt{\exists}{y}Fyx$ and $Fxd \supset \qt{\exists}{y}Fyx$ where in both cases the second occurrence of $y$ is not replaced since it is not free. 
The constants here are referred to as \define{instantiating constants}.




\subsection{Universal Elimination}
  \label{sec:UniElim}

Recall $\qt{\forall}{x} Lkx$ from before.
We claimed that $Lkc$ was entailed by $\qt{\forall}{x} Lkx$, but now we are in a position to state this a little more precisely.
To begin with, we may observe that $Lkc$ is a substitution instance of $\qt{\forall}{x} Lkx$.
More generally, universally quantified claims entail all of their substitution instances.
In order to maintain completeness, we may include the following elimination rule ($\forall$E) so that the substitution instances of a universally quantified claim can be derived from that universally quantified claim:

\begin{proof}
	\have[m]{a}{\qt{\forall}{\alpha}\metaA}
	\have[ ]{c}{\metaA\unisub{\beta}{\alpha}} \by{$\forall$E ~~where $\beta$ is a constant}{a} 
\end{proof}

Remember that the notation for a substitution instance is not a part of QL$^=$, so you cannot write it directly in a proof.
Instead, you write the substitution instance itself including whichever constant $\beta$ is being used to replace the variable $\alpha$ as in this example:

\begin{proof}
	\hypo{a}{\qt{\forall}{x}(Mx \eif Rxd)} \pr{}
	\have{c}{Ma \eif Rad} \Ae{a}
	\have{d}{Md \eif Rdd} \Ae{a}
\end{proof}

%This rule is very similar to the tree rule for universals, which, in our tree system, allowed one to develop a branch containing a universal with any instance of it one likes. 
You are permitted to write down any instance you like on a new line. In this example, we have used the rule twice to produce two instances. In the first case, we instantiate with the constant $a$ and we instantiate with the constant $d$ in the second case. 






\subsection{Existential Introduction}
  \label{sec:ExistIntro}

Recall that $Lkc$ was said to entail $\qt{\exists}{x} Lkx$.
Given that Kin loves Cassandra, it follows that Kin loves someone.
More generally, any existentially quantified claim is entailed by its substitution instances.
In order to preserve completeness, we may capture these entailments in our proof system by including the following existential introduction rule ($\exists$I):

\begin{proof}
  \have[m]{a}{\metaA\unisub{\beta}{\alpha}} \by{where $\beta$ is a constant and $\alpha$ is a variable}{}  
	\have[\ ]{c}{\qt{\exists}{\alpha}\metaA} \Ei{a}  
\end{proof}

In the example above, $\metaA\unisub{\beta}{\alpha}=Lkx\unisub{c}{x}=Lkc$.
Given $\exists$I, we may derive $\qt{\exists}{\alpha}\metaA=\exists xLkx$ by existentially generalising on $c$.
Alternatively, we could have existentially generalised on $k$, deriving $\exists xLxc$ given that $\metaA\unisub{\beta}{\alpha}=Lxc\unisub{k}{x}=Lkc$. 
Both $Lkx\unisub{c}{x}$ and $Lxc\unisub{k}{x}$ are identical to $Lkc$. 
Similarly, instead of deriving $\qt{\exists}{x}Lkx$ and $\qt{\exists}{x}Lxc$ from $Lkc$, we could have used the variable $y$ to derive $\qt{\exists}{y}Lky$ and $\qt{\exists}{y}Lyc$ since $Lkc$ is also identical to $Lky\unisub{c}{y}$ and $Lyc\unisub{k}{y}$.
Something similar may be said for other variables.

The example above only included one occurrence of each constant.
By contrast, the sentence $Ma \eif Rad$ has two occurrences of the constant $a$.
As a result, we may existentially generalise on either occurrence of $a$ by itself, both occurrences together, or neither.
Consider:

\begin{proof}
	\hypo{a}{Ma \eif Rad} \pr{}
	\have{d}{\qt{\exists}{x}(Mx \eif Rad)} \Ei{a}
	\have{b}{\qt{\exists}{x}(Ma \eif Rxd)} \Ei{a}
	\have{c}{\qt{\exists}{x}(Mx \eif Rxd)} \Ei{a}
	\have{k}{\qt{\exists}{x}(Ma \eif Rad)} \Ei{a}
	\have{e}{\qt{\exists}{y}\qt{\exists}{x}(Mx \eif Ryd)} \Ei{d}
	\have{f}{\qt{\exists}{z}\qt{\exists}{y}\qt{\exists}{x}(Mx \eif Ryz)} \Ei{e}
\end{proof}

Whereas line $2$ existentially generalises on the first occurrence of the constant $a$, line $3$ generalises on the second occurrence, and line $4$ generalises on both. 
Focusing on line $2$, $\metaA\unisub{\beta}{\alpha}=(Mx \supset Rad)\unisub{a}{x}=(Ma \supset Rad)$, where similar identities hold for the other lines.
For line $4$ we have $\metaA\unisub{\beta}{\alpha}=(Mx \supset Rxd)\unisub{a}{x}=(Ma \supset Rad)$, and for line $5$ we have $\metaA\unisub{\beta}{\alpha}=(Ma \supset Rad)\unisub{a}{x}=(Ma \supset Rad)$.
In lines $6$ and $7$, one existential generalisation is staged after the next, even if they generalise on difference occurrences of the same constant. 

Put roughly, existential generalisation permits one to replace any number of occurrences of a constant with a variable that is then bound by an existential quantifier.
Strictly speaking, this approximation is not correct since we cannot generalise as follows:

\begin{proof}
	\hypo{a}{\qt{\exists}{x}(Mx \eif Rad)} \pr{}
  \have{e}{\qt{\exists}{x}\qt{\exists}{x}(Mx \eif Rxd)} \by{$\exists$I (\textsc{incorrect})}{a}
	\have{c}{\qt{\exists}{y}\qt{\exists}{x}(Mx \eif Ryd)} \Ei{d}
\end{proof}

Whereas line $3$ is the same as line $6$ above and perfectly correct, line $2$ does not follow by existential generalisation.
The reason is that we cannot construct an appropriate $\metaA\unisub{\beta}{\alpha}$.
For instance, we cannot take $\metaA\unisub{\beta}{\alpha}=\qt{\exists}{x}(Mx \eif Rxd)\unisub{a}{x}$ given the scope of the quantifier since $\qt{\exists}{x}(Mx \eif Rxd)\unisub{a}{x}$ is not identical to the premise $\qt{\exists}{x}(Mx \eif Rad)$.
By contrast, $\metaA\unisub{\beta}{\alpha}=\qt{\exists}{x}(Mx \eif Ryd)\unisub{a}{y}$ is acceptable since $\qt{\exists}{x}(Mx \eif Ryd)\unisub{a}{y}=\qt{\exists}{x}(Mx \eif Rad)$ which is identical to the premise.
Thus we may derive $\exists y\qt{\exists}{x}(Mx \eif Ryd)$ on line $3$ by $\exists$I.

Whereas replacing $a$ with $x$ results in a quantifier which is already present picking up an extra bound variable, this does not happen if we replace $a$ with $y$ instead. 
The existential generalisation rule is stated in such a way so as to ensure that this extra binding cannot occur without breaking the rule.
Nevertheless, it is important to be careful in generalising existentially to follow the rule accurately, where checking to see if you pick up any extra variable binding is an easy way to check to see if you are following the rule.




\subsection{Universal Introduction}
  \label{sec:UniIntro}

The rules provided above permit us to derive sentence $\ref{I5}$ from $\ref{I4}$ and to derive $\ref{I6}$ from $\ref{I5}$.
As we noted above, the converse derivations do not hold.
After all, just because Kin loves Cassandra (\ref{I5}), it does not follow that Kin loves everything (\ref{I4}).
Similarly, just because Kin loves something (\ref{I6}), it does not follow that Kin loves Cassandra (\ref{I5}).
More generally, universal claims are not entailed by their substitution instances, and existential claims do not entail their substitution instances.
Nevertheless, it is possible derive universal claims from their instances in specific circumstances, and similarly, it is possible to derive an instance of an existential claim in certain circumstances.
The following two section will introduce these derivation rules, discussing the conditions of their application.

One way to think about a universal claim of the form $\qt{\forall}{\alpha}\metaA\alpha$ is as a long conjunction $\metaA\unisub{a}{\alpha} \eand \metaA\unisub{b}{\alpha} \eand\ldots$ where the constants $a,b,\ldots$ name every element in the domain.
However, this way of thinking is limited since we may not have enough constants to name every element in the domain, and even if there were enough constants to go around, they could all be interpreted by the same element of the domain on a given interpretation.
These considerations are what motivated the introduction of variable assignments which we could quantify over in the semantics.
In particular, $\VV{\I}{\va{a}}(\forall\alpha\metaA)=1$ just in case $\VV{\I}{\va{c}}(\metaA)=1$ for every $\alpha$-variant $\va{c}$ of $\va{a}$.
We may simulate something analogous in the proof system for QL$^=$ by way of constants that do not occur in the premises of the derivation or in the universal claim that we are looking to derive.
Some examples will help to illustrate.

Consider the following sentences:

\begin{earg}
  \item[\ex{I7}] $\qt{\forall}{x} Mx$.
  \item[\ex{I8}] $\qt{\forall}{y} My$.
\end{earg}

It is natural to assume that these sentences are logically equivalent for indeed they say the very same thing, i.e., that everything is $M$.
Insofar as these entailments are to be reflected in the proof system, we need a way to derive sentence \ref{I8} from sentence \ref{I7} and \textit{vice versa}.

Consider the following derivation:

\begin{proof}
	\hypo{x}{\qt{\forall}{x} Mx} \pr{}
	\have{a}{Ma} \Ae{x}
	\have{y}{\qt{\forall}{y} My} \Ai{a}
\end{proof}

In line $2$, we have derived $Ma$ from $\qt{\forall}{x}Mx$ by $\forall$E given above.
We could have equally derived $Mb$ or $M\alpha$ for any other constant $\alpha$.
This much should come as no surprise.
What is more surprising is the derivation of $\qt{\forall}{y}My$ in line $3$ from $Ma$ in line $2$.
After all, this is like the inference from `Alan is mad' to `everyone is mad' which is easy to invalidate.
You might wonder what kind of constraints would make this inference to hold.

The key idea behind the inference from line $2$ to line $3$ is that $a$ is an arbitrary constant. 
In particular, $a$ does not occur in the premise, nor does $a$ occur in line $3$ which we are deriving, and so there are no constraints on what $a$ might name. 
Rather, the constant $a$ could name anything whatsoever. 
You can think of $a$ as analogous to $\va{c}(x)$ for an arbitrary $x$-variant $\va{c}$ which permits us to quantify over all elements of the domain.
Given that $a$ could refer to anything, we may derive line $3$.
Although we used the variable $y$ in line $3$, we could have used $x$, or indeed any other variable since there is no threat of any extra variable binding taking place.
This puts us in a position to articulate the universal introduction rule ($\forall$I):

\begin{proof}
  \have[m]{a}{\metaA\unisub{\beta}{\alpha}} \by{where $\beta$ is a constant and $\alpha$ is a variable}{}  
  \have[ ]{c}{\qt{\forall}{\alpha}\metaA} \by{$\forall$I where $\beta$ does not occur here or in any undischarged assumptions}{a}
\end{proof}

It is easy to see that the inference from line $2$ to line $3$ in the proof given above follows this rule.
For contrast, consider the following incorrect application:

\begin{proof}
	\hypo{a}{\qt{\forall}{x} Rxa} \pr{}
	\have{b}{Raa} \Ae{a}
  \have{c}{\qt{\forall}{y} Ryy} \by{$\forall$I (\textsc{incorrect})}{b}
\end{proof}

Intuitively, this argument would be like inferring the conclusion that everything respects itself from the premise that everything respects Arthur.
Even if it follows from the premise that Arthur respects himself, it does not follow that everything respects itself.
% The derivation above goes wrong in that the constant $a$ occurs in the premise which is an assumption that we never discharge. 
The reason the derivation goes astray is that $a$ is not an arbitrary constant since it occurs in the premise which is an undischarged assumption.
In particular, we might take $a$ to name Arthur.
Even if $a$ named something else, it's interpretation would still be constrained in any interpretation in which the premise is true.
% Although $Raa$ may hold, the same cannot be said for $Rbb$ and so on for any arbitrary constant $b$ that does not occur in any undischarged assumption since then there would not be any constraint on what $b$ might name in an interpretation that makes the premises true. 
As a result, the constant $a$ is not arbitrary in way that we need it to be if we are to universally generalise on $a$ with the rule $\forall$I. 

We have just seen one way that $\forall$I can go wrong by offending the constraint that the instantiating constant not occur in an undischarged assumption.
What about the other constraint?
In order to bring this out, consider the following:

\begin{proof}
	\hypo{a}{\qt{\forall}{x} Rxx} \pr{}
	\have{b}{Raa} \Ae{a}
  \have{c}{\qt{\forall}{x} Rax} \by{$\forall$I (\textsc{incorrect})}{b}
\end{proof}

This argument infers that Arthur respects everything from the premise that everything respects itself.
Letting $\metaA\unisub{\beta}{\alpha}=Rax\unisub{a}{x}=Raa$, we may observe that $\qt{\forall}{x}\metaA=\qt{\forall}{x}Rax$, and so one might have thought that we could derive $\qt{\forall}{x}Rax$ from $Raa$.
This would have been correct but for the provision that $\beta$ not occur in $\qt{\forall}{\alpha}\metaA$ which in the case above requires that $a$ not occur in $\qt{\forall}{x}Rax$.
Since $a$ does occur in $\qt{\forall}{x}Rax$, line $3$ does not follow from line $2$.

A good way to remember the restrictions on the $\forall$I rule is to remember that these restriction are put in place to require the instantiating constant to be \textit{arbitrary}.
In particular, we want the instantiating constant that we are generalising of to be arbitrary, and so it cannot occur in any undischarged assumptions or in the sentence that we are deriving.
The incorrect inferences above are paradigmatic of cases where these requirements are not satisfied.

Although the constant $\alpha$ is not permitted to occur in any undischarged assumption, it may occur in an assumption of a subproof that we have already closed.
For example, here is a perfectly respectable proof of $\qt{\forall}{z}(Dz \eif Dz)$ from no premises.

\begin{proof}
	\open
		\hypo{f1}{Df} \as{}
		\have{f2}{Df} \by{R}{f1}
	\close
	\have{ff}{Df \eif Df}\ci{f1-f2}
	\have{zz}{\qt{\forall}{z}(Dz \eif Dz)}\Ai{ff}
\end{proof}

Since the assumption given in line $1$ above has been discharged, the instantiating constant $f$ does not occur in any undischarged assumptions, and so line $4$ follows from line $3$ by $\forall$I. 



\subsection{Existential Elimination}
  \label{sec:ExistElim}

A sentence with an existential quantifier tells us that \textit{something} satisfies a given condition.
For example, letting `$S$' regiment `is sad' and `$M$' regiment `is mad', the existential claims $\qt{\exists}{x} Sx$ and $\qt{\exists}{y} Sy$ say that something is sad and that something is mad but they don't tell us \textit{what} is sad or mad.
In particular, we cannot conclude that the same thing is sad and mad.
This worry can be brought out with the following incorrect derivation:

\begin{proof}
  \hypo{b}{\qt{\exists}{x} Sx} \pr{}
	\hypo{a}{\qt{\exists}{y} My} \pr{}
  \have{d}{Sa} \by{$\exists$I (\textsc{incorrect})}{b} 
  \have{c}{Ma} \by{$\exists$I (\textsc{incorrect})}{a}
  \have{e}{Sa \eand Ma} \ai{c,d}
  \have{f}{\qt{\exists}{z}(Sz \eand Mz)} \Ei{e}
\end{proof}

Whereas $a$ is a perfectly arbitrary constant when it is introduced in line $3$, reusing $a$ in line $4$ leads to the conclusion that the same thing is both sad and mad.
Were we permitted to introduce lines $3$ and $4$ in this way, nothing would stop us from conjoining these claims and existentially generalising, concluding that something is both sad and mad even though this might not be the case.
For instance, one thing could be sad and something else could be mad where nothing requires these to be the same thing. 
Somehow we must prevent these two existential claims from running together as they do above.

Although it is important to avoid concluding too much, this does not mean that we cannot draw any inferences at all from an existential claim.
For instance, suppose that we knew that $\qt{\exists}{x} Sx$ and $\qt{\forall}{x}(Sx \eif Mx)$, or in English, something is sad and, moreover, everything that is sad is also mad.
It is natural to reason in the following way:

\begin{quote}
  By assumption, something is sad.
  Although we do not know what that things is, call it `Bob' for the purposes of this argument.
  We also know by assumption that everything that is sad is mad.
  In particular, if Bob is sad, then Bob is mad.
  Thus Bob is mad.
  Since `Bob' was a name we introduced only for the sake of the argument, we may revert to the more general claim that something is mad.
\end{quote}

Especially for long lines of reasoning, it is often useful to introduce a temporary constant in the manner employed above.
In particular, we want the constant to be arbitrary, and so it cannot occur in any previous assumptions.
At the same time, we also need to keep track of this constant, being careful not to make any other assumptions about the object to which this temporary constant refers, or to draw any conclusions which include this constant.

It will be convenient to refer to an arbitrary constant that is used to temporarily refer to whatever it is that satisfies an existential claim as a \define{proxy}.
Accordingly, our use of a proxy must be restricted to a subproof, where it is in this sense arbitrary and temporary.
This is the schematic form of the existential elimination rule ($\exists$E): 

\begin{proof}
	\have[m]{a}{\qt{\exists}{\alpha}\metaA}
	\open	
    \hypo[n]{b}{\metaA\unisub{\beta}{\alpha}} \as{\strut\hspace{.07in}where $\beta$ is a constant and does not in occur}
    \have[ ]{x}{\vdots} \by{\strut\hspace{.4in}lines $m$, $p$, or any undischarged assumptions}{}
		\have[p]{c}{\metaB}
	\close
	\have[\ ]{d}{\metaB{}} \Ee{a,b-c}
\end{proof}

The restriction on what $\beta$ can be is what prevents $\exists$E from producing invalid arguments as brought out above. 
One easy way to satisfy these restrictions is to always choose a new instantiating constant $\beta$ that does not appear anywhere outside the subproof. 
This practice is in keeping with the idea that $\beta$ is an arbitrary place holder that we make temporary use of inside a subproof in order to expedite the lines of reasoning that we wish to draw.

Like the rules for conditional introduction, negation introduction, and negation elimination, the existential elimination rule is a rule that involves discharging an assumption.
The pattern is to assume a substitution instance with a proxy, reason your way to a conclusion that does not include that proxy, and then discharge the assumption, closing the subproof.

Having introduced the existential elimination rule, we are now in a position to regiment the informal argument given above in which `Bob' served as our proxy.

\begin{proof}
	\hypo{es}{\qt{\exists}{x} Sx} \pr{}
	\hypo{ast}{\qt{\forall}{x}(Sx \eif Mx)} \pr{} 
	\open
		\hypo{s}{Sa}\as{}
		\have{st}{Sa \eif Ma}\Ae{ast}
		\have{t}{Ma} \ce{s,st}
		\have{et1}{\qt{\exists}{x} Mx}\Ei{t}
	\close
	\have{et2}{\qt{\exists}{x} Tx}\Ee{es,s-et1}
\end{proof}

Given the introduction and elimination rules for both the existential and universal quantifiers, we may turn to derive the quantifier exchange rules which will often be useful.




\subsection{Quantifier Exchange Rules}

Sentences of the form $\enot\qt{\exists}{\alpha}\metaA$ and $\qt{\forall}{\alpha}\enot\metaA$ are logically equivalent, as are sentences of the form $\enot\qt{\forall}{\alpha}\metaA$ and $\qt{\exists}{\alpha}\enot\metaA$.
Accordingly, we may assert the following entailments: 

\vspace{.1in}
\begin{enumerate}[leftmargin=.75in]
  \begin{multicols}{2}
    \item[$(\enot\exists)$] $\enot\qt{\exists}{\alpha}\metaA \vDash \qt{\forall}{\alpha}\enot\metaA$.
    \item[$(\enot\forall)$] $\enot\qt{\forall}{\alpha}\metaA \vDash \qt{\exists}{\alpha}\enot\metaA$.
    \item[$(\forall\enot)$] $\qt{\forall}{\alpha}\enot\metaA \vDash \enot\qt{\exists}{\alpha}\metaA$.
    \item[$(\exists\enot)$] $\qt{\exists}{\alpha}\enot\metaA \vDash \enot\qt{\forall}{\alpha}\metaA$.
  \end{multicols}
\end{enumerate}
\vspace{-.05in}

Given the introduction and elimination rules for the quantifiers, we may derive rules which correspond to these entailments.
Consider the following proof for $(\enot\exists)$:

\begin{proof}
	\hypo{a}{\enot\qt{\exists}{\alpha} \metaA}      \pr{}
    \open
      \hypo{b}{\metaA\unisub{\beta}{\alpha}}      \as{where $\beta$ is a new constant}
      \have{c}{\qt{\exists}{\alpha} \metaA}       \Ei{b}
      \have{d}{\enot\qt{\exists}{\alpha} \metaA}  \r{a}
    \close
  \have{e}{\enot\metaA\unisub{\beta}{\alpha}}     \ni{b-d}
  \have{f}{\qt{\forall}{\alpha}\enot\metaA}       \Ai{e}
\end{proof}

This proof works by instantiating $\metaA$ with a new constant $\beta$ in line $2$, and then existentially generalising on $\beta$ in order to derive a contradiction, where $\enot\metaA\unisub{\beta}{\alpha}$ follows by negation introduction. 
Since $\beta$ does not occur in any undischarged assumptions, we may universally generalise on $\beta$ in order to derive the conclusion in line $6$. 

Consider the following proof of the $(\forall\enot)$ which works in the opposite direction: 

\begin{proof}
	\hypo{a}{\enot\qt{\forall}{\alpha} \metaA}      \pr{}
    \open
      \hypo{b}{\qt{\exists}{\alpha}\metaA}        \as{}
      \have{c}{\metaA\unisub{\beta}{\alpha}}      \by{$\exists$E where $\beta$ is a new constant}{b}
      \have{d}{\enot\qt{\forall}{\alpha} \metaA}  \r{a}
    \close
  \have{e}{\enot\metaA\unisub{\beta}{\alpha}}     \ni{b-d}
  \have{f}{\qt{\forall}{\alpha}\enot\metaA}       \ni{e}
\end{proof}



Consider the following proof for $(\enot\exists)$:

\begin{proof}
	\hypo{a}{\enot\qt{\exists}{\alpha} \metaA}      \pr{}
    \open
      \hypo{b}{\metaA\unisub{\beta}{\alpha}}      \as{where $\beta$ is a new constant}
      \have{c}{\qt{\exists}{\alpha} \metaA}       \Ei{b}
      \have{d}{\enot\qt{\exists}{\alpha} \metaA}  \r{a}
    \close
  \have{e}{\enot\metaA\unisub{\beta}{\alpha}}     \ni{b-d}
  \have{f}{\qt{\forall}{\alpha}\enot\metaA}       \ni{e}
\end{proof}



\begin{proof}
	\have{Aa}{\qt{\forall}{\script{x}} \metaA{}} \pr{want $\enot\qt{\exists}{\script{x}}\enot \metaA{}$}
	\open
		\hypo{Ena}{\qt{\exists}{\script{x}}\enot \metaA{}}\as{for reductio}
		\open
			\hypo{nc}{\enot \metaA{\unisub{\script{x}}{\script{a}^\ast}}}\as{for $\exists$E}
			\open
				\hypo{Aa2}{\qt{\forall}{\script{x}} \metaA{}}\as{for reductio}{}
				\have{c2}{\metaA{\unisub{\script{x}}{\script{a}^\ast}}}\Ae{Aa}
				\have{nc2}{\enot \metaA{\unisub{\script{x}}{\script{a}^\ast}}}\by{R}{nc}
			\close
			\have{nAa}{\enot\qt{\forall}{\script{x}} \metaA{}}\ni{Aa2-nc2}
		\close
		\have{nAa3}{\enot\qt{\forall}{\script{x}} \metaA{}}\Ee{Ena, nc-nAa}
		\have{Aa3}{\qt{\forall}{\script{x}} \metaA{}}\by{R}{Aa}
		\close
	\have{nEna}{\enot\qt{\exists}{\script{x}}\enot \metaA{}}\ni{Ena-Aa3}
\end{proof}
$^\ast$ Where name \script{a} does not appear outside the subproof.

This is a proof \emph{schema} --- it is not itself a proof in QL, as its lines are not QL sentences. But it describes how a proof of this form can be given. For example, here is one instance of the above schema:


\begin{proof}
	\hypo{Aa}{\qt{\forall}{y} Ay} \pr{want $\enot\qt{\exists}{y}\enot Ay$}
	\open
		\hypo{Ena}{\qt{\exists}{y}\enot Ay}\as{for reductio}
		\open
			\hypo{nc}{\enot Ac}\as{for $\exists$E}
			\open
				\hypo{Aa2}{\qt{\forall}{y} Ay}\as{for reductio}
				\have{c2}{Ac}\Ae{Aa}
				\have{nc2}{\enot Ac}\by{R}{nc}
			\close
			\have{nAa}{\enot\qt{\forall}{y} Ay}\ni{Aa2-nc2}
		\close
		\have{nAa3}{\enot\qt{\forall}{y} Ay}\Ee{Ena, nc-nAa}
		\have{Aa3}{\qt{\forall}{y} Ay}\by{R}{Aa}
	\close
	\have{nEna}{\enot\qt{\exists}{y}\enot Ay}\ni{Ena-Aa3, Ena-nAa3}
\end{proof}

(Note that this proof encodes the same form of reasoning one would employ to demonstrate via a tree that $\qt{\forall}{y} Ay \models \enot \qt{\exists}{y} \enot Ay$. If you're into TREES and read Chapter~\ref{ch.QLTrees}, you might have fun drawing out the tree to compare the two methods.)

In order to fully demonstrate that $\enot\qt{\exists}{\script{x}}\enot\metaA{}$ is logically equivalent to $\qt{\forall}{\script{x}}\metaA{}$, we would also need a second proof that assumes $\enot\qt{\exists}{\script{x}}\enot\metaA{}$ and derives $\qt{\forall}{\script{x}}\metaA{}$. We leave that proof as an exercise for the reader.

It will often be useful to translate between quantifiers by adding or subtracting negations in this way, so we add two derived rules for this purpose. These rules are called quantifier negation (QN):
\begin{center}
\begin{tabular}{rl}
$\enot\qt{\forall}{\script{x}}\metaA{} \Longleftrightarrow \qt{\exists}{\script{x}}\enot\metaA{}$\\
$\enot\qt{\exists}{\script{x}}\metaA{} \Longleftrightarrow \qt{\forall}{\script{x}}\enot\metaA{}$
& QN
\end{tabular}
\end{center}
QN is a replacement rule. Like our SL replacement rules (DeMorgan, Double Negation, etc.), it can be used on whole sentences or on subformulae.

\section{Identity Introduction}

The introduction rule for identity is very simple. Everything is identical to itself; so, for any name \script{a}, one may write --- regardless of what one has on the previous lines of the proof --- that $\script{a}{=}\script{a}$:

\begin{proof}
	\have[\ \,\,\,]{x}{\script{a}=\script{a}} \by{: =I}{}
\end{proof}

The {=}I rule is unlike our other rules in that it does not require referring to any prior lines of the proof. We need only cite the rule itself; it does not reference any line numbers.

\section{Identity Elimination}

If you have shown that $a{=}b$, then anything that is true of $a$ must also be true of $b$. For any sentence with $a$ in it, you can replace some or all of the occurrences of $a$ with $b$ and produce an equivalent sentence. For example, if you already know $Raa$, then you are justified in concluding $Rab$, $Rba$, $Rbb$. Recall that $\metaA{}\freesub{a}{b}$ is the sentence produced by replacing $a$ in \metaA{} with $b$. This is not the same as a substitution instance, because $b$ may replace some or all occurrences of $a$. The identity elimination rule ({=}E) justifies replacing terms with other terms that are identical to it:
\begin{proof}
	\have[m]{e}{\script{c}{=}\script{d}}
	\have[n]{a}{\metaA{}}
	\have[\ ]{ea1}{\metaA{}\freesub{\script{c}}{\script{d}}} \by{=E}{e,a}
	\have[\ ]{ea2}{\metaA{}\freesub{\script{d}}{\script{c}}} \by{=E}{e,a}
\end{proof}

Here is a simple proof of an instance of the \emph{transitivity of identity}. Let's prove that if $a{=}b$ and $b{=}c$, then $a{=}c$:

\begin{proof}
	\open
		\hypo{p}{a{=}b \eand b{=}c}\pr{want $a{=}c$}
		\have{ab}{a{=}b}\ae{p}
		\have{bc}{b{=}c}\ae{p}
		\have{ac}{a{=}c}\by{{=}E}{ab,bc}
	\close
	\have{conc}{(a{=}b \eand b{=}c)\eif a{=}c} \ci{p-ac}
\end{proof}

At line 4, we took advantage of the identity claim $b{=}c$ on line 3, and replaced the $b$ in line 2 with a $c$. Then we used the familiar \eif{}I rule to discharge the assumption of line 1, proving the conditional we were aiming for.


\section{Translation and evaluation}

Consider this argument: There is only one button in my pocket. There is a blue button in my pocket. So there is no non-blue button in my pocket.

We begin by defining a symbolization key:
\begin{ekey}
\item{UD:} buttons in my pocket
\item{Bx:} $x$ is blue.
\end{ekey}
Because we have no need to discuss anything other than buttons in my pocket, we've restricted the UD accordingly. If we included other things (buttons elsewhere and/or things other than buttons), we'd need predicates corresponding to being a button and things' locations. The simple version here is adequate for our present needs. The argument is translated as:
\begin{earg}
\item{} $\qt{\forall}{x} \qt{\forall}{y}\ x{=}y$
\item{} $\qt{\exists}{x} Bx$
\item{\therefore} $\enot \qt{\exists}{x} \enot Bx$
\end{earg}

So the set-up for a natural deduction proof will be:

\begin{proof}
	\hypo{one}{\qt{\forall}{x}\qt{\forall}{y}\ x{=}y} \pr{}
	\hypo{eb}{\qt{\exists}{x} Bx} \pr{want $\enot\qt{\exists}{x} \enot Bx$}
	\have{}{}{}
%	\open
%		\hypo{be1}{Be}
%		\have{all1}{\qt{\forall}{y}\ e{=}y}\Ae{one}
%		\have{ef1}{e{=}f}\Ae{all1}
%		\have{bf1}{Bf}\by{{=}E}{ef1,be1}
%	\close
%	\have{bf}{Bf}\Ee{eb,be1-bf1}
%	\have{ab}{\qt{\forall}{x} Bx}\Ai{bf}
%	\have{nnab}{\enot\enot\qt{\forall}{x} Bx}\by{DN}{ab}
%	\have{nenb}{\enot\qt{\exists}{x}\enot Bx}\by{QN}{nnab}
\end{proof}

There are various strategies one might employ. Here are two clues that point toward one promising strategy. Note again that we have an existential on line 2 --- this suggests existential elimination as a possible strategy. Note also that we are aiming for $\enot \qt{\exists}{x} \enot Bx$, which equivalent to $\enot \enot \qt{\forall}{x} Bx$ by QN. This in turn is equivalent, by DN, to $\qt{\forall}{x} Bx$, which suggests that universal introduction is going to be an important step. If we introduce an assumption with a proxy instance of $\qt{\exists}{x} Bx$, we'll be able to work toward a generic instance of $Bx$. In this example, we'll take $e$ as our proxy, and show that $Bf$ follows from $\qt{\exists}{x} Bx$:

\begin{proof}
	\hypo{one}{\qt{\forall}{x}\qt{\forall}{y}\ x{=}y} \pr{}
	\hypo{eb}{\qt{\exists}{x} Bx} \pr{want $\enot\qt{\exists}{x} \enot Bx$}
	\open
		\hypo{be1}{Be}\as{for $\exists${}E}
		\have{all1}{\qt{\forall}{y}\ e{=}y}\Ae{one}
		\have{ef1}{e{=}f}\Ae{all1}
		\have{bf1}{Bf}\by{{=}E}{ef1,be1}
	\close
	\have{bf}{Bf}\Ee{eb,be1-bf1}
%	\have{ab}{\qt{\forall}{x} Bx}\Ai{bf}
%	\have{nnab}{\enot\enot\qt{\forall}{x} Bx}\by{DN}{ab}
%	\have{nenb}{\enot\qt{\exists}{x}\enot Bx}\by{QN}{nnab}
\end{proof}

By line 7, we have discharged the assumption about the proxy --- we won't use the name $e$ any more --- we have established that $Bf$ follows from the two premises. Since $f$ is an arbitrary name --- one that does not appear in any undischarged assumption --- we can perform universal introduction on that instance. This in turn lets us complete the proof via the two substitution rules mentioned above:

\begin{proof}
	\hypo{one}{\qt{\forall}{x}\qt{\forall}{y}\ x{=}y} \pr{}
	\hypo{eb}{\qt{\exists}{x} Bx} \pr{want $\enot\qt{\exists}{x} \enot Bx$}
	\open
		\hypo{be1}{Be}\as{for $\exists${}E}
		\have{all1}{\qt{\forall}{y}\ e{=}y}\Ae{one}
		\have{ef1}{e{=}f}\Ae{all1}
		\have{bf1}{Bf}\by{{=}E}{ef1,be1}
	\close
	\have{bf}{Bf}\Ee{eb,be1-bf1}
	\have{ab}{\qt{\forall}{x} Bx}\Ai{bf}
	\have{nnab}{\enot\enot\qt{\forall}{x} Bx}\by{DN}{ab}
	\have{nenb}{\enot\qt{\exists}{x}\enot Bx}\by{QN}{nnab}
\end{proof}



\section{Natural deduction strategy}

All the strategy advice given in \S\ref{sec.SL.ND.strategy} is equally applicable to natural deduction proofs in QL. Review the suggestions there for general advice for natural deduction proofs. Applied to our new QL rules, if you have a universal, you can think about taking any instances that look useful. (Taking random instances is unlikely to be useful.) If you have an existential, consider using the existential elimination rule, which begins by assuming an instance with a proxy, then deriving a conclusion that does not contain that proxy name.

Showing $\enot \qt{\exists}{x}\metaA{}$ can also be hard, and it is often easier to show  $\qt{\forall}{x}\enot \metaA{}$ and use the QN rule. {\color{black} Although technically in \textit{Carnap}---using system LogicBookPD---you won't have access to this rule QN of quantifier conversion! Sorry not sorry!} 



\section{Soundness and completeness}

The proofs for soundness and completeness of our natural deduction system are beyond the scope of this textbook {\color{black} (but not beyond the scope of the MIT version of this course!)}. If you are interested in thinking through how those proofs would go, here are a few hints to get you started. Soundness in a natural deduction system amounts to the claim that if any sentence \metaA{} is derivable from a set of sentences \metaSetX{}, then $\metaSetX{}\models\metaA{}$. To prove this, you would need to demonstrate that any possible natural deduction proof meets this constraint. This is trivial for `proofs' that only contain premises; you'd next have to show, for every possible way of extending the proof (i.e., everything permitted by any one of our rules), that any newly added lines with no undischarged assumptions are entailed by the premises.

Undischarged assumptions would require special treatment. You can think of an assumption as being similar to a `temporary premise' --- what you really want to prove is that, for every possible line in a proof, that line is entailed by the premises \emph{in addition to} any undischarged assumptions.

The completeness proof is more complex. We need some way to guarantee that there is a proof corresponding to every QL entailment. The way to do this is to find an algorithmic procedure that is guaranteed to find a proof if one exists, and to prove that this is so. One good way to do this is to take advantage of the proven completeness of our \emph{tree} system for QL, presented in Chapter \ref{ch.QLsoundcomplete}, and find a way to demonstrate that any tree proof can be converted to a natural deduction proof. Here is a hint if you'd like to undertake that project: the tree method encodes the same kind of reasoning that reductio proofs do.



\iffalse

\practiceproblems

\solutions
\problempart
\label{pr.justifyQLproof}
Provide a justification (rule and line numbers) for each line of proof that requires one.
\begin{multicols}{2}
%$\{\qt{\forall}{x}(\qt{\exists}{y})(Rxy \eor Ryx),\qt{\forall}{x}\enot Rmx\}\vdash\qt{\exists}{x}Rxm$
\begin{proof}
\hypo{p1}{\qt{\forall}{x}\qt{\exists}{y}(Rxy \eor Ryx)}
\have{p2}{\qt{\forall}{x}\enot Rmx}
\have{3}{\qt{\exists}{y}(Rmy \eor Rym)}{}
	\open
		\hypo{a1}{Rma \eor Ram}
		\have{a2}{\enot Rma}{}
		\have{a3}{Ram}{}
		\have{a4}{\qt{\exists}{x} Rxm}{}
	\close
\have{n}{\qt{\exists}{x} Rxm} {}
\end{proof}

%$\{\qt{\forall}{x}(\qt{\exists}{y}Lxy \eif \qt{\forall}{z}Lzx), Lab\} \vdash \qt{\forall}{x}Lxx$
\begin{proof}
\hypo{1}{\qt{\forall}{x}(\qt{\exists}{y}Lxy \eif \qt{\forall}{z}Lzx)}
\hypo{2}{Lab}
\have{3}{\qt{\exists}{y} Lay \eif \qt{\forall}{z}Lza}{}
\have{4}{\qt{\exists}{y} Lay} {}
\have{5}{\qt{\forall}{z} Lza} {}
\have{6}{Lca}{}
\have{7}{\qt{\exists}{y} Lcy \eif \qt{\forall}{z}Lzc}{}
\have{8}{\qt{\exists}{y} Lcy}{}
\have{9}{\qt{\forall}{z} Lzc}{}
\have{10}{Lcc}{}
\have{11}{\qt{\forall}{x} Lxx}{}
\end{proof}


% $\{\qt{\forall}{x}(Jx \eif Kx), \qt{\exists}{x}\qt{\forall}{y} Lxy, \qt{\forall}{x} Jx\} \vdash \qt{\exists}{x}(Kx \eand Lxx)$
\begin{proof}
\hypo{a}{\qt{\forall}{x}(Jx \eif Kx)}
\hypo{b}{\qt{\exists}{x}\qt{\forall}{y} Lxy}
\hypo{c}{\qt{\forall}{x} Jx}
\open
	\hypo{2}{\qt{\forall}{y} Lay}
	\have{d}{Ja}{}
	\have{e}{Ja \eif Ka}{}
	\have{f}{Ka}{}
	\have{3}{Laa}{}
	\have{4}{Ka \eand Laa}{}
	\have{5}{\qt{\exists}{x}(Kx \eand Lxx)}{}
\close
\have{j}{\qt{\exists}{x}(Kx \eand Lxx)}{}
\end{proof}


%$\vdash \qt{\exists}{x} Mx \eor \qt{\forall}{x}\enot Mx$
\begin{proof}
	\open
		\hypo{p1}{\enot (\qt{\exists}{x} Mx \eor \qt{\forall}{x}\enot Mx)}
		\have{p2}{\enot \qt{\exists}{x} Mx \eand \enot \qt{\forall}{x}\enot Mx}{}
		\have{p3}{\enot \qt{\exists}{x} Mx}{}
		\have{p4}{\qt{\forall}{x}\enot Mx}{}
		\have{p5}{\enot \qt{\forall}{x}\enot Mx}{}
	\close
\have{n}{\qt{\exists}{x} Mx \eor \qt{\forall}{x}\enot Mx} {}
\end{proof}
\end{multicols}

\solutions
\problempart
\label{pr.someQLproofs}
Provide a natural deduction proof of each claim.
\begin{earg}
\item $\vdash \qt{\forall}{x} Fx \eor \enot \qt{\forall}{x} Fx$
\item $\{\qt{\forall}{x}(Mx \eiff Nx), Ma\eand\qt{\exists}{x} Rxa\}\vdash \qt{\exists}{x} Nx$
\item $\{\qt{\forall}{x}(\enot Mx \eor Ljx), \qt{\forall}{x}(Bx\eif Ljx), \qt{\forall}{x}(Mx\eor Bx)\}\vdash \qt{\forall}{x}Ljx$
\item $\qt{\forall}{x}(Cx \eand Dt)\vdash \qt{\forall}{x}Cx \eand Dt$
\item $\qt{\exists}{x}(Cx \eor Dt)\vdash \qt{\exists}{x} Cx \eor Dt$
\end{earg}

\problempart
Provide a proof of the argument about Billy on p.~\pageref{surgeon2}.



\problempart
\label{pr.BarbaraEtc.proof1}
Look back at Part \ref{pr.BarbaraEtc} on p.~\pageref{pr.BarbaraEtc}. Provide proofs to show that each of the argument forms is valid in QL.




\solutions
\problempart
\label{pr.QLproofsNDe}
Provide a natural deduction proof of each claim.
\begin{earg}
\item $\qt{\forall}{x} \qt{\forall}{y} Gxy\vdash\qt{\exists}{x} Gxx$
\item $\qt{\forall}{x} \qt{\forall}{y} (Gxy \eif Gyx) \vdash \qt{\forall}{x}\qt{\forall}{y} (Gxy \eiff Gyx)$
\item $\{\qt{\forall}{x}(Ax\eif Bx), \qt{\exists}{x} Ax\} \vdash \qt{\exists}{x} Bx$
\item $\{Na \eif \qt{\forall}{x}(Mx \eiff Ma), Ma, \enot Mb\}\vdash \enot Na$
\item $\vdash\qt{\forall}{z} (Pz \eor \enot Pz)$
\item $\vdash\qt{\forall}{x} Rxx\eif \qt{\exists}{x} \qt{\exists}{y} Rxy$
\item $\vdash\qt{\forall}{y} \qt{\exists}{x} (Qy \eif Qx)$
\end{earg}



\problempart
Show that each pair of sentences is provably equivalent.
\begin{earg}
\item $\qt{\forall}{x} (Ax\eif \enot Bx)$, $\enot\qt{\exists}{x}(Ax \eand Bx)$
\item $\qt{\forall}{x} (\enot Ax\eif Bd)$, $\qt{\forall}{x} Ax \eor Bd$
\item $\qt{\exists}{x} Px \eif Qc$, $\qt{\forall}{x} (Px \eif Qc)$
\end{earg}



\problempart
Show that each of the following is provably inconsistent.
\begin{earg}
\item \{$Sa\eif Tm$, $Tm \eif Sa$, $Tm \eand \enot Sa$\}
\item \{$\enot\qt{\exists}{x} Rxa$, $\qt{\forall}{x} \qt{\forall}{y} Ryx$\}
\item \{$\enot\qt{\exists}{x} \qt{\exists}{y} Lxy$, $Laa$\}
\item \{$\qt{\forall}{x}(Px \eif Qx)$, $\qt{\forall}{z}(Pz \eif Rz)$, $\qt{\forall}{y} Py$, $\enot Qa \eand \enot Rb$\}
\end{earg}



\solutions
\problempart
\label{pr.likes}
Write a symbolization key for the following argument, translate it, and prove it:
\begin{quote}
There is someone who likes everyone who likes everyone that first person likes. Therefore, there is someone who likes themself.
\end{quote}

\problempart
\label{pr.identity}
Provide a proof of each claim.
\begin{earg}
\item $\{Pa \eor Qb, Qb \eif b{=}c, \enot Pa\}\vdash Qc$
\item $\{m{=}n \eor n{=}o, An\}\vdash Am \eor Ao$
\item $\{\qt{\forall}{x} \: x{=}m, Rma\}\vdash \qt{\exists}{x} Rxx$
\item $\enot \qt{\exists}{x} \: x {\neq} m \vdash \qt{\forall}{x}\qt{\forall}{y} (Px \eif Py)$
\item $\qt{\forall}{x}\qt{\forall}{y}(Rxy \eif x{=}y)\vdash Rab \eif Rba$
\item $\{\qt{\exists}{x} Jx, \qt{\exists}{x} \enot Jx\}\vdash \qt{\exists}{x} \qt{\exists}{y}\ x{\neq} y$
\item $\{\qt{\forall}{x}(x{=}n \eiff Mx), \qt{\forall}{x}(Ox \eor \enot Mx)\}\vdash On$
\item $\{\qt{\exists}{x} Dx, \qt{\forall}{x}(x{=}p \eiff Dx)\}\vdash Dp$
\item $\{\qt{\exists}{x}\bigl[Kx \eand \qt{\forall}{y}(Ky \eif x{=}y) \eand Bx\bigr], Kd\}\vdash Bd$
\item $\vdash Pa \eif \qt{\forall}{x}(Px \eor x {\neq} a)$
\end{earg}



\solutions
\problempart
\label{pr.QLequivornot}
For each of the following pairs of sentences: If they are logically equivalent in QL, give proofs to show this. If they are not, construct a model to show this.
% TODO: this isn't a great problem set in the context, as ND isn't an appropriate method for demonstrating invalidity. Figure out what to do about this.
\begin{earg}
\item $\qt{\forall}{x} Px \eif Qc$, $\qt{\forall}{x} (Px \eif Qc)$
\item $\qt{\forall}{x} Px \eand Qc$, $\qt{\forall}{x} (Px \eand Qc)$
\item $Qc \eor \qt{\exists}{x} Qx$, $\qt{\exists}{x} (Qc \eor Qx)$
\item $\qt{\forall}{x}\qt{\forall}{y} \qt{\forall}{z} Bxyz$, $\qt{\forall}{x} Bxxx$
\item $\qt{\forall}{x}\qt{\forall}{y} Dxy$, $\qt{\forall}{y}\qt{\forall}{x} Dxy$
\item $\qt{\exists}{x}\qt{\forall}{y} Dxy$, $\qt{\forall}{y}\qt{\exists}{x} Dxy$
\end{earg}

\solutions
\problempart
\label{pr.QLvalidornot}
For each of the following arguments: If it is valid in QL, give a proof. If it is invalid, construct a model to show that it is invalid.
% TODO: this isn't a great problem set in the context, as ND isn't an appropriate method for demonstrating invalidity. Figure out what to do about this.
\begin{earg}
\item $\qt{\forall}{x}\qt{\exists}{y} Rxy$, \therefore\ $\qt{\exists}{y}\qt{\forall}{x} Rxy$
\item $\qt{\exists}{y}\qt{\forall}{x} Rxy$, \therefore\ $\qt{\forall}{x}\qt{\exists}{y} Rxy$
\item $\qt{\exists}{x}(Px \eand \enot Qx)$, \therefore\ $\qt{\forall}{x}(Px \eif \enot Qx)$
\item $\qt{\forall}{x}(Sx \eif Ta)$, $Sd$, \therefore\ $Ta$
\item $\qt{\forall}{x}(Ax\eif Bx)$, $\qt{\forall}{x}(Bx \eif Cx)$, \therefore\ $\qt{\forall}{x}(Ax \eif Cx)$
\item $\qt{\exists}{x}(Dx \eor Ex)$, $\qt{\forall}{x}(Dx \eif Fx)$, \therefore\ $\qt{\exists}{x}(Dx \eand Fx)$
\item $\qt{\forall}{x}\qt{\forall}{y}(Rxy \eor Ryx)$, \therefore\ $Rjj$
\item $\qt{\exists}{x}\qt{\exists}{y}(Rxy \eor Ryx)$, \therefore\ $Rjj$
\item $\qt{\forall}{x} Px \eif \qt{\forall}{x} Qx$, $\qt{\exists}{x} \enot Px$, \therefore\ $\qt{\exists}{x} \enot Qx$
\item $\qt{\exists}{x} Mx \eif \qt{\exists}{x} Nx$, $\enot \qt{\exists}{x} Nx$, \therefore\ $\qt{\forall}{x} \enot Mx$
\end{earg}

\problempart
\label{pr.QLND.trees1}
Look at the arguments given in Chapter \ref{ch.QLTrees}, Problem Part \ref{pr.QL.trees.translation.and.validity} (page \pageref{pr.QL.trees.translation.and.validity}). For those arguments whose QL translations are valid, prove their validity via natural deduction.

\problempart
\label{pr.QLND.trees2}
Look at the entailment claims given in Chapter \ref{ch.identity}, Problem Part \ref{pr.IdentityTrees} (page \pageref{pr.IdentityTrees}). For those entailment claims that are true, prove them via natural deduction.

\problempart
\label{pr.QLND.trees3}
Look at the arguments given in Chapter \ref{ch.identity}, Problem Part \ref{pr.IdentityArguments} (page \pageref{pr.IdentityArguments}). For those arguments whose QL translations are valid, prove their validity via natural deduction.

\fi
