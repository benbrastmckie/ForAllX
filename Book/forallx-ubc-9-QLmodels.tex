%!TEX root = forallx-ubc.tex
\chapter{A formal semantics for QL}
\label{ch.QL.models}
\chaptermark{Formal semantics for {QL}}
%see here: looks complicated:
%https://tex.stackexchange.com/questions/476957/capitalize-first-letter-of-words-in-chapter-mark

% Need to figure out how to capitalize `QL' in the running header, maybe need to define a special label (like i did in dissertation)

%JH: when ichikawa talks about `defining truth' in this chapter and for SL, what he really means is defining truth CONDITIONS
%logic of variable assignments and satisfiability semantics: we are temporarily making variables into constants: assigning a constant to each individual variable. basically converting open sentences (those with free variables) into wffs so that we can assign them truth values. 

%gameplan is to rewrite the truth-condition seciton using Logic Book Section 8.1, especially pages 338 and 339 which really do a much better job explaining this stuff. Should also make clear, like the logic book does, that one does not need to understand this bit of formal semantics to appreciate the important semantic notions of entailment, validity, and consistency in QL. For those, suffices to understand notion of truth in a model. 

In this chapter, we describe a \emph{formal semantics} for QL. This corresponds to the discussion of interpretations and truth in SL given in Chapter \ref{ch.SLmodels}. Like truth in SL, truth in QL is determined by a particular interpretation; entailment is a matter of truth in all interpretations. In SL, we emphasized the partial valuation functions provided by interpretations, limiting the domain to the atomic sentences involved in a given set of sentences. These corresponded to rows of the truth table. For example, a model \script{I} might have provided these assignments:

\begin{displaymath}
\script{I} :
\left\{
	\begin{array}{ll}
	P = 0\\
	Q = 1\\
	R = 0
	\end{array}
\right.
\end{displaymath}

Interpretation \script{I} settles the truth value of any SL sentence one can construct from $P$, $Q$, and $R$. All the elements of SL {\color{black}are truth-functional, their truth-values determined by those of the atomic sentences that compose them}. Because QL involves richer notions and a more complex vocabulary than SL, it requires correspondingly richer information from its models.

\section{Interpretations in QL}

%%% FROM last chapter

Given the symbolization key we have been using, $\qt{\forall}{x}Hx$ means `Everyone is happy.' Who is included in this \emph{everyone}? When we use sentences like this in English, we usually do not mean everyone now alive on the Earth. We certainly do not mean everyone who was ever alive or who will ever live. We mean something more modest: everyone in the building, everyone in the class, or everyone in the room.

In order to eliminate this ambiguity, we will need to specify a \define{universe of discourse} --- abbreviated UD {\color{black} (less grandiosely, we might call this the ``domain of discourse.'')}. The UD is the set of things that we are talking about. So if we want to talk about people in Chicago, we define the UD to be people in Chicago. We write this at the beginning of the symbolization key, like this:
\begin{ekey}
\item[UD:] people in Chicago
\end{ekey}
The quantifiers \emph{range over} the universe of discourse. Given this UD, $\qt{\forall}{x}$ means `Everyone in Chicago' and $\qt{\exists}{x}$ means `Someone in Chicago.' Each constant names some member of the UD, so we can only use this UD with the symbolization key above if Donald, Gregor, and Marybeth are all in Chicago. If we want to talk about people in places besides Chicago, then we need to include those people in the UD.

In QL, the UD must be \emph{non-empty}; that is, it must include at least one thing. It is possible to construct formal languages that allow for empty UDs, but this introduces complications; such languages are beyond the scope of this book.

Even allowing for a UD with just one member can produce some strange results. Suppose we have this as a symbolization key:
\begin{ekey}
\item[UD:] the Eiffel Tower
\item[Px:] $x$ is in Paris.
\end{ekey}
The sentence $\qt{\forall}{x} Px$ might be paraphrased in English as `Everything is in Paris.' Yet that would be misleading. It means that everything \emph{in the UD} is in Paris. This UD contains only the Eiffel Tower, so with this symbolization key $\qt{\forall}{x} Px$ just means that the Eiffel Tower is in Paris. We will rarely work with such bizarre domains as this.

It is a rule in QL that each constant will pick out exactly one member of the UD. (There is no rule prohibiting multiple different constants from referring to the same member of the UD.)

%\subsection{Non-referring terms}
%In QL, each constant must pick out exactly one member of the UD. A constant cannot refer to more than one thing --- it is a \emph{singular} term. Each constant must still pick out \emph{something}. This is connected to a classic philosophical problem: the so-called problem of non-referring terms.
%
%Medieval philosophers typically used sentences about the \emph{chimera} to exemplify this problem. Chimera is a mythological creature; it does not really exist. Consider these two sentences:
%\begin{earg}
%\item[\ex{chimera1}] Chimera is angry.
%\item[\ex{chimera2}] Chimera is not angry.
%\end{earg}
%It is tempting just to define a constant to mean `chimera.' The symbolization key would look like this:
%\begin{ekey}
%\item[UD:] creatures on Earth
%\item[Ax:] $x$ is angry.
%\item[c:] chimera
%\end{ekey}
%We could then translate sentence \ref{chimera1} as $Ac$ and sentence \ref{chimera2} as $\enot Ac$.
%
%Problems will arise when we ask whether these sentences are true or false.
%
%One option is to say that sentence \ref{chimera1} is not true, because there is no chimera. If sentence \ref{chimera1} is false because it talks about a non-existent thing, then sentence \ref{chimera2} is false for the same reason. Yet this would mean that $Ac$ and $\enot Ac$ would both be false. Given the truth conditions for negation, this cannot be the case.
%
%Since we cannot say that they are both false, what should we do? Another option is to say that sentence \ref{chimera1} is \emph{meaningless} because it talks about a non-existent thing. So $Ac$ would be a meaningful expression in QL for some interpretations but not for others. Yet this would make our formal language hostage to particular interpretations. Since we are interested in logical form, we want to consider the logical force of a sentence like $Ac$ apart from any particular interpretation. If $Ac$ were sometimes meaningful and sometimes meaningless, we could not do that.
%
%This is the \emph{problem of non-referring terms}, and we will return to it later (see p.~\pageref{subsec.defdesc}.) The important point for now is that each constant of QL \emph{must} refer to something in the UD, although the UD can be any set of things that we like. If we want to symbolize arguments about mythological creatures, then we must define a UD that includes them. This option is important if we want to consider the logic of stories. We can translate a sentence like `Sherlock Holmes lived at 221B Baker Street' by including fictional characters like Sherlock Holmes in our UD.
%

%%%

What is an interpretation in QL? Like a symbolization key for QL, an interpretation requires a universe of discourse, a schematic meaning for each of the predicates, and an object that is picked out by each constant. For example:

\begin{ekey}
\item[UD:] Marvel characters
\item[Hx:] $x$ is a hero.
\item[Sx:] $x$ has spider powers.
\item[m:] Miles Morales
\item[p:] Peter Parker
\item[r:] The Red Skull
\item[s:] Susan Storm
\item[u:] Ultimate Spider-Man
\end{ekey}

This interpretation is given in terms of English descriptions. To apply it, you need to know some details about the characters in question. For example, $Sm$ is true on this interpretation, because Miles Morales does have spider powers. But the interpretation itself doesn't tell us that --- to get that information from this way of setting out the interpretation, you need to know some details about what happens in the story. You need to know, for example, that Miles Morales, like his more famous mentor Peter Parker, also has spider powers. If you do know a bit about Marvel comics, you may know that Miles Morales is actually the Ultimate Spider-Man. So $u$ and $m$ in this interpretation are two different names for the same member of the UD. There is no rule against having multiple names for the same member. (We'll discuss this issue in much more detail in Chapter \ref{ch.identity}.)

We want our QL models to encode this kind of information too. Like a good SL model, a QL model shouldn't require prior knowledge of comic books. One way we could try to do this would be to just give a truth value assignment, as we did for SL. The truth value assignment would assign 0 or 1 to each atomic wff: $Sm=1$, $Sp=1$, $Sr=0$, and so on. If we were to do that, however, we might just as well translate the sentences from QL to SL by replacing $Sp$ and $Sm$ with sentence letters. We could then rely on the definition of truth for SL, but at the cost of ignoring all the logical structure of predicates and terms. In writing a symbolization key for QL, we do not give separate definitions for $Sp$ and $Sm$. Instead, we give meanings to the components $S$, $p$, and $m$. This is essential because we want to be able to reflect the logical relationships between e.g.\ $Sp$ and $\qt{\exists}{x} Sx$.

Our interpretations should include descriptions for predicates and names, not just for sentences. We cannot use a truth value assignment for this, because a predicate by itself (except a 0-place predicate) is neither true nor false. In the interpretation given above, $H$ is true \emph{of} Peter Parker (i.e., $Hp$ is true), but it makes no sense to ask whether $H$ on its own is true. It would be like asking whether the English language fragment `$\ldots$is a hero' is true.

What does an interpretation do for a predicate, if it does not make it true or false? An interpretation helps to pick out the objects to which the predicate applies. Interpreting $Hx$ to mean `$x$ is a hero' picks out some characters as the things that are $H$s. Formally, this is a set of members of the UD to which the predicate applies; this set is called the \define{extension} of the predicate. 

%JH: I feel like this discussion is not getting to the point fast enough. It is getting caught up in some abstract issues. Not enough concrete illustration. Ideally would rewrite this in the future.

{\color{black} Basically, an interpretation specifies everything that falls within the extension of the predicate, i.e. everything that bears the property or relation described by that predicate. So if you have a predicate $R$ for the color red, your interpretation will specify all of the things in your domain of discourse that are red. Any object not assigned to the extension of `red' is by default not red.}

Some predicates have indefinitely large extensions. It would be impractical to try and write down all of the Marvel characters individually, so instead we use an English language expression to interpret the predicate. This is somewhat imprecise, because the interpretation alone does not tell you which members of the UD are in the extension of the predicate. In order to figure out whether a particular member of the UD is in the extension of the predicate (to figure out whether the Red Skull is a hero, for instance), you need to know about comic books. (As you might guess from his name, he's not.) In general, the extension of a predicate is the result of an interpretation \emph{along with} some facts.

Sometimes it is possible to list all of the things that are in the extension of a predicate. Instead of writing a schematic English sentence, we can write down the extension as a set of things. Suppose we wanted to add a one-place predicate $F$ to the key above, meaning `$x$ is a founding member of the Fantastic Four', so we write the extension as a set of characters:
\begin{partialmodel}
	\extension{F} & \{Reed Richards, Susan Storm, Johnny Storm, Ben Grimm\}
\end{partialmodel}

You do not need to know anything about comic books to be able to determine that, on this interpretation, $Fs$ is true: Susan Storm, whose name is given as `$s$', is just specified to be one of the things that is $F$. Similarly, $\qt{\exists}{x} Fx$ is obviously true on this interpretation: There is at least one member of the UD that is an $F$ --- in fact, there are four of them.

What about the sentence $\qt{\forall}{x} Fx$? That sentence is false, because it is not true that all members of the UD are $F$. It requires the barest minimum of knowledge about comic books to know that there are other characters besides just these four. Although we specified the extension of $F$ in a formally precise way, we still specified the UD with an English language description. Formally speaking, a UD is just a set of {\color{black}objects fall within the extension of various predicates.}
% members.

The formal significance of a predicate is determined by its extension, but what should we say about constants like $m$ and $s$? The meaning of a constant determines which member of the UD is picked out by the constant. The individual that the constant picks out is called the \define{referent} of the constant. Both $m$ and $u$ have the same referent, since they both refer to the same comic book character. You can think of a constant letter as a name and the referent as the thing named. In English, we can use the different names `Miles' and `Ultimate Spider-Man' to refer to the same comic book character. In this interpretation, we also use the different constants `$m$' and `$u$' to refer to the same member of the UD.

\section{Sets}

We use curly brackets `\{' and `\}' to denote sets. The members of the set can be listed in any order, separated by commas. This means that \{foo, bar\} and \{bar, foo\} are the same set.

It is possible to have a set with no members in it. This is called the \define{empty set}. The empty set is sometimes written as `\{\}', but usually it is written as the single symbol `$\emptyset$'.

\section{Extensions of predicates}
As we have seen, an interpretation in QL is only formally significant insofar as it determines a UD, an extension for each predicate, and a referent for each constant. We call this formal structure a \define{model} for QL.

To see how this works, consider this symbolization key:
\begin{ekey}
\item{UD:} The first ten natural numbers
\item{$Px$:} $x$ is prime.
\item{$n_{4}$}: 4
\end{ekey}

Given some basic mathematical knowledge, it is obvious that $Pn_{4}$ is false. Let's consider the model this key suggests, to show why it makes this wff false. Instead of just giving a description in the UD, we can list the members as a set. We also define the extension of the predicate $P$, and the referent of the constant $n_{4}$:

\begin{partialmodel}
	UD & $\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}$\\
	\extension{P} & \{2, 3, 5, 7\}\\
	\referent{n_{4}} & 4
\end{partialmodel}

This is not a full model for this interpretation, but it is a detailed enough partial model to show that $Pn_{4}$ is false. You do not need to know anything about mathematics to see that this sentence is false in this model. The UD member named by $n_{4}$ is not in the extension of $P$. In this way, the model captures all of the formal significance of the interpretation.

Suppose we enrich this symbolization key with more predicates:
\label{10UD}
\begin{ekey}
\item{UD:} The first ten natural numbers
\item{$Ex$:} $x$ is even.
\item{$Nx$:} $x$ is negative.
\item{$Lxy$:} $x$ is less than $y$.
\item{$Txyz$:} $x$ times $y$ equals $z$.
\end{ekey}
What do we need to add to the model for our new predicates?

The extension of $E$ in our model should be the subset $\{2, 4, 6, 8, 10\}$. There are no negative numbers in the UD, so $N$ has an empty extension; i.e. $\extension{N}=\emptyset$.

Sometimes it will be convenient to represent extensions graphically, similar to the way we did with truth tables. We can represent the extensions just described for $P$, $E$, and $N$ thus:

\begin{table}[h!]
\centering
\begin{tabular}{l|l|l|l}
            & $P$ & $E$ & $N$ \\ \hline
\textbf{1}  & 0  & 0          & 0          \\
\textbf{2}  & 1  & 1          & 0          \\
\textbf{3}  & 1  & 0          & 0          \\
\textbf{4}  & 0  & 1          & 0          \\
\textbf{5}  & 1  & 0          & 0          \\
\textbf{6}  & 0  & 1          & 0          \\
\textbf{7}  & 1  & 0          & 0          \\
\textbf{8}  & 0  & 1          & 0          \\
\textbf{9}  & 0  & 0          & 0          \\
\textbf{10} & 0 & 1          & 0         
\end{tabular}
\end{table}

The members of the UD are listed as rows; the one-place predicates are given as columns. The 0s and 1s indicate whether each member satisfies each predicate. Notice that the same information is conveyed in this chart as in the three sets of integers described above. Either is an acceptable way of indicating the extension of the predicates.

The extension of a two-place predicate like $L$ is more complicated. {\color{black}Many-place predicates are \textit{relations} between objects.} Hence, no individual number falls under the extension of this predicate; it is about a relation between members. Note also that sets of pairs of numbers aren't suitable for the extension of $L$ either, because 1 is less than 8, but 8 is not less than 1. (Remember, the set \{1,8\} is the very same set as the set \{8,1\}.) The solution is to have the extension of $L$ comprise a set of \define{ordered pairs} of numbers. An ordered pair is like a set with two members, except that the order \emph{does} matter. We write ordered pairs with angle brackets `$\openntuple$' and `$\closentuple$'. The ordered pair \mbox{\ntuple{foo, bar}} is different than the ordered pair \mbox{\ntuple{bar, foo}}. The extension of $L$ is a set of ordered pairs --- all of the pairs of numbers in the UD such that the first number is less than the second. Writing this out completely:


$\extension{L}=$ \{\ntuple{1, 2}, \ntuple{1, 3}, \ntuple{1, 4}, \ntuple{1, 5}, \ntuple{1, 6}, \ntuple{1, 7}, \ntuple{1, 8}, \ntuple{1, 9}, \ntuple{1, 10},
\ntuple{2, 3}, \ntuple{2, 4}, \ntuple{2, 5}, \ntuple{2, 6}, \ntuple{2, 7}, \ntuple{2, 8}, \ntuple{2, 9}, \ntuple{2, 10},
\ntuple{3, 4}, \ntuple{3, 5}, \ntuple{3, 6}, \ntuple{3, 7}, \ntuple{3, 8}, \ntuple{3, 9}, \ntuple{3, 10},
\ntuple{4, 5}, \ntuple{4, 6}, \ntuple{4, 7}, \ntuple{4, 8}, \ntuple{4, 9}, \ntuple{4, 10},
\ntuple{5, 6}, \ntuple{5, 7}, \ntuple{5, 8}, \ntuple{5, 9}, \ntuple{5, 10},
\ntuple{6, 7}, \ntuple{6, 8}, \ntuple{6, 9}, \ntuple{6, 10}, 
\ntuple{7, 8}, \ntuple{7, 9}, \ntuple{7, 10},
\ntuple{8, 9}, \ntuple{8, 10}
\ntuple{9, 10}%
\}

Formally, the extension of a two-place predicate is a set of ordered pairs. Sometimes we will find it easier to represent extensions in a chart, with the two variable positions represented on the two axes. For example, the extension above could be expressed via a table like the one below. The `0' in the first cell of the table says that \ntuple{1, 1} is not in the extension of $L$; the next cell in the first row says that \ntuple{1, 2} is. Etc. Sometimes drawing out a chart like this will be the easiest way to represent models for the extensions of two-place predicates.




\begin{table}[h!]
\centering
\begin{tabular}{l|llllllllll}
$Lxy$         & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{5} & \textbf{6} & \textbf{7} & \textbf{8} & \textbf{9} & \textbf{10} \\ \hline
\textbf{1}  & 0          & 1          & 1          & 1          & 1          & 1          & 1          & 1          & 1          & 1           \\
\textbf{2}  & 0          & 0          & 1          & 1          & 1          & 1          & 1          & 1          & 1          & 1           \\
\textbf{3}  & 0          & 0          & 0          & 1          & 1          & 1          & 1          & 1          & 1          & 1           \\
\textbf{4}  & 0          & 0          & 0          & 0          & 1          & 1          & 1          & 1          & 1          & 1           \\
\textbf{5}  & 0          & 0          & 0          & 0          & 0          & 1          & 1          & 1          & 1          & 1           \\
\textbf{6}  & 0          & 0          & 0          & 0          & 0          & 0          & 1          & 1          & 1          & 1           \\
\textbf{7}  & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 1          & 1          & 1           \\
\textbf{8}  & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 1          & 1           \\
\textbf{9}  & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 1           \\
\textbf{10} & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          
\end{tabular}
\end{table}

{\color{black} Often, an even easier method is to use `set-builder notation', which is very common in mathematics. We can represent the extension of the less than relation as the set of numbers in our UD such that the first is less than the second:} $$extension(L) = \{ \ntuple{x, y} : (x < y \textrm{ and } x, y \in UD)\}$$

{\color{black}The `$\in$' symbol indicates set-membership, so `$m \in UD$' means that $m$ is a member of the set UD. We read the colon `:' as `such that'. After the colon, we list any constraints that $x$ and $y$ must satisfy for the n-tuple $\ntuple{x, y}$ to be a member of the extension of the predicate $L$. Altogether, we read this as follows: the extension of $L$ is the set of n-tuples $\ntuple{x, y}$ where $x$ is less than $y$ and both $x$ and $y$ belong to the universe of discourse.}

The extension of a three-place predicate is a set of ordered triples where the predicate is true of those three things \emph{in that order}. So the extension of $T$ in this model will contain ordered triples like \ntuple{2, 4, 8}, because $2\times 4 = 8$. Because the surface of a sheet of paper is for all intents and purposes two-dimensional, it is usually not convenient to represent 3-or-more place predicates with tables. {\color{black} Using set-builder notation, we can represent the extension of $T$ as follows:} $$extension(T) = \{ \ntuple{x, y, z} : x \times y = z \textrm{ and } x, y, z \in UD \}$$

Generally, the extension of an $n$-place predicate is a set of ordered $n$-tuples ${\langle}a_1, a_2,\ldots, a_n{\rangle}$ such that $a_1$--$a_n$ are members of the UD and the predicate is true of $a_1$--$a_n$ in that order.


\section{Extensions of 0-place predicates}
\label{sec.0PlaceModels}

What of a 0-place predicate? Recall from Chapter \ref{ch.QL} that a 0-place predicate corresponds to an SL sentence letter --- it takes a truth value in an interpretation without reference to any particular objects. So a QL model provides truth values to 0-place predicates directly, just like an SL valuation function does.

This fact follows from the general description of $n$-place predicates given in the previous section: the extension of an $n$-place predicate is a set of ordered $n$-tuples. In the special case where $n=0$, the extension of the predicate will be a set of 0-tuples. But there is only one possible 0-tuple: the empty set, $\emptyset$. So there are only two possible extensions of a 0-place predicate, corresponding to the choice of whether $\emptyset$ is included in the extension or not. (Formally, the extension will either be the set containing the empty set --- \{$\emptyset$\} --- or it will be the empty set $\emptyset$ itself.)
%JH: would be fun to relate these points to Frege's use of the True and the False. 

For clarity and convenience, when indicating the extension of 0-place predicates in QL models, we'll simply indicate the truth values for the sentences themselves, like we did in SL. So we might indicate the extensions of 0-place predicates, for instance, by writing

\begin{ekey}
\item{$P$} = 1
\item{$Q$} = 0
\end{ekey}

instead of the more confusing

\begin{partialmodel}
	\extension{P} & \{$\emptyset$\}\\
	\extension{Q} & $\emptyset$. \\
\end{partialmodel}

So in the special case where we are \emph{only} working with 0-place predicates, QL models directly provide SL valuation functions. This is another respect in which QL is simply a generalization of SL. If you ignore the UD and the extensions of higher-place predicates, a QL model provides the same information we were using to discuss SL models in Chapter \ref{ch.SLmodels}.

\section{Working with models}
\label{sec.UsingModels}


We will use the double turnstile symbol for QL much as we did for SL. `$\metaA{}\models\metaB{}$' means that `\metaA{} entails \metaB{}': When \metaA{} and \metaB{} are two sentences of QL, $\metaA{}\models\metaB{}$ means that there is no model in which \metaA{} is true and \metaB{} is false. $\models\metaA{}$ is shorthand for $\emptyset\models\metaA{}$, which means that \metaA{} is true in every model. This allows us to give definitions for various concepts in QL. In fact, we can use the same definitions offered in Chapter \ref{ch.SLmodels}.

\begin{quote}
A \define{tautology in QL} is a sentence \metaA{} that is true in every model; i.e.,  $\models\metaA{}$.

A \define{contradiction in QL} is a sentence \metaA{} that is false in every model; i.e., $\models\enot\metaA{}$.

A sentence is \define{contingent in QL} if and only if it is neither a tautology nor a contradiction.

An argument `` $\script{P}_1, \script{P}_2, \cdots$, \therefore\ \metaC{} '' is \define{valid in QL} if and only if there is no model in which all of the premises are true and the conclusion is false; i.e., $\{\script{P}_1,\script{P}_2,\cdots\}\models\metaC{}$. Otherwise, an argument is \define{invalid in QL}.

Two sentences \metaA{} and \metaB{} are \define{logically equivalent in QL} if and only if both $\metaA{}\models\metaB{}$ and $\metaB{}\models\metaA{}$.

The set $\{\metaA{}_1,\metaA{}_2,\metaA{}_3,\cdots\}$ is \define{consistent in QL} if and only if there is at least one model in which all of the sentences are true (i.e. a model that satisfies all the sentences). A set is \define{inconsistent in QL} if and only if there is no such model.

\end{quote}


\section{Constructing models}

Suppose we want to show that $\qt{\forall}{x}Axx \eif Bd$ is \emph{not} a tautology. This requires showing that the sentence is not true in every model. If we can provide an example of a model in which the sentence is false, then we will have shown that the sentence is not a tautology.

What would such a model look like? In order for $(\qt{\forall}{x}Axx) \eif Bd$ to be false, the antecedent ($\qt{\forall}{x} Axx$) must be true, and the consequent ($Bd$) must be false.

To construct such a model, we start with a UD. It will be easier to specify extensions for predicates if we have a small UD, so start with a UD that has just one member. Formally, this single member might be anything. Let's say it is Miles Morales.

We want $\qt{\forall}{x} Axx$ to be true, so we want all members of the UD to be paired with themself in the extension of $A$; this means that the extension of $A$ must be \{\ntuple{Miles Morales, Miles Morales}\}.

We want $Bd$ to be false, so the referent of $d$ must not be in the extension of $B$. We give $B$ an empty extension.

Since Miles is the only member of the UD, it must be the referent of $d$. The model we have constructed looks like this:
\begin{partialmodel}
	UD			& \{Miles Morales\}\\
	\extension{A} 	& \{\ntuple{Miles Morales, Miles Morales}\}\\
	\extension{B}	& $\emptyset$\\
	\referent{d}	& Miles Morales
\end{partialmodel}

Strictly speaking, a model specifies an extension for \emph{every} predicate of QL and a referent for \emph{every} constant. As such, it is generally impossible to write down a full model. That would require writing down infinitely many extensions and infinitely many referents. However, we do not need to consider every predicate in order to show that there are models in which $\qt{\forall}{x}Axx \eif Bd$ is false. Predicates like $H$ and constants like $f_{13}$ make no difference to the truth or falsity of this sentence. It is enough to specify extensions for $A$ and $B$ and a referent for $d$, as we have done. This provides a \emph{partial model} in which the sentence is false.

Perhaps you are wondering: What might the predicate $A$ mean in English? It doesn't really matter. For formal purposes, the existence of models like the one described above is enough to show that $\qt{\forall}{x} Axx \eif Bd$ is not a tautology. But we can offer an interpretation in English if we like. How about this one?

\begin{ekey}
\item[UD:] Miles Morales
\item[$Axy$:] $x$ knows $y$'s biggest secret.
\item[$Bx$:] $x$'s powers derive from gamma radiation.
\item[$d$:] Miles Morales
\end{ekey}

This is one way we can interpret the model above. $Add$ is true, because Miles does know Miles's biggest secret. (It's that he's the Ultimate Spider-Man. Now you know it too!) $Bd$ is false: Miles's powers came from a genetically enhanced spider, not from gamma radiation. But the partial model constructed above includes none of these interpretative details. All it says is that $A$ is a predicate which is true of Miles and Miles, and that $B$ is a predicate which does not apply to Miles. There are indefinitely many predicates in English that have this extension. $Axy$ might instead mean `$x$ is the same size as $y$' or `$x$ and $y$ live in the same city'; $Bx$ might  translate as `$x$ is a billionaire' or `$x$'s uncle was killed by a robber' or `Ted Cruz has tweeted about $x$'. In constructing a model and giving extensions for $A$ and $B$, we do not need to specify what English predicates $A$ and $B$ should be used to translate. We are concerned with whether the sentence `$\qt{\forall}{x}Axx \eif Bd$' comes out true or false, and all that matters for truth and falsity in QL is the information in the model: the UD, the extensions of predicates, and the referents of constants.

We can just as easily show that $\qt{\forall}{x}Axx \eif Bd$ is not a contradiction. We need only specify a model in which $\qt{\forall}{x}Axx \eif Bd$ is true; i.e., a model in which either $\qt{\forall}{x} Axx$ is false or $Bd$ is true. Here is one such partial model:

\begin{partialmodel}
	UD			& \{The Red Skull\}\\
	\extension{A} 	& \{\ntuple{The Red Skull, The Red Skull}\}\\
	\extension{B}	& \{The Red Skull\}\\
	\referent{d}	& The Red Skull
\end{partialmodel}

I've switched our object from Miles Morales to The Red Skull to emphasize that it doesn't matter what object you pick. (Changing the examples all back to Miles would make no difference.) On this model, $\qt{\forall}{x}Axx \eif Bd$ is true, because it is a conditional with a true consequent (as well as a true antecedent). We have now shown that $\qt{\forall}{x}Axx \eif Bd$ is neither a tautology nor a contradiction. By the definition of `contingent in QL,' this means that 
$\qt{\forall}{x}Axx \eif Bd$ is contingent. In general, showing that a sentence is contingent will require two models: one in which the sentence is true and another in which the sentence is false.

Suppose we want to show that $\qt{\forall}{x} Sx$ and $\qt{\exists}{x} Sx$ are not logically equivalent. We need to construct a model in which the two sentences have different truth values, where one of them is true while the other is false. We start by specifying a UD. Again, we make the UD reasonably small so that we can specify extensions easily. But this time we will need at least two members. If we only had one member of the domain, we wouldn't be able to illustrate the difference between \emph{all} and \emph{some}. Let the UD be \{The Red Skull, Miles Morales\}.

We can make $\qt{\exists}{x} Sx$ true by including something in the extension of $S$, and we can make $\qt{\forall}{x} Sx$ false by leaving something out of the extension of $S$. It does not matter which one we include and which one we leave out. Making Miles the only $S$, we get a partial model that looks like this:
\begin{partialmodel}
	UD			& \{Miles, The Red Skull\}\\
	\extension{S}	& \{Miles\}
\end{partialmodel}
This partial model shows that the two sentences are \emph{not} logically equivalent. $\qt{\exists}{x} Sx$ is assigned 1 on this model, but $\qt{\forall}{x} Sx$ is assigned 0.

Back on p.~\pageref{surgeon3correct}, we said that this argument would be invalid in QL:
\begin{earg}
\item[] $(Rc \eand K_1c) \eand Tc$
\item[\therefore] $Tc \eand K_2c$
\end{earg}
Now we can prove that this is so. To show that this argument is invalid, we need to show that there is some model in which the premise is true and the conclusion is false. We can construct such a model deliberately. Here is one way to do it:
\begin{partialmodel}
	UD			& \{Reed Richards\}\\
	\extension{T}	& \{Reed Richards\}\\
	\extension{K_1}	& \{Reed Richards\}\\
	\extension{K_2}	& $\emptyset$\\
	\extension{R}	& \{Reed Richards\}\\
	\referent{c}	& Reed Richards
\end{partialmodel}

Similarly, we can show that a set of sentences is consistent by constructing a model in which all of the sentences are true.










\section{Reasoning about all models}
\label{sec.allmodelreasoning}
We can show that a sentence is \emph{not} a tautology just by providing one carefully specified model: a model in which the sentence is false. To show that something is a tautology, on the other hand, it would not be enough to construct ten, one hundred, or even a thousand models in which the sentence is true. It is only a tautology if it is true in \emph{every} model, and there are infinitely many models. This cannot be avoided just by constructing partial models, because there are infinitely many partial models.

Consider, for example, the sentence $Raa\eiff Raa$. There are two logically distinct partial models of this sentence that have a 1-member UD. There are 32 distinct partial models that have a 2-member UD. There are 1526 distinct partial models that have a 3-member UD. There are 262,144 distinct partial models that have a 4-member UD. And so on to infinity. In order to show that this sentence is a tautology, we need to show something about all of these models. There is no hope of doing so by dealing with them one at a time.
%JH: not clear to me where the `32' comes from: two objects a and b. Two choices for Raa (true or false), likewise for Rbb, and then likewise for Rab and Rba. Then a choice about whether a is same object as b, or are we stipulating that the two objects are distinct? 

Nevertheless, $Raa\eiff Raa$ is obviously a tautology. We can prove it with a simple argument:
\begin{quote}
\label{allmodels1}
There are two kinds of models: those in which $\langle$referent(a), referent(a)$\rangle$ is in the extension of $R$ and those in which it is not. In the first kind of model, $Raa$ is true. Hence, by the truth table for the biconditional, $Raa\eiff Raa$ is also true. In the second kind of model, $Raa$ is false, which also makes $Raa\eiff Raa$ true. Since the sentence is true in both kinds of model, and since every model is one of the two kinds, $Raa\eiff Raa$ is true in every model. Therefore, this sentence is a tautology.
\end{quote}
This is a sound argument; it should convince us of its conclusion. But note that it is not an argument in QL. Rather, it is an argument in English \emph{about} QL; it is an argument in the metalanguage. Furthermore, this style of argument won't always work, at least not without some generalization! 

%JH: not clear that the following claim is true, since we do have a formal procedure through our natural deduction proof system, or other Sound proof systems: There is no formal procedure for evaluating or constructing natural language arguments like this one. Even though the imprecision of natural language is a key reason we began thinking about formal languages, we can't escape our metalanguage! 

%Bad transition: There are further difficulties with this approach. 

Consider the sentence $\qt{\forall}{x}(Rxx\eif Rxx)$, another obvious tautology. It might be tempting to reason in this way: `$Rxx\eif Rxx$ is true in every model, so $\qt{\forall}{x}(Rxx\eif Rxx)$ must be true.' The problem is that $Rxx\eif Rxx$ is \emph{not} true in every model. Since $x$ is a variable rather than a constant, `$Rxx\eif Rxx$' is not a sentence, and so it is \emph{neither} true \emph{nor} false. We do not yet have the vocabulary to say what we want to say about $Rxx\eif Rxx$. In the next section, we generalize the concept of \emph{satisfaction} introduced in \S\ref{sec:entailmentSL}. After doing so, we can provide an argument that $\qt{\forall}{x}(Rxx\eif Rxx)$ is a tautology.

It is necessary to reason about an infinity of models to show that a sentence is a tautology. Similarly, it is necessary to reason about an infinity of models to show that a sentence is a contradiction, that two sentences are equivalent, that a set of sentences is inconsistent, or that an argument is valid. There are other things we can show by carefully constructing a model or two. Table \ref{table.ModelOrArgument} summarizes which things are which.

{\color{black}In Chapter~\ref{ch.QLND}, our natural deduction system will provide an alternative strategy for showing that a sentence in QL is a tautology. By deriving a sentence from no assumptions, and then appealing to the Soundness of our proof system QND, we can show that sentence is a tautology. Cool story bro!}

\begin{table}[t]
\caption{It is relatively easy to answer a question if you can do it by constructing a model or two. It is much harder if you need to reason about all possible models. This table shows when it suffices to construct a model(s).}
\label{table.ModelOrArgument}
\begin{center}
\begin{tabular*}{\textwidth}[t]{p{10em}p{10em}p{10em}}
& {\centerline{YES}} & {\centerline{NO}}\\
\cline{3-3}

Is \metaA{} a tautology? & {show that \metaA{} must be true in any model} & \tablefbox{\emph{construct a model} in which \metaA{} is false}\\
\cline{3-3}

Is \metaA{} a contradiction? &  {show that \metaA{} must be false in any model} & \tablefbox{\emph{construct a model} in which \metaA{} is true}\\
\cline{2-3}

Is \metaA{} contingent? & \tablefbox{\emph{construct two models}, one in which \metaA{} is true and another in which \metaA{} is false}\vline & {either show that \metaA{} is a tautology or show that \metaA{} is a contradiction}\\
\cline{2-3}

Are \metaA{} and \metaB{} equivalent? & {show that \metaA{} and \metaB{} must have the same truth value in any model} & \tablefbox{\emph{construct a model} in which \metaA{} and \metaB{} have different truth values}\\
\cline{2-3}

Is the set \model{A} consistent? & \tablefbox{\emph{construct a model} in which all the sentences in \model{A} are true} & {show that the sentences in \model{A} could not all be true in any model}\\
\cline{2-3}

Is the argument \mbox{`\script{P}, \therefore\ \metaC{}'} valid? & {show that any model in which \script{P} is true must be a model in which \metaC{} is true} & \tablefbox{\emph{construct a model} in which \script{P} is true and \metaC{} is false}\\
\cline{3-3}
\end{tabular*}
\end{center}
\end{table}



\section{Truth-conditions in QL}
\label{sec.TruthInQL}
%JH: really, this section is about truth CONDITIONS, not truth. 
%JH: replacing `definition of truth' with `definition of truth-conditions' or `determination of truth', since again, it's unclear that we are defining `truth.' We're simply providing a recursive account of truth conditions. 

In our discussion of SL, we split the definition of the truth-conditions of sentences into two parts: a truth value assignment ($a$) for atomic sentence letters and a truth function ($v$) for all sentences. The truth function covered the way that complex sentences are built from sentence letters and connectives. This revealed a recursive structure for the truth-conditions of any well-formed formula in SL. 

Just as for SL, the truth value of a sentence in QL is relative to an interpretation: a sentence is true \emph{in a model} or false \textit{in a model}. Tautologies are, of course, true \textit{in all models}; contradictions are false \textit{in all models}. Atomic sentences are $n$-place predicates followed by $n$ constants, like $Pj$ or $Qbcd$. A sentence $Pj$ is true in a model \model{M} if and only if the referent of $j$ is in the extension of $P$ in \model{M}.

We could go on in this way to define truth for all atomic sentences that contain only predicates and constants: Consider any sentence of the form $\script{R}\script{c}_1\ldots\script{c}_n$ where \script{R} is an n-place predicate and the \script{c}s are constants. It is true in \model{M} if and only if ${\langle}\referent{\script{c}_1},\ldots,\referent{\script{c}_n}{\rangle}$ is a member of the set \extension{\script{R}} in \model{M}.

We could then determine the truth of sentences built up with sentential connectives in the same way we did for SL. For example, the sentence $(Pj \eif Mda)$ is true in \model{M} if either $Pj$ is false in \model{M} or $Mda$ is true in \model{M}.

Unfortunately, this approach fails when we consider sentences containing quantifiers. Consider $\qt{\forall}{x} Px$. When is it true in a model \model{M}? The answer cannot depend on whether $Px$ is true or false in \model{M}, because the $x$ in `$Px$' is a free variable. $Px$ is not a sentence. It is neither true nor false.

We were able to give a recursive determination of truth in SL because every well-formed formula of SL has a truth value. Matters are more complex in QL, so we cannot determine truth values simply by starting with the truth of atomic sentences and building up. We also need to consider the atomic formulae which are not sentences (these contain unbound variables, and can be called `open formula'). In order to do this we will extend the notion of \emph{satisfaction}: in a model, every well-formed formula of QL will be satisfied or not satisfied, even if it does not have a truth value. We will then be able to determine the \emph{truth} of sentences of QL in terms of satisfaction. {\color{black} Fittingly, this approach to the semantics of quantifier logic is known as \textit{satisfaction semantics}, introduced by Tarski in the mid-1930s. We thank you, Tarski, for sponsoring the following section!}


\section{Satisfaction Semantics}
\label{sec:satisfactionQL}
% earlier, I should define `open sentence', but maybe `open formula' is better, since Ichikawa is saying that these things are not sentences. So calling them and open sentence would be confusing.

The open formula `$Px$' says, roughly, that `$x$ is one of the $P$s'. This cannot be quite right, however, because $x$ is a variable and not a constant. It does not name any particular member of the UD. Instead, its meaning in a sentence is determined by the quantifier that binds it. The variable $x$ must stand-in for any member of the UD in the sentence $\qt{\forall}{x}Px$, but it only needs to stand-in for one member in $\qt{\exists}{x}Px$. Since we want the definition of satisfaction to cover open formula like $Px$ without any quantifier whatsoever, we will start by saying how to interpret a free variable like the `$x$' in `$Px$'. 

{\color{black}\textit{Long story short}: we will devise a method for temporarily treating free variables as constants. When we interpret an existential like $\qt{\exists}{x} Px$, we effectively ask ``is there some member $c$ of the UD such that if we construed $x$ as denoting that member $c$, then there would be a P, i.e. $Pc$ is true?" Likewise, when we interpret a universal like $\qt{\forall}{x} Px$, we effectively ask ``are all of the members $c_1, c_2, \dots$ of the UD such that if we construe $x$ as denoting any one of them, then $Pc_i$ is true, where we replace $x$ with that member $c_i$, doing this for \textit{every} member $c_i$?'' Hopefully this idea is pretty intuitive! In the remainder of this section, try not to lose the forest for the trees. We are basically going to spell out a formal but somewhat tedious way of making precise this guiding intuition. Honestly, if you understand this basic intuition, that is probably enough. The rest of the section is mainly an exercise in formalization.} 
%Effectively, when we interpret 

%JH: would be better to use function notation, e.g. f(x), to emphasize that we are assignming constants to the variable x. `a' is a bad choice for a couple reasons (looks like a constant and looks like a common word)

{\color{black}Excepting tautologies and contradictions, the truth of a QL sentence is relative to an interpretation \textbf{I} (the \textbf{bold face font} denotes that this symbol is part of our metalanguage, not a QL sentence). Equivalently, it is relative to a model $\model{M}_{\mathbf{I}}$ induced by interpretation \textbf{I}. To temporarily replace variables with constants, we introduce a set of functions known as \textit{variable assignments}. Each variable assignment is relative to an interpretation (since different interpretations allow different variable assignments). We will denote a variable assignment as $\mathbf{d_I}$. The letter `d' should make you think of `denotations', since a variable assignment stipulates what a variable temporarily denotes, i.e. represents or stands for. Again, hold onto that forest!} 

{\color{black}As the name suggests, a variable assignment $\mathbf{d_I}$ takes in a variable (e.g. $x$) and outputs a constant, i.e. some member of the UD. If our UD consists of positive integers, then $\mathbf{d_I} (x)$ might equal $2$. Different variables can be assigned to the same constant, but every variable must be assigned a constant (otherwise $\mathbf{d_I}$ wouldn't be a function over the variables!). Different variable assignments differ in the constants they assign to variables.} 

%We do this by introducing a \emph{variable assignment}. Formally, this is a function that matches up each variable with a member of the UD. Call this function `$a$'. (The `$a$' is for `assignment', but this is not the same as the truth value assignment that we used in defining truth for SL.) 
%For every variable $x$ in our metalanguage, `$a(x)$' represents the object that the assignment $a$ assigns to $x$. 

{\color{black}Now we come to the whole point of this preamble: satisfaction. We'll say that a variable assignment $\mathbf{d_I} (x)$ \textit{satisfies} an open formula $Px$---on interpretation $\textbf{I}$---provided that $\mathbf{d_I}(x)$ lies in the extension of the predicate $P$. Again, `$\mathbf{d_I}(x)$' simply denotes the object that $\mathbf{d_I}$ assigns to the variable $x$. Equivalently, we could say that an open formula $Px$ is satisfied in a model $\model{M}_{\mathbf{I}}$ by a variable assignment $\mathbf{d_I}$ if and only if $\mathbf{d_I}(x)$ is in the  extension of P. Essentially, this notion of satisfaction lets us generalize the notion of truth to apply to open formulae. Cool beans.}  

{\color{black}We can generalize this notion of satisfaction to open formulae that comprise any n-place predicate $Q$. Consider an open formula of the form $Qx_1x_2\dots x_n$, for an n-place predicate $Q$. A variable assignment $\mathbf{d_I}$ will take in each of these variables $x_1 \dots x_n$ and assign each to some constant in the UD (not necessarily the same constant, of course!). We can then say that the variable assignment $\mathbf{d_I}$ \textit{satisfies} $Qx_1 x_2 \dots x_n$ provided that $<\mathbf{d_I}(x_1), \mathbf{d_I}(x_2),\dots, \mathbf{d_I}(x_n)>$ is in the extension of $Q$ on interpretation \textbf{I}. Whew! Let that sink in a little.}

%mathbf doesn't seem to work in ntuple command: $\ntuple{\mathbf{d_I}(x_1), \mathbf{d_I}(x_2),\dots, \mathbf{d_I}(x_n)}$
%<d_I(x_1), d_I(x_2),\dots, d_I(x_n)

{\color{black}Okay, so now we ascend from satisfaction for open formulae to the beast we're after: satisfaction for closed formulae, i.e. where variables are bound. So what does it take for an interpretation to satisfy a universal generalization like $\qt{\forall}{y} Py$? Recall our guiding intuition: we need it to be the case that the open formula $Py$ is satisfied no matter which member of the UD we assign to the variable $y$. To be satisfied, $\qt{\forall}{y} Py$ requires that every member of the UD lies in \extension{P}. So in particular,} it's not enough if $Py$ is satisfied in \model{M} by $\mathbf{d_I}(y)$. For that would just mean that the specific constant $\mathbf{d_I}(y)$ lies in the extension of $P$, without telling us anything about \textit{the other} constants in our UD. 

{\color{black}Here's where things get really fancy (buckle your brain belts!). We need some way of expressing the intuitive idea of assigning constants to variables such that $Py$ is satisfied no matter what constant we assign to the variable $y$. When in doubt, notation it out! So we introduce a new kind of function $\mathbf{d_I} [c / y]$, where the notation `$[c/y]$' is read `$c$ for $y$'. The function $\mathbf{d_I} [c / y]$ is just like the variable assignment $\mathbf{d_I}$, except for the following: $\mathbf{d_I} [c / y]$ necessarily assigns the constant $c$ to variable $y$. This means that $\mathbf{d_I} [c / y] (y) = c$. For any other variable $x$ distinct from $y$, $\mathbf{d_I} [c / y] (x) = \mathbf{d_I}(x)$. Since the variable assignment $\mathbf{d_I} [c / y]$ is so similar to the variable assignment $\mathbf{d_I}$, we call the former a \textit{variant} of the latter.} 

Defined piecewise, $\mathbf{d_I} [c / y]$ acts on variables as follows:\footnote{This piecewise function notation is very common in the mathlands. Take it or leave it!}

\begin{equation}
\mathbf{d_I} [c / y](x)=
    \begin{cases}
        \mathbf{d_I}(x) & \text{if } x \neq y \\
        c & \text{if } x =y 
    \end{cases}
\end{equation}

Here's a concrete illustration: Suppose that the UD is presidents of the United States. The function $\mathbf{d_I}[\mbox{Grover Cleveland}/y]$ assigns Grover Cleveland to the variable $y$, regardless of what $\mathbf{d_I}$ assigns to $y$. For any other variable $z$, $\mathbf{d_I}[\mbox{Grover Cleveland}/y](z)$ equals $\mathbf{d_I}(z)$.


%So we need another bit of technical notation: For any member $\pi$ of the UD and any variable \script{x}, let $a[\pi|\script{x}]$ be the variable assignment that assigns $\pi$ to \script{x} but agrees with $\mathbf{d_I}(x)$ in all other respects. We have used $\pi$, the Greek letter \emph{pi}, to underscore the fact that it is some member of the UD and not some symbol of QL. 

{\color{black}We can now say that $\qt{\forall}{y} Py$ is satisfied in a model $\model{M}_I$ by a variable assignment $\mathbf{d_I}$ if and only if, for every object $c$ in the UD of $\model{M}_I$, $Py$ is satisfied in \model{M} by $\mathbf{d_I}[c/y]$. Let's put that another way, in case you find it easier to understand: a formula of the form $\qt{\forall}{y} Py$ is satisfied by $\mathbf{d_I}$ on interpretation $\textbf{I}$ provided that each member $c$ of the UD is such that the variant $\mathbf{d_I}[c/y]$ satisfies $Py$ on interpretation $\textbf{I}$. In other words, the output of the variant $\mathbf{d_I}[c/y](c)$ lies in the extension of $P$ for every constant $c$ in our UD. Again, this is just a convoluted (but precise) way of saying the intuitive idea we began with! Forest, meet trees!} 

{\color{black}It may help to see how satisfaction works out for existentials such as $\qt{\exists}{y} Py$, since this case is somewhat simpler. A variable assignment $\mathbf{d_I}$ satisfies a sentence of the form $\qt{\exists}{y} Py$ provided that there is at least one member $c$ of the UD such that the variant $\mathbf{d_I}[c/y]$ satisfies the open formula $Py$ on interpretation $\textbf{I}$. Basically, we just need there to be at least one constant $c$ that lies in the extension of $P$ (so that $\mathbf{d_I}[c/y](y) \in \text{extension}(P)$. We've just come up with a fancy way of formalizing this idea (a way that generalizes to QL sentences of arbitrary complexity).} 

%The intuitive thought here is that wff satisfaction is relative to a variable assignment. A variable assignment is a way of treating each variable as if it were a name for some object or other; a wff is satisfied by $\mathbf{d_I}(x)$ in a given model iff, in that model, treating the variables the way $\mathbf{d_I}(x)$ suggests would yield a true wff.

You may worry that our statement of satisfaction by a variable assignment in a model is circular, because it gives the satisfaction conditions for the sentence $\qt{\forall}{x} Px$ using the phrase `for every object'. Similarly, we give the satisfaction conditions for the sentence $\qt{\exists}{x} Px$ using the phrase `at least one object'. However, we must remember the difference between a logical symbol like `$\forall$' and an English language word like `every.' The word is part of the metalanguage that we use in defining satisfaction conditions for object language sentences that contain the symbol. (Recall the parallel discussion of sentential connectives on p.\ \pageref{truthdefinition}.)

We can now give a general definition of satisfaction, generalizing from the cases we have already discussed. We define a function $\mathbf{s}$ (for `satisfaction') in a model $\model{M}_I$ such that for any wff \metaA{} and variable assignment $\mathbf{d_I}$, $\mathbf{s}(\metaA{}, \mathbf{d_I})=1$ if \metaA{} is satisfied in $\model{M}_I$ by $\mathbf{d_I}$; otherwise $\mathbf{s}(\metaA{}, \mathbf{d_I})=0$. Remember: `1' stands for `true' and `0' stands for `false.' 

% %JH: Note that in the first \item, we are implicitly defining the denotation function that the Logic Book defines on p. 340, end of Section 8.1. It seems overkill to have to define yet another function, so this implicit approach seems fine (although it notationally not great to have these $t_i$ running around, since probably they should be in bold or script as metavariables. But then it would seem strange to write c_i = t_i. Logic Book gets around this by having that function, and also having an interpretation function I that can act on constants to say what they are interpreted as. 
%\script{t}_1\ldots\script{t}_n

\begin{enumerate}
\item Let \metaA{} be an atomic wff of the form $\script{P}t_1\ldots t_n$, where each $t_i$ is either a constant or a variable. Introduce objects $c_i$ which represent the denotation of $t_i$, either because $t_i$ is already a constant or because we assign $t_i$ to a constant using a variable assignment. For each $t_i$, if $t_i$ is a constant then $c_i = t_i$. If $t_i$ is instead a variable, then $c_i = \mathbf{d_I}(t_i)$. We'll say that $\mathbf{d_I}$ satisfies $\script{P}t_1\ldots t_n$ provided that $< c_1, \ldots, c_n>$ is in \extension{\script{P}}. In other words, we have the following two cases:
\begin{displaymath}\mathbf{s}(\metaA{}, \mathbf{d_I}) =
	\left\{\begin{array}{ll}
	1 & \mbox{if $< c_1, \ldots, c_n>$ is in \extension{\script{P}} in $\model{M}_I$},\\
	0 & \mbox{otherwise.}
	\end{array}\right.
\end{displaymath}

%For each term $t_i$: If $t_i$ is a constant, then $\pi_i = \referent{t_i}$. If $t_i$ is a variable, then $\pi_i = a(t_i)$.

\item If \metaA{} is ${\enot}\metaB{}$ for some wff \metaB{}, then
\begin{displaymath}\mathbf{s}(\metaA{}, \mathbf{d_I}) =
	\left\{\begin{array}{ll}
	1 & \mbox{if $\mathbf{s}(\metaB{}, \mathbf{d_I}) = 0$},\\
	0 & \mbox{otherwise.}
	\end{array}\right.
\end{displaymath}

\item If \metaA{} is $(\metaB{}\eand\metaC{})$ for some wffs \metaA{}, \metaB{}, then
\begin{displaymath}\mathbf{s}(\metaA{}, \mathbf{d_I}) =
	\left\{\begin{array}{ll}
	1 & \mbox{if $\mathbf{s}(\metaB{}, \mathbf{d_I}) = 1$ and $\mathbf{s}(\metaC{}, \mathbf{d_I}) = 1$,}\\
	0 & \mbox{otherwise.}
	\end{array}\right.
\end{displaymath}

\item If \metaA{} is $(\metaB{}\eor\metaC{})$ for some wffs \metaA{}, \metaB{}, then
\begin{displaymath}\mathbf{s}(\metaA{}, \mathbf{d_I}) =
	\left\{\begin{array}{ll}
	0 & \mbox{if $\mathbf{s}(\metaB{}, \mathbf{d_I}) = 0$  and $\mathbf{s}(\metaC{}, \mathbf{d_I}) = 0$,}\\
	1 & \mbox{otherwise.}
	\end{array}\right.
\end{displaymath}

\item If \metaA{} is $(\metaB{}\eif\metaC{})$ for some wffs \metaA{}, \metaB{}, then
\begin{displaymath}\mathbf{s}(\metaA{}, \mathbf{d_I}) =
	\left\{\begin{array}{ll}
	0 & \mbox{if $\mathbf{s}(\metaB{}, \mathbf{d_I}) = 1$ and $\mathbf{s}(\metaC{}, \mathbf{d_I}) = 0$,}\\
	1 & \mbox{otherwise.}
	\end{array}\right.
\end{displaymath}

\item If \metaA{} is $(\metaB{}\eiff\metaC{})$ for some wffs \metaA{}, \metaB{}, then
\begin{displaymath}\mathbf{s}(\metaA{}, \mathbf{d_I}) =
	\left\{\begin{array}{ll}
	1 & \mbox{if $\mathbf{s}(\metaB{}, \mathbf{d_I}) = \mathbf{s}(\metaC{}, \mathbf{d_I})$},\\
	0 & \mbox{otherwise.}
	\end{array}\right.
\end{displaymath}

\item If \metaA{} is $\qt{\forall}{\script{x}} \metaB{}$ for some wff \metaB{} and some variable \script{x}, then
\begin{displaymath}\mathbf{s}(\metaA{}, \mathbf{d_I}) =
	\left\{\begin{array}{ll}
	1 & \mbox{if $\mathbf{s}(\metaB{}, \mathbf{d_I}[c/\script{x}])=1$ for every member $c$ of the UD},\\
	0 & \mbox{otherwise.}
	\end{array}\right.
\end{displaymath}

\item If \metaA{} is $\qt{\exists}{\script{x}} \metaB{}$ for some wff \metaB{} and some variable \script{x}, then
\begin{displaymath}\mathbf{s}(\metaA{}, \mathbf{d_I}) =
	\left\{\begin{array}{ll}
	1 & \mbox{if $\mathbf{s}(\metaB{}, \mathbf{d_I}[c/\script{x}])=1$ for at least one member $c$ of the UD},\\
	0 & \mbox{otherwise.}
	\end{array}\right.
\end{displaymath}
\end{enumerate}
 
This definition follows the same structure as the definition of a wff for QL, so we know that every wff of QL will be covered by this definition. For a model \model{M} and a variable assignment $\mathbf{d_I}$, any wff will either be satisfied or not. No wffs are left out or assigned conflicting values. {\color{black}Man, what a wild ride that was!} 




\section{Truth in QL}

Consider a simple quantified sentence like $\qt{\forall}{x}Px$. By part 7 in the definition of satisfaction, this sentence is satisfied if $a[\pi|x]$ satisfies $Px$ in \model{M} for every $\pi$ in the UD. In other words, assign that $x$ to any object in the UD you like, and the resultant wff will come out true. By part 1 of the definition, this will be the case if every $\pi$ is in the extension of $P$. Whether $\qt{\forall}{x}Px$ is satisfied does not depend on the particular variable assignment $\mathbf{d_I}(x)$. If this sentence is satisfied, then it is true. This is a formalization of what we have said all along: $\qt{\forall}{x}Px$ is true if everything in the UD is in the extension of $P$.

The same thing holds for any sentence of QL. Because all of the variables are bound, a sentence is satisfied or not regardless of the details of the variable assignment. So we can define truth in this way: A sentence \metaA{} is \define{true in} \model{M} if and only if some variable assignment satisfies \metaA{} in $M$; \metaA{} is \define{false in} \model{M} otherwise.

Truth in QL is \emph{truth in a model}. {\color{black}Unless they are a tautology or a contradiction,} sentences of QL are not flat-footedly true or false as mere symbols, but only relative to a model. A model provides the meaning of the symbols, insofar as it makes any difference to truth and falsity.


\section{Reasoning about all models (reprise)}
At the end of section \ref{sec.allmodelreasoning}, we were stymied when we tried to show that $\qt{\forall}{x}(Rxx\eif Rxx)$ is a tautology. Having defined satisfaction, we can now reason in this way:
\begin{quote}
Consider some arbitrary model \model{M}. Now consider an arbitrary member of the UD; for the sake of convenience, call it $\pi$. It must be the case either that $\langle\pi,\pi\rangle$ is in the extension of $R$ or that it is not. If $\langle\pi,\pi\rangle$ is in the extension of $R$, then $Rxx$ is satisfied by a variable assignment that assigns $\pi$ to $x$ (by part 1 of the definition of  {satisfaction}); since the consequent of $Rxx\eif Rxx$ is satisfied, the conditional is satisfied (by part 5). If $\langle\pi,\pi\rangle$ is not in the extension of $R$, then $Rxx$ is not satisfied by a variable assignment that assigns $\pi$ to $x$ (by part 1); since the antecedent of $Rxx\eif Rxx$ is not satisfied, the conditional is satisfied (by part 5). In either case, $Rxx\eif Rxx$ is satisfied. This is true for any member of the UD, so $\qt{\forall}{x}(Rxx \eif Rxx)$ is satisfied by any truth value assignment (by part 7). So $\qt{\forall}{x}(Rxx \eif Rxx)$ is true in \model{M} (by the recursive structure of truth in QL). This argument holds regardless of the exact UD and regardless of the exact extension of $R$, so $\qt{\forall}{x}(Rxx \eif Rxx)$ is true in any model. Therefore, it is a tautology.
\end{quote}

Giving arguments about all possible models typically requires a clever combination of two strategies:

1. {\color{black}\textit{Proof by cases}}: Divide cases between possible kinds, such that every case must be one kind or the other.  In the argument on p.~\pageref{allmodels1}, for example, we distinguished two kinds of models based on whether or not a specific ordered pair was in \extension{R}. In the argument above, we distinguished cases in which an ordered pair was in \extension{R} and cases in which it was not. {\color{black}Note that this proof strategy is just like the one we use for the rule of Disjunction Elimination (\eor E) in our natural deduction systems!}

2. {\color{black}\textit{Universal Generalization}}: Consider an arbitrary object as a way of showing something more general. In the argument above, it was crucial that $\pi$ was just some arbitrary member of the UD. We did not assume anything special about it. As such, whatever we could show to hold of $\pi$ must hold of every member of the UD --- if we could show it for $\pi$, we could show it for anything. In the same way, we did not assume anything special about \model{M}, and so whatever we could show about \model{M} must hold for all models. {\color{black}Note that this proof strategy parallels a new rule we will describe in Chapter~\ref{ch.QLND} for introducing a universal quantifier ($\forall$I). It is also a foundational reasoning strategy in mathematics.}

Consider one more example. The argument $\qt{\forall}{x}(Hx \eand Jx)$ \therefore   $\qt{\forall}{x} Hx$ is obviously valid. We can show that the argument is valid by considering what must be true in every model in which the premise is true.
\begin{quote}
Consider an arbitrary model \model{M} in which the premise $\qt{\forall}{x}(Hx \eand Jx)$ is true. The conjunction $Hx \eand Jx$ is satisfied regardless of what is assigned to $x$, so $Hx$ must be also (by part 3 of the definition of {satisfaction}). As such, $\qt{\forall}{x} Hx$ is satisfied by any variable assignment (by part 7 of the definition of {satisfaction}) and true in \model{M} (by the definition of {truth}).
Since we did not assume anything about \model{M} besides $\qt{\forall}{x}(Hx \eand Jx)$ being true, $\qt{\forall}{x} Hx$ must be true in any model in which $\qt{\forall}{x}(Hx \eand Jx)$ is true. So $\qt{\forall}{x}(Hx \eand Jx) \models \qt{\forall}{x} Hx$.
\end{quote}
Even for a simple argument like this one, the reasoning is somewhat complicated. For longer arguments, the reasoning can be insufferable. Difficulties arise because talking about an infinity of models requires reasoning things out in English. What are we to do? The answer won't surprise readers of the first half of the book: we'll make use of some formal proof systems! We have seen two kinds of proof systems for SL: the tree method, and natural deduction proofs. In the coming chapters, we'll extend both kinds of systems to QL as well. 

{\color{black}We hasten to note that---until we show these proof systems are Sound---the most they show is the syntactic property of derivability. They let us establish a single turnstile, e.g. that $\qt{\forall}{x}(Hx \eand Jx) \vdash{} \qt{\forall}{x} Hx$, but we'll need a Soundness result to convert this to a double turnstile $\models$, i.e. to a semantic notion of entailment.} 


\iffalse

\practiceproblems

\solutions
\problempart
\label{pr.TorF1}
Determine whether each sentence is true or false in the model given.
\begin{partialmodel}
UD & \{Corwin, Benedict\}\\
\extension{A} & \{Corwin, Benedict\}\\
\extension{B} & \{Benedict\}\\
\extension{N} & $\emptyset$\\
\referent{c} & Corwin
\end{partialmodel}
\begin{earg}
\item $Bc$
\item $Ac \eiff \enot Nc$
\item $Nc \eif (Ac \eor Bc)$
\item $\qt{\forall}{x} Ax$
\item $\qt{\forall}{x} \enot Bx$
\item $\qt{\exists}{x}(Ax \eand Bx)$
\item $\qt{\exists}{x}(Ax \eif Nx)$
\item $\qt{\forall}{x}(Nx \eor \enot Nx)$
\item $\qt{\exists}{x} Bx \eif \qt{\forall}{x} Ax$
\end{earg}




\solutions
\problempart
\label{pr.TorF2}
Determine whether each sentence is true or false in the model given.
\begin{partialmodel}
UD & \{Waylan, Willy, Johnny\}\\
\extension{H} & \{Waylan, Willy, Johnny\}\\
\extension{W} & \{Waylan, Willy\}\\
\extension{R} & \{\ntuple{Waylan, Willy},\ntuple{Willy, Johnny},\ntuple{Johnny, Waylan}\}\\
\referent{m} & Johnny
\end{partialmodel}
\begin{earg}
\item $\qt{\exists}{x}(Rxm \eand Rmx)$
\item $\qt{\forall}{x}(Rxm \eor Rmx)$
\item $\qt{\forall}{x}(Hx \eiff Wx)$
\item $\qt{\forall}{x}(Rxm \eif Wx)$
\item $\qt{\forall}{x}\bigl[Wx \eif(Hx \eand Wx)\bigr]$
\item $\qt{\exists}{x} Rxx$
\item $\qt{\exists}{x}\qt{\exists}{y} Rxy$
\item $\qt{\forall}{x} \qt{\forall}{y} Rxy$
\item $\qt{\forall}{x} \qt{\forall}{y} (Rxy \eor Ryx)$
\item $\qt{\forall}{x} \qt{\forall}{y} \qt{\forall}{z}\bigl[(Rxy \eand Ryz) \eif Rxz\bigr]$
\end{earg}

\solutions
\problempart
\label{pr.TorF3}
Determine whether each sentence is true or false in the model given.
\begin{partialmodel}
	UD			& \{Lemmy, Courtney, Eddy\}\\
	\extension{G}	& \{Lemmy, Courtney, Eddy\}\\
	\extension{H}	& \{Courtney\}\\
	\extension{M}	& \{Lemmy, Eddy\}\\
	\referent{c}	& Courtney\\
	\referent{e}	& Eddy
\end{partialmodel}
\begin{earg}
\item $Hc$
\item $He$
\item $Mc \eor Me$
\item $Gc \eor \enot Gc$
\item $Mc \eif Gc$
\item $\qt{\exists}{x} Hx$
\item $\qt{\forall}{x} Hx$
\item $\qt{\exists}{x} \enot Mx$
\item $\qt{\exists}{x}(Hx \eand Gx)$
\item $\qt{\exists}{x}(Mx \eand Gx)$
\item $\qt{\forall}{x}(Hx \eor Mx)$
\item $\qt{\exists}{x} Hx \eand \qt{\exists}{x} Mx$
\item $\qt{\forall}{x}(Hx \eiff \enot Mx)$
\item $\qt{\exists}{x} Gx \eand \qt{\exists}{x} \enot Gx$
\item $\qt{\forall}{x}\qt{\exists}{y}(Gx \eand Hy)$
\end{earg}

\solutions
\problempart
\label{pr.InterpretationToModel}
Write out the model that corresponds to the interpretation given.
\begin{ekey}
\item{UD:} natural numbers from 10 to 13
\item{Ox:} $x$ is odd. 
\item{Sx:} $x$ is less than 7.
\item{Tx:} $x$ is a two-digit number.
\item{Ux:} $x$ is thought to be unlucky.
\item{Nxy:} $x$ is the next number after $y$.
\end{ekey}


\problempart
\label{pr.Contingent}
Show that each of the following is contingent.
\begin{earg}
\item \leftsolutions\ $Da \eand Db$
\item \leftsolutions\ $\qt{\exists}{x} Txh$
\item \leftsolutions\ $Pm \eand \enot\qt{\forall}{x} Px$
\item $\qt{\forall}{z} Jz \eiff \qt{\exists}{y} Jy$
\item $\qt{\forall}{x} (Wxmn \eor \qt{\exists}{y}Lxy)$
\item $\qt{\exists}{x} (Gx \eif \qt{\forall}{y} My)$
\end{earg}

\solutions
\problempart
\label{pr.NotEquiv}
Show that the following pairs of sentences are not logically equivalent.
\begin{earg}
\item $Ja$, $Ka$
\item $\qt{\exists}{x} Jx$, $Jm$
\item $\qt{\forall}{x} Rxx$, $\qt{\exists}{x} Rxx$
\item $\qt{\exists}{x} Px \eif Qc$, $\qt{\exists}{x} (Px \eif Qc)$
\item $\qt{\forall}{x}(Px \eif \enot Qx)$, $\qt{\exists}{x}(Px \eand \enot Qx)$
\item $\qt{\exists}{x}(Px \eand Qx)$, $\qt{\exists}{x}(Px \eif Qx)$
\item $\qt{\forall}{x}(Px\eif Qx)$, $\qt{\forall}{x}(Px \eand Qx)$
\item $\qt{\forall}{x}\qt{\exists}{y} Rxy$, $\qt{\exists}{x}\qt{\forall}{y} Rxy$
\item $\qt{\forall}{x}\qt{\exists}{y} Rxy$, $\qt{\forall}{x}\qt{\exists}{y} Ryx$
\end{earg}



\problempart
Show that the following sets of sentences are consistent.
\begin{earg}
\item \{Ma, \enot Na, Pa, \enot Qa\}
\item \{$Lee$, $Lef$, $\enot Lfe$, $\enot Lff$\}
\item \{$\enot (Ma \eand \qt{\exists}{x} Ax)$, $Ma \eor Fa$, $\qt{\forall}{x}(Fx \eif Ax)$\}
\item \{$Ma \eor Mb$, $Ma \eif \qt{\forall}{x} \enot Mx$\}
\item \{$\qt{\forall}{y} Gy$, $\qt{\forall}{x} (Gx \eif Hx)$, $\qt{\exists}{y} \enot Iy$\}
\item \{$\qt{\exists}{x}(Bx \eor Ax)$, $\qt{\forall}{x} \enot Cx$, $\qt{\forall}{x}\bigl[(Ax \eand Bx) \eif Cx\bigr]$\}
\item \{$\qt{\exists}{x} Xx$, $\qt{\exists}{x} Yx$, $\qt{\forall}{x}(Xx \eiff \enot Yx)$\}
\item \{$\qt{\forall}{x}(Px \eor Qx)$, $\qt{\exists}{x}\enot(Qx \eand Px)$\}
\item \{$\qt{\exists}{z}(Nz \eand Ozz)$, $\qt{\forall}{x}\qt{\forall}{y}(Oxy \eif Oyx)$\}
\item \{$\enot \qt{\exists}{x} \qt{\forall}{y} Rxy$, $\qt{\forall}{x} \qt{\exists}{y} Rxy$\}
\end{earg}


\problempart
Construct models to show that the following arguments are invalid.
\begin{earg}
\item $\qt{\forall}{x}(Ax \eif Bx)$, \therefore\ $\qt{\exists}{x} Bx$
\item $\qt{\forall}{x}(Rx \eif Dx)$, $\qt{\forall}{x}(Rx \eif Fx)$, \therefore\ $\qt{\exists}{x}(Dx \eand Fx)$
\item $\qt{\exists}{x}(Px\eif Qx)$, \therefore $\qt{\exists}{x} Px$
\item $Na \eand Nb \eand Nc$, \therefore\ $\qt{\forall}{x} Nx$
\item $Rde$, $\qt{\exists}{x} Rxd$, \therefore\ $Red$
\item $\qt{\exists}{x}(Ex \eand Fx)$, $\qt{\exists}{x} Fx \eif \qt{\exists}{x} Gx$, \therefore\ $\qt{\exists}{x}(Ex \eand Gx)$
\item $\qt{\forall}{x} Oxc$, $\qt{\forall}{x} Ocx$, \therefore\ $\qt{\forall}{x} Oxx$
\item $\qt{\exists}{x}(Jx \eand Kx)$, $\qt{\exists}{x} \enot Kx$, $\qt{\exists}{x} \enot Jx$, \therefore\ $\qt{\exists}{x}(\enot Jx \eand \enot Kx)$
\item $Lab \eif \qt{\forall}{x} Lxb$, $\qt{\exists}{x} Lxb$, \therefore\ $Lbb$
\end{earg}





\problempart
\label{pr.SemanticsEssay}
\begin{earg}
\item Many logic books define consistency and inconsistency in this way:
`` A set $\{\metaA{}_1,\metaA{}_2,\metaA{}_3,\cdots\}$ is inconsistent if and only if $\{\metaA{}_1,\metaA{}_2,\metaA{}_3,\cdots\}\models(\metaB{}\eand\enot\metaB{})$ for some sentence \metaB{}. A set is consistent if it is not inconsistent.''

Does this definition lead to any different sets being consistent than the definition on  p.~\pageref{def.consistencySL}? Explain your answer.

\item\leftsolutions\ Our definition of truth says that a sentence \metaA{} is \define{true in} \model{M} if and only if some variable assignment satisfies \metaA{} in $M$. Would it make any difference if we said instead that \metaA{} is \define{true in} \model{M} if and only if \emph{every} variable assignment satisfies \metaA{} in $M$? Explain your answer.
\end{earg}

\fi
