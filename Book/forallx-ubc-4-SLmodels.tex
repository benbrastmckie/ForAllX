%!TEX root = forallx-ubc.tex
\chapter{Logical Entailment in SL}
\label{ch.SLmodels}

In Ch.~\ref{ch.SL} we defined the sentences of SL, and in Ch.~\ref{ch.TruthTables} we defined the interpretations of SL and provided semantic clauses for the logical connectives.
Given these definitions, we are now in a position to introduce the notion of \textit{logical entailment}, relating this notion to the semantic concepts of validity, tautology, contradiction, consistency, and logical equivalence.






\section{Satisfaction}
\label{sec:satisfaction}

Recall that an \define{interpretation} is any function which assigns a truth-value to every sentence letter of SL.
We will also refer to interpretations of SL as \define{models} of SL since interpretations provide an extensional way to represent the meanings of the sentence letters in SL.\footnote{Intensional and hyperintensional semantic frameworks provide much more fine-grained representations of meanings, but this doesn't make extensional frameworks irrelevant. After all, first-order set theory is an extensional theory which many take to provide a foundation for mathematics.}

Whereas a sentence $\metaA{}$ may be either true of false on a given interpretation $\I$ (i.e., the valuation function $\V{\I}$ induced by $\I$ assigns that sentence to $1$), sets of sentences do not have truth-values.
Accordingly, we may say that an SL interpretation $\I$ \define{satisfies} a set of SL sentences $\Gamma=\set{\metaA_{1},\metaA_{2},\ldots}$ just in case $\V{\I}(\metaA)=1$ for all $\metaA \in \Gamma$.
Derivatively, it is convenient to say that an interpretation $\I$ of SL \define{satisfies} a single sentence $\metaA$ just in case it satisfies the singleton set $\set{\metaA}$, i.e., the set which includes $\metaA$ as its only member. 





\section{Entailment}
  \label{sec:entailment}

A set of SL sentences $\Gamma$ \define{logically entails} $\metaA$ just in case every interpretation that satisfies $\Gamma$ also satisfies $\metaA$.
Logical entailment is also called the \define{logical consequence} relation, or \define{semantic consequence}, and is written: $\Gamma \models \metaA$. 
An entire chapter is named after this relation for good reason: it is the most important semantic concept that we will introduce and will later be shown to have the same extension as a corresponding syntactic notion.

Note that the double turnstile `$\models$' is--- like the metavariable `\metaA{}'--- part of the \emph{metalanguage} we use to discuss SL, and not a part of SL.
For ease of exposition, we will often drop `logically', speaking simply of entailment.
Although officially $\models$ takes a set of SL sentences on the left together with a single SL sentence on the right, it is both common and convenient to drop the set notation, writing `$\metaA_1,\ldots,\metaA_n \models \metaB$' instead of `$\set{\metaA_1,\ldots,\metaA_n} \models \metaB$'.
% Even though entailment is connected in important ways to the validity of arguments, it is important to remember to apply the definitions rigorously and precisely.

Recall that an argument in SL is a sequence of SL sentences, and so a completely different type of thing than a set of sentences of SL.
After all, sets do not specify the order of their members.
Nevertheless, we may say that for any SL argument, that argument is valid if and only if it's premises entail it's conclusion.
What we cannot say is that for any set of SL sentences $\Gamma$ and further sentence $\metaA$, if $\Gamma \models \metaA$, then \textit{the} argument whose premises are the sentences in $\Gamma$ and whose conclusion is $\metaA$ is valid.
This is because there may fail to be a unique argument that we can construct from a set of SL sentences $\Gamma$ and a further SL sentence $\metaA$.
For instance, assuming $\Gamma$ includes at least two sentences, we can construct different arguments by ordering the premises in different ways.
Instead, we may claim something general: if $\Gamma \models \metaA$, then \textit{every} argument where the sentence in $\Gamma$ are the premises (in some order or other) and $\metaA$ is the conclusion is valid.

It will help to consider a simple example.
For instance, take the following entailment claim: 
  $$P, Q \models P\eor Q.$$ 
The entailment above is true since every interpretation that satisfies the set $\set{P, Q}$ also satisfies $P\eor Q$.
Accordingly, we may say that the argument with $P$ as its first premise, $Q$ as its second premise, and $P\eand Q$ as its conclusion is logically valid. 
Although closely related, this is a different claim than our original entailment, one to do with arguments.
For instance, there is a distinct argument which takes $Q$ to be its first premise, $P$ as its second premise, and $P\eand Q$ as its conclusion, though this second argument is just as valid as the first.
By contrast, permuting $P$ and $Q$ in the entailment claim above does not amount to a distinct entailment claim, but rather a distinct means of expressing the very same entailment claim. 
This is because sets do not preserve order: $\set{P,Q}=\set{Q,P}$.




\section{Tautologies}

What should we make of the following claim:

\begin{quote}
  $P\eand Q \models A\eiff\enot\enot A$.
\end{quote}

Notice that the sentence letters on the left-hand-side are completely different letters from those on the right-hand-side.
So there is a straightforward sense in which the two sides of the entailment have \emph{nothing to do with one another}.
Nevertheless, the entailment above is true: every interpretation that satisfies the sentences on the left, also satisfes the sentence on the right for the simple reason that every interpretation whatsoever satisfies $A\eiff\enot\enot A$.

Whereas before we said that an SL sentence $\metaA$ is a tautology just in case it was true on all interpretations of SL (equivalently, all lines of a complete truth table for that sentence), we may now define the SL tautologies in terms of entailment.
Officially, a sentence $\metaA$ of SL is a \define{tautology} just in case $\metaA$ is entailed by the empty set, i.e., $\varnothing \models \metaA$.
Dropping set notation, it is typical to leave off the empty set entirely, writing $\models \metaA$ for brevity.

In order to see why this definition makes sense, we may observe that every SL interpretation satisfies the empty set $\varnothing$.
After all, an SL interpretation $\I$ could only fail to satisfy a set $\Gamma$ of SL sentences if there were some sentence in $\Gamma$ that fails to be true on $\I$.
Since there are no sentences in $\varnothing$, the empty set $\varnothing$ is vacuously satisfied by every SL interpretation whatsoever.
By definition, an SL sentence $\metaA$ is entailed by the empty set (i.e., $\models \metaA$) just in case every interpretation to satisfy the empty set $\varnothing$ also satisfies $\metaA$.
Since we have shown that every interpretation satisfies the empty set, this is equivalent to claiming that every SL interpretation satisfies $\metaA$. 
Thus, $\models \metaA$ if and only if $\V{\I}(A)=1$ for all SL interpretations $\I$.   

Consider the following claims:

\begin{earg}
  \item[] $\models P \eor \enot P$
  \item[] $\models P \eiff P$
  \item[] $\models (P \eand\enot P)\eif (A \eor B)$
\end{earg}

Although for different reasons, each of the entailments above are true, and so the SL sentences on the right are tautologies.
For contrast, the following claims are not tautologies:

\begin{earg}
  \item[] $\models P$
  \item[] $\models P \eand \enot P$
  \item[] $\models \enot(P \eif \enot P)$
\end{earg}

If you ever want to compute whether a sentence is a tautology, you can always write out its truth table.
This can be practical so long as it does not include too many sentence letters.


\section{Weakening}

If the right-hand-side of an entailment claim is a tautology, it doesn't matter what's on the left for the entailment to hold.
For instance, given that $\models P \eor \enot P$, we may conclude that $Q \models P \eor \enot P$.
More generally, we may observe the following:
$$\text{If}~ \Gamma \models \metaA, ~\text{then}~ \Gamma \cup \Sigma\models \metaA.$$
This principle is referred to as \define{weakening}.
As a special case (i.e., $\Gamma=\varnothing$), we may conclude that if $\metaA$ is a tautology (i.e., $\models \metaA$), then every set of SL sentences $\Sigma$ entails $\metaA$ (i.e., $\Sigma \models \metaA$).

In particular, we may draw the following conclusions from the entailments above:

\begin{earg}
  \item[] $Q \models P \eor \enot P$
  \item[] $R \eif (Q \eand \enot Q)\models P \eiff P$
  \item[] $A \eand \enot A \models (P \eand\enot P)\eif (A \eor B)$
\end{earg}

In $\S\ref{sec:entailment}$, we said that if an argument is valid, then its premises entail its conclusion.
Given weakening, it follows that if an argument is valid, then any set containing the arguments premises will entail the argument's conclusion.




\section{Unsatisfiable}

Having defined what it is for a sentence to be a tautology in terms of entailment, it is natural to consider how we might use the notion of entailment to define what it is for a sentence to be a contradiction.
Here it will help to begin by considering the following entailment:
$$P \eand \enot P \models Q.$$
This statement is true.
It says that every interpretation satisfying $P \eand \enot P$ also satisfies $Q$.
This follows vacuously since no interpretation satisfies $P \eand \enot P$, and so every interpretation which satisfies $P \eand \enot P$ (all zero of them) also satisfies $Q$.
Or to take another approach, think about what it would take for the entailment above to be false: there would have to be some interpretation which satisfies $P \eand \enot P$ but does not satisfy $Q$.
But there are no interpretations that satisfy $P \eand \enot P$, and so the entailment above is true.

Observe that the reason that the entailment above is true has nothing to do with the sentence $Q$.
Thus the same considerations would demonstrate that $P \eand \enot P \models \metaA{}$ for any sentence \metaA{} of SL.
Moreover, the same conclusion holds were we to replace $P \eand \enot P$ with any other SL sentence that is not true on any interpretation.
For instance, consider:

\begin{earg}
\item[] $A \eand \enot A \models \enot Q \eif R$.
\item[] $\enot (P \eor \enot P) \models (A_1 \eor A_2) \eif \enot (A_3 \eiff (A_4 \eand \enot A_2))$.
\end{earg}

Since there are no interpretations that satisfy the sentences on the left, you do not need to examine the sentence on the right to confirm that the entailment claims above are true.
Given that the sentences on the right do not matter, it would be nice to have a way to represent that the sentences on the left entail any sentence whatsoever.
There are two common ways to do this, but both make use of the same notation where $\Gamma$ is a set of SL sentences:
$$\Gamma \models \bot.$$
One way to interpret the entailment above is as a universal claim that $\Gamma$ entails every sentence of SL whatsoever. 
Another way to interpret this entailment is to take `$\bot$' to abbreviate some particular sentence of SL (it doesn't matter which) that is not true on any SL interpretation.
These conventions turn out to amount to the very same thing.
For simplicity, we will assume the latter convention where `$\bot$' abbreviates `$A \eand \enot A$' for definiteness.

A sentence $\Gamma$ of SL is \define{unsatisfiable} just in case $\Gamma \models \bot$.
In order to see why this definition makes sense, we may show that a set of SL sentences $\Gamma$ is unsatisfiable just in case there is no SL interpretation $\I$ which satisfies $\Gamma$.
To do so, suppose that $\Gamma$ is unsatisfiable, and so $\Gamma \models \bot$.
It follows that every SL interpretation that satisfies $\Gamma$ also satisfies $\bot$.
However, by design, there is no interpretation that satisfies $\bot$.
Thus there is no SL interpretation $\I$ that satisfies $\Gamma$, for otherwise $\I$ would have to satisfy $\bot$.
Conversely, suppose that there is no SL interpretation $\I$ that satisfies $\Gamma$.
It follows vacuously that every SL interpretation that satisfies $\Gamma$ (all zero of them) also satisfies $\bot$.
Hence $\Gamma \models \bot$, and so $\Gamma$ is unsatisfiable.
This shows that $\Gamma$ is unsatisfiable if and only if there is no SL interpretation $\I$ that satisfies $\Gamma$.
% Haven taken unsatisfiability to be the basic notion, we may now define a set of SL sentences $\Gamma$ to be \define{satisfiable} just in case $\Gamma$ is not unsatisfiable. 
It follows that $\Gamma$ is \define{satisfiable} just in case there is an SL interpretation $\I$ that satisfies $\Gamma$.

Consider the following examples:

\begin{earg}
\item[] $A \eand \enot A \models \bot$.
\item[] $P, \enot P \models \bot$.
\item[] $P \eiff Q, Q \eiff\enot P \models \bot$.
\end{earg}

The sets of sentences on the left of each entailment above are unsatisfiable.\footnote{Recall that we have omitted set notation for ease of exposition.}
As a special case, we may say that an SL sentence $\metaA$ is a \define{contradiction} just in case its singleton set $\set{\metaA}$ is unsatisfiable, i.e., $\metaA \models \bot$.
Whereas contradictions are sentences of SL, only \textit{sets} of sentences of SL may be said to be unsatisfiable.
Nevertheless, it follows by the weakening principle given above that any set of SL sentences which contains a contradiction is unsatisfiable.
By contrast, there are lots of unsatisfiable sets of sentences that do not contain contradictions.
For instance, neither $P \eiff Q$ nor $Q \eiff \neg P$ are contradictions. 
Nevertheless, the set $\set{P \eiff Q, Q \eiff \neg P}$ is unsatisfiable. 
Compare the following examples to those given above:

\begin{earg}
\item[] $(P \eor \enot P) \models\bot$
\item[] $P, \enot Q, (R \eor Q) \models\bot$
\item[] $\enot P, \enot Q, (P \eif \enot\enot Q) \models\bot$
\end{earg}

Since the sentences on the left can be satisfied, the three entailments given above are false.



\section{Consistency}
  \label{sec:consistency}

Recall that the definition of consistency given in $\S\ref{sub:consistency}$ appealed to complete truth-tables: a set of SL sentences $\Gamma$ is \define{consistent} just in case there is at least one line of a complete truth table including every sentence in $\Gamma$ on which all of the sentences in $\Gamma$ are true.
Alternatively, we may avoid appealing to complete truth tables by saying that a set of SL sentences $\Gamma$ is \define{consistent} just in case there is an interpretation $\I$ of SL where every sentence in $\Gamma$ is true, i.e., $\V{\I}(\metaA)$ for all $\metaA$ in $\Gamma$.\label{def.consistencySL}
Accordingly, we may show that any set of SL sentences $\Gamma$ is consistent just in case it is satisfiable. 
Put otherwise, consistency and satisfiablility have the same \textit{extension} insofar as they apply to the very same sets of SL sentences.
As a result, if you ever need help seeing whether a given set of sentences can be satisfied, you can always draw out its truth table to check if any row assigns a `1' every sentence in the set.
If there is no row which assigns a `1` to every sentence in the set, then the set is unsatisfiable.




% \section{Defining truth-conditions in SL}
% \label{sec:truthSL}
% \label{sec.semanticsSL}
%
% % %JH: this section seems to have some conceptual problems. Try to find an analog in the Logic Book or Calgary book and rewrite this! 
% %Could honestly make more sense to just get right to notions of truth-functional entailment, etc. It's not like we're really explaining `truth' in a first-semester logic class. Would need to get into disquotation theory. 
% %so maybe move this and the next section to the end of the chapter! Ultimately, I'd like to combine this stuff w/ the truth tables anyway, like in the logic book! 
% %alternatively, I could combine this section and the next w/ recursion/induction in a chapter on that. 
%
% {\color{black}This section formally characterizes the \emph{truth-conditions} of well-formed formulae (wffs) in SL. These are the logical conditions under which a sentence is true or false.} We build on what we already know from constructing truth tables. In Chapter~\ref{ch.TruthTables}, we used truth tables to reliably test whether a sentence is a tautology in SL, whether two sentences are equivalent, whether an argument is valid, and so on. For instance: \metaA{} is a tautology in SL if and only if it is assigned `1' on every line of a complete truth table.
%
% Truth tables work because each line of a truth table corresponds to a way the world might be, at least conceptually or logically. We consider all the logically possible combinations of 1s and 0s for the sentence letters that compose the sentences we care about. A truth table allows us to determine what would happen given these different combinations. 
%
% {\color{black}To formally define truth-conditions in SL, we introduce a function \textit{\textbf{a}} that assigns---for each interpretation---a 1 or 0 to each of the atomic sentences of SL. We call this function a \textit{truth-value assignment}. We proceed to use the function \textit{\textbf{a}} to construct a more general function \textit{\textbf{v}} called a `valuation function'. Unlike \textit{\textbf{a}}, \textit{\textbf{v}} is defined on arbitrarily complex wffs in SL. We show it is possible to construct the valuation function \textit{\textbf{v}} such that it has the following desirable property:} for any wff \metaA{}, \textit{\textbf{v}}(\metaA{})$=1$ if \metaA{} is true and \textit{\textbf{v}}(\metaA{})$=0$ if \metaA{} is false. 
%
% %It does this by means of a valuation function $\mathbf{v}$, that acts on atomic sentences 
% %We can interpret this function as accurately defining the truth-conditions for SL if it assigns 1 to all of the true sentences of SL and 0 to all of the false sentences of SL. 
%
% Recall that the recursive definition of a wff of SL has two stages: The first step says that atomic sentences (solitary sentence letters) are wffs. The second stage considers wffs that are constructed out of more basic wffs. There is a clause in the definition for each of the sentential connectives. For example, if \metaA{} is a wff, then \enot\metaA{} is a wff.

% \subsection{Truth for Atomic Sentences}
%
% Our strategy for defining the valuation \textit{\textbf{v}} will also be in two steps. The first step will handle truth-conditions for atomic sentences; the second step will handle truth-conditions for compound sentences.
%
% How can we define the truth-conditions for an atomic sentence of SL? Consider, for example, the sentence $M$. Without an interpretation, we cannot say whether $M$ is true or false. It might mean anything. If we use `$M$' to symbolize `The moon orbits the Earth', then $M$ is true. If we use `$M$' to symbolize `The moon is a giant turnip', then $M$ is false.
%
% When we give a symbolization key for SL, we provide a translation into English of the sentence letters that we use. In this way, the interpretation specifies what each of the sentence letters \emph{means}. However, this is not enough to determine whether or not that sentence is true. Assessing the sentences about the moon, for instance, requires that you know some rudimentary astronomy. Imagine a small child who became convinced that the moon is a giant turnip. She could understand what the sentence `The moon is a giant turnip' means, but mistakenly think that it were true.
%
% So a symbolization key alone does not determine whether a sentence is true or false. Truth or falsity depends also on what the world is like. If `$M$' meant `The moon is a giant turnip' and the real moon were a giant turnip, then $M$ would be true. To determine a truth value via the symbolization key, one has to first translate the sentence into English, and then rely on one's knowledge of what the world is like.
%
% We want a logical system that can proceed without astronomical investigation. Moreover, we want to abstract away from the specific commitments of a given symbolization key. So our characterization of truth-conditions proceeds in a different way. We ignore any proffered symbolization key, and take, from a given interpretation, a \emph{truth value assignment}. Formally, this is just a function that tells us the truth value of all the atomic sentences. Call this function `\textit{\textbf{a}}' (for `assignment'). We define \textit{\textbf{a}} for all atomic sentence letters \script{P}, such that
% \begin{displaymath}
% a(\script{P}) =
% \left\{
% 	\begin{array}{ll}
% 	1 & \mbox{if \script{P} is true},\\
% 	0 & \mbox{otherwise.}
% 	\end{array}
% \right.
% \end{displaymath}
% This means that \textit{\textbf{a}} takes any atomic sentence of SL and assigns it either a one or a zero; one if the sentence is true, zero if the sentence is false. 
%
% You can think of \textit{\textbf{a}} as being like a row of a truth table. Whereas a truth table row assigns a truth value to a few atomic sentences, the truth value assignment assigns a value to every atomic sentence of SL. There are infinitely many sentence letters, and the truth value assignment gives a value to each of them {\color{black}(if you're worried about infinity, this might trouble you!)}. When constructing a truth table, we only care about sentence letters that affect the truth value of sentences that interest us. As such, we ignore the rest.
%
% It is important to note that the truth value assignment, \textit{\textbf{a}}, is not part of the language SL. Rather, it is part of the mathematical machinery that we are using to describe SL. It encodes which atomic sentences are true and which are false.
%
% \subsection{Truth for arbitrary SL sentences}
%
% We now define the valuation function, \textit{\textbf{v}}, using the same recursive structure that we used to define a wff of SL.
%
% \begin{enumerate}
% \item If \metaA{} is a sentence letter, then \textit{\textbf{v}}(\metaA{}) $=$ \textit{\textbf{a}}(\metaA{}).
% %\setcounter{Example}{\arabic{enumi}}\end{enumerate}
% %...
% % Break out of the {enumerate} environment to say something about what is
% % going on. Using \setcounter in this way preserves the numbering, so
% % that the list can resume after the comments.
%
% %This is a mathematical equals sign, not the identity predicate we defined for QL.
%
% % Resume the {enumerate} environment and restore the counter.
% %...
% %\begin{enumerate}\setcounter{enumi}{\arabic{Example}}
%
% \item If \metaA{} is ${\enot}\metaB{}$ for some sentence \metaB{}, then
% \begin{displaymath}\textit{\textbf{v}}(\metaA{}) =
% 	\left\{\begin{array}{ll}
% 	1 & \mbox{if \textit{\textbf{v}}(\metaB{}) $= 0$},\\
% 	0 & \mbox{otherwise.}
% 	\end{array}\right.
% \end{displaymath}
%
% \item If \metaA{} is $(\metaB{}\eand\metaC{})$ for some sentences \metaB{}, \metaC{}, then
% \begin{displaymath}\textit{\textbf{v}}(\metaA{}) =
% 	\left\{\begin{array}{ll}
% 	1 & \mbox{if \textit{\textbf{v}}(\metaB{}) $= 1$ and \textit{\textbf{v}}(\metaC{}) $= 1$,}\\
% 	0 & \mbox{otherwise.}
% 	\end{array}\right.
% \end{displaymath}
% \setcounter{Example}{\arabic{enumi}}\end{enumerate}
% %...
% \label{truthdefinition}
% You may be tempted to worry that this definition is circular, because it uses the word `and' in trying to define `and.' But remember, we are not attempting to give a definition of the English word `and'; we are giving a definition of truth-conditions for sentences of SL containing the logical symbol `\eand.' We define truth-conditions for object language sentences containing the symbol `\eand' using the metalanguage word `and.' There is nothing circular about that.
%
% %...
% \begin{enumerate}\setcounter{enumi}{\arabic{Example}}
%
% \item If \metaA{} is $(\metaB{}\eor\metaC{})$ for some sentences \metaB{}, \metaC{}, then
% \begin{displaymath}\textit{\textbf{v}}(\metaA{}) =
% 	\left\{\begin{array}{ll}
% 	0 & \mbox{if \textit{\textbf{v}}(\metaB{}) $= 0$ and \textit{\textbf{v}}(\metaC{}) $= 0$,}\\
% 	1 & \mbox{otherwise.}
% 	\end{array}\right.
% \end{displaymath}
% %\setcounter{Example}{\arabic{enumi}}\end{enumerate}
% %...
% %Notice that this defines truth for sentences containing the symbol `\eor' using the word `and.'
% %...
% %\begin{enumerate}\setcounter{enumi}{\arabic{Example}}
%
% \item If \metaA{} is $(\metaB{}\eif\metaC{})$ for some sentences \metaB{}, \metaC{}, then
% \begin{displaymath}\textit{\textbf{v}}(\metaA{}) =
% 	\left\{\begin{array}{ll}
% 	0 & \mbox{if \textit{\textbf{v}}(\metaB{}) $= 1$ and \textit{\textbf{v}}(\metaC{}) $= 0$,}\\
% 	1 & \mbox{otherwise.}
% 	\end{array}\right.
% \end{displaymath}
%
% \item If \metaA{} is $(\metaB{}\eiff\metaC{})$ for some sentences \metaB{}, \metaC{}, then
% \begin{displaymath}\textit{\textbf{v}}(\metaA{}) =
% 	\left\{\begin{array}{ll}
% 	1 & \mbox{if \textit{\textbf{v}}(\metaB{}) $=$ \textit{\textbf{v}}(\metaC{})},\\
% 	0 & \mbox{otherwise.}
% 	\end{array}\right.
% \end{displaymath}
% \end{enumerate}
%
% Since the definition of \textit{\textbf{v}} has the same structure as the definition of a wff, we know that \textit{\textbf{v}} assigns a value to \emph{every} wff of SL. Since the sentences of SL and the wffs of SL are the same, this means that \textit{\textbf{v}} returns the truth value of every sentence of SL.
%
% Setting aside tautologies and contradictions, the truth or falsity of a sentence in SL is always \emph{relative to} some interpretation. This is because the sentence's truth-conditions do not say whether it is true or false. Rather, the truth-conditions specify how the truth of that sentence relates to a truth value assignment \textit{\textbf{a}} to atomic sentence letters.




%************************JH******************************
%stuff I cut from Ichikawa's version or additional concerns I had about it: 

%JH: following seems unnecessary
%(Technical side note: one might be tempted to \emph{identify} interpretations with assignments of truth values to atomic sentences. (In past versions of this book, that's actually what I did.) For a variety of reasons, this is not (any longer) my preference. One reason is that there can be different ways to assign truth values to atomic sentences, corresponding to one and the same row of the truth table, if one includes values for atoms that are not mentioned in the truth table. In a truth table for a sentence that doesn't include an $R$, for instance, these two assignments of truth values to atoms are effectively equivalent, and correspond to the same row of the truth table: \{$P=1$, $Q=1$, $R=1$\}, \{$P=1$, $Q=1$, $R=0$\}. So there could be different interpretations corresponding to the same row of the truth table, but an interpretation \emph{determines} a row of a truth table.

%A more complex motivation for my terminological choice here has to do with the relationship between SL and QL, a more complex language we'll learn later in the textbook. I'll return to this connection in \S\ref{sec.0PlaceModels}.)

%JH: I don't understand the following paragraph or the point of it...
%Once we construct a truth table, the symbols `1' and `0' are divorced from their metalinguistic meaning of `true' and `false'. We interpret `1' as meaning `true', but the formal properties of 1 are defined by the characteristic truth tables for the various connectives.  The symbols in a truth table have a formal meaning that we can specify entirely in terms of how the connectives operate. For example, if $A$ is value 1, then $\enot A$ is value 0.

%JH: part of the following `defN of truth' seems circular, since we appeal to a pretheoretic notion of `true sentences of SL' when we say ``We can interpret this function as a definition of truth for SL if it assigns 1 to all of the true sentences of SL and 0 to all of the false sentences of SL". Indeed, we could flip the valuation and we would syntactically have just as good a characterization of truth conditions. We just wouldn't have a `match' with the world. But this modeling principle/norm is separate from the abstract project of characterizing truth-conditions recursively, i.e. showing the compositionality of truth-conditions in SL. 

%JH: it seems a bit misleading to describe this construction as giving a definition of `truth' in sentential logic (indeed as the last paragraph of this section itself seems to indicate!). Rather, we are showing that sentential logic has a compositionality principle: the truth value of a sentence is determined by the truth values of component parts. 

%JH: following seems to indicate that we're not really defining `truth' in SL. we're showing that truth in SL is compositional. Nice illustration of recursive reasoning, but that's about it! so could be a good warmup for the week on induction/recursion. but not essential for the HW problems for ch. 2 and 3 on truth tables, entailment, validity. 


\iffalse

\practiceproblems



\problempart
\label{HW3.C}
Each of the following claims can be evaluated with truth tables. For each, what would you look for in a completed truth table to evaluate it? The Greek letters can stand for any arbitrary sentence of SL. The first claim has the answer filled out for you.

\begin{earg}
		\item[0.] $\Phi$ is a tautology.
		To evaluate this claim, check to see whether the main connective of $\Phi$ has a 1 under it in every row. If so, it is true.
		\item $\Phi \models \Psi$. 
		To evaluate this claim, check to see whether... 
		
		\item $\Phi$ is contingent.
\item $\Phi \models \bot$
		\item $\emptyset \models \Phi$
	\end{earg}


\problempart
Determine whether each entailment claim is true. You may construct a truth table to test it if you like, but these examples are simple enough so that you may be able to just think it through and get the right answer.
\begin{earg}
\item $Q \models (P \eor Q)$
\item $P, Q \models (P \eor P)$
\item $P \eiff Q, P \models Q$ %  \textcolor{red}{True.}
\item $S \models (Q \eif Q)$   %\textcolor{red}{True.}
\item $P \eand \enot P \models (Q \eor \enot Q)$%   \textcolor{red}{True.}
\item $(P \eand \enot P) \models (Q \eand \enot Q)$
\item $(P \eor \enot P) \models \bot$
\item $(P \eor \enot P) \models Q$%   \textcolor{red}{False: $\{P=1, Q=0\}$.}
\item $\models (P \eor \enot P)$
\item $\models (P \eand \enot P)$
\item $(A \eor B) \eif \enot P \models (P \eor \enot P)$
\item $(P \eiff Q) \models ((P \eand Q) \eor \enot (P \eor Q))$
\end{earg}

\fi 
