%!TEX root = forallx-ubc.tex
\chapter{Identity}
\label{ch.identity}

The last two chapters introduced the syntax and semantics for QL.
In this chapter, we will extend both the syntax and semantics of QL to accommodate the \define{identity} predicate `$=$', referring to this extended languages as QL$^=$.

It is important to emphasises that to say that $\v{x}$ and $\v{y}$ are identical is different from saying that $\v{x}$ and $\v{y}$ are \textit{duplicates} though this is a common way of using the word `identity' in English.
For instance, consider the use of the word `identical' in the following case:

  \begin{quote}
    \texttt{Spheres}: Consider a possible world in which there is nothing but two identical spheres, similar in every way to each other, separated by just one meter.
    Although there is no property that they do not share, the two spheres are distinct.
    After all, there are two spheres, not just one.
  \end{quote}

Insofar as the spheres are distinct--- there are two of them, not one--- we will say that they are not \textit{numerically identical}, or just \textit{non-identical} for short.
If `$a$' names one sphere and `$b$' names the other, we may express this with the sentence `${=}ab$' where `$=$' is a two place predicate, or `$a=b$' for the sake of readability and familiarity.
In this sense of identity, it is not true that the two spheres are identical as claimed in \texttt{Spheres}.
Indeed, no two things whatsoever are identical in our sense since if they were, then they would not be two things after all but rather just one thing perhaps with different names.

Before showing how to include a designated predicate for identity in the syntax and semantics for QL$^=$, it will help to guide our ambitions by considering some of what motivates this addition.
After all, QL is very powerful language, at least by comparison to SL.
Why should we need to further extend QL?
Can't we get by without identity?



\section{Motivation}%
  \label{sec:Motivation}

It turns out that there is a lot that cannot be said without an identity predicate.
You might be wondering why we can't just declare that a certain predicate be used to express identity the way that we do in regimenting other predicates in QL.
For instance, suppose we were to regiment `Hesperus is Phosphorus' as `$Ihp$' given the following symbolization key:

\begin{ekey}
% \begin{multicols}{2}
\item[Ixy:] $x$ is $y$
\item[h:] Hesperus
\item[p:] Phosphorus
\item[v:] Venus
% \end{multicols}
\end{ekey}

One might take the regimentation given above to do as good a job as any of our regimentations in QL.
Why does identity deserve special treatment?

Consider the following English argument regimented with the symbolization given above:

\begin{multicols}{2}
  
\begin{earg}
  \item[] Hesperus is Phosphorus.
  \item[] Phosphorus is Venus.
  \item[\therefore] Hesperus is Venus.
\end{earg}

\begin{earg}
  \item[] $Ihp$
  \item[] $Ipv$
  \item[\therefore] $Ihv$
\end{earg}

\end{multicols}

This argument is invalid.
For instance, consider the following countermodel:

\begin{partialmodel}
	$\D$		& $\set{h,p,v}$\\
  $\I(I)$ & $\set{\tuple{h,p},\tuple{p,v}}$\\
	$\I(h)$	& $h$\\
	$\I(p)$	& $p$\\
	$\I(v)$	& $v$
\end{partialmodel}

Since $\tuple{h,p},\tuple{p,v}\in\I(I)$ but $\tuple{h,v}\notin\I(I)$, it follows that $\tuple{\I(h),\I(p)},\tuple{\I(p),\I(v)}\in\I(I)$ and $\tuple{\I(h),\I(v)}\notin\I(I)$, and so by definition $\tuple{\VV{\I}{\va{a}}(h),\VV{\I}{\va{a}}(p)},\tuple{\VV{\I}{\va{a}}(p),\VV{\I}{\va{a}}(v)}\in\I(I)$ and $\tuple{\VV{\I}{\va{a}}(h),\VV{\I}{\va{a}}(v)}\notin\I(I)$ where $\va{a}$ is any variable assignment that does no substantive work here.
It follows that $\VV{\I}{\va{a}}(Ihp)=\VV{\I}{\va{a}}(Ipv)=1$ and yet $\VV{\I}{\va{a}}(Ihv)\neq 1$.
Having produced a model which makes the premises true and the conclusion false, the argument is not valid.

An analogous argument shows that the following argument is also invalid:

\begin{multicols}{2}

\begin{ekey}
  \item[Txy:] $x$ is taller than $y$
  \item[k:] Kate
  \item[s:] Sam
  \item[l:] Lu
\end{ekey}

\begin{earg}
  \item[] Kate is taller than Sam.
  \item[] Sam is taller than Lu.
  \item[\therefore] Kate is taller than Lu.
  \item[] ~
\end{earg}

\end{multicols}

\begin{multicols}{2}

\begin{partialmodel}
	$\D$		& $\set{k,s,l}$\\
  $\I(T)$ & $\set{\tuple{k,s},\tuple{s,l}}$\\
	$\I(k)$	& $k$\\
	$\I(s)$	& $s$\\
	$\I(l)$	& $l$
\end{partialmodel}

\begin{earg}
  \item[] $Tks$
  \item[] $Tsl$
  \item[\therefore] $Tkl$
\end{earg}
\vfill
\strut

\end{multicols}

Replacing `$I$' with `$T$' and similarly replacing `$h$' with `$k$' and so on for the other constants, the very same semantic proof could be repurposed to show that the premises in the argument above do not entail the conclusion.
Here we may ask if this is right, and if so, why we shouldn't say the very same thing about the identity argument.

Certainly it should be admitted that the taller-than argument is a very strong argument in ordinary contexts.
After all, given the intended interpretation of English, any \textit{possibility} in which Kate is taller than Sam and in which Sam is taller than Lu is also a possibility in which Kate is taller than Lu. 
The reason the argument is invalid is that nothing forces us to interpret the predicate `is taller than' as meaning what it usually means.
Put otherwise, the dyadic predicate `is taller than' is a \define{non-logical} term of our language, and is to be regimented by a non-logical dyadic predicate in QL which we may interpret by any subset of $\D^2$ given any domain $\D$ whatsoever. 
This makes the argument easy to invalidate.

Were to want to make the taller-than argument valid, we would have to add an additional premise as in the follow arguments:

\begin{multicols}{2}
  
\begin{earg}
  \item[] $(Tks \eand Tsl) \eif Tkl$
  \item[] $Tks$
  \item[] $Tsl$
  \item[\therefore] $Tkl$
\end{earg}

\begin{earg}
  \item[] $\forall x\forall y \forall z((Txy \eand Tyz) \eif Txz)$
  \item[] $Tks$
  \item[] $Tsl$
  \item[\therefore] $Tkl$
\end{earg}

\end{multicols}

Both of the arguments above are valid.
Whereas the argument on the right starts off by asserting that the taller-than relation is transitive, the argument on the left appeals to a particular instances of the transitivity of the taller-than relation.

It is natural to assume that on the intended interpretation of `is taller than' in English, we mean to express a transitive relation since this is how heights behave.
In reasoning from $Tks$ and $Tsl$ to $Tkl$, we are implicitly relying on our intuitive grasp of a particular interpretation rather than not general logical features of the sentences involved. 
That is, the argument is convincing not because of its logical form, but because of the particular interpretation that we are assuming, i.e., where `is taller than' expresses a transitive relation.
When we add a premises which requires $T$ to be transitive (or else add the relevant instance), we are making our assumptions explicit in a way that avoids reliance on a particular intended interpretation of our language.
Instead, the amended arguments given above are valid since any model which makes these premises true makes their conclusions true. 
Put otherwise, the conclusion follows by virtue of the logical forms of the sentences and not some particular interpretation.

What about the identity argument?
Certainly we could reproduce a similar story, claiming that as it stands, the identity argument we started off with is not valid but could be made valid by adding a premise that requires identity to be transitive.
The question is whether this would be appropriate in the case of an identity predicate.
More specifically, is it permissible to interpret identity as \textit{any} subset of $\D^2$ over any domain $\D$?

The answer is certainly `Yes' since this is exactly how we would interpret the identity argument in QL.
Nevertheless, there is good not to go this way, choosing instead to include a designated predicate for identity in QL$^=$.
Recast in QL$^=$, the original identity argument becomes:

\begin{multicols}{2}
  
\begin{earg}
  \item[] Hesperus is Phosphorus.
  \item[] Phosphorus is Venus.
  \item[\therefore] Hesperus is Venus.
\end{earg}

\begin{earg}
  \item[] $h=p$
  \item[] $p=v$
  \item[\therefore] $h=v$
\end{earg}

\end{multicols}

Instead of taking this argument to only be convincing when we restrict consideration to an intended interpretation where `$=$' means identity, we are taking identity to be a logical notion akin to negation, conjunction, and the quantifiers.
Rather than relying on the intended interpretation of our language to tell us what identity means, we are going to provide semantic clauses in just the same way that we did for the other logical terms of our language.
% Roughly, `$\alpha=\beta$' is true in a model $\M=\tuple{\D,\I}$ given a variable assignment $\va{a}$ just in case $\alpha$ and $\beta$ refer to the same individual in the model.
% Note that we have used `the same individual' to provide the semantics for identity.
As a result, the argument above will turn out to be valid as it stands.

You might be wondering why we don't do something similar for the `is taller than' predicate, and so on for other notions like `between', or `is older than', etc.
There are two reasons worth considering.
The first is that there is no clear stopping point.
Were we to start expanding the range of logical predicates whose interpretation we hold fixed by providing semantic clauses, we could go and go forever.
This in itself does not require that we do so--- we could just choose to include certain predicates in the logical vocabulary of our language and not others given our purposes.
The second reason is more forceful: in order to provide a semantic clause for the taller-than predicate `$T$', we would have to provide a theory of what it is for one thing to be taller than another.
Without providing such a theory, nothing guarantees that $T$ is transitive, and so the taller-than argument would remain invalid. 

% Suppose one were to attempt to provide a theory of the taller-than predicate by taking $T$ to be transitive and irreflexive, using QL to state these assumptions.
% Here we may object that there are lots of relations that are transitive and irreflexive, and so given these constraints alone, we have no reason to think that $T$ picks out the taller-than relation rather than some other relation.
% For instance `is older than' is also transitive and irreflexive, but means something completely different than `is taller than'.
%
% Although one might attempt to improve on our initial theory of being taller than, doing so reaches beyond the subject-matter of logic.
% Rather, logic is concerned with the so called \define{logical terms} like negation, conjunction, quantification, and identity, where these notions do not concern any particular ways for things to be (e.g., one thing being taller than another), but rather provide very general conceptual resources for articulating theories in the first place.
% For instance, one may point out that we might use a language like QL in order to provide a theory constraining the interpretation of $T$.
% In particular, consider the following constraint:
%   $$(\alpha=\beta) \supset (T\alpha\gamma\equiv T\beta\gamma).$$
% This says that if $\alpha=\beta$, then $\alpha$ is taller than $\gamma$ just in case $\beta$ is taller than $\gamma$. 
% Certainly this seems true, and yet it is unclear how we would state such a principle for our theory of the taller-than relation without recourse to the identity predicate.
% This gives us reason to think that the theory of the taller-than relation should be presented in QL$^=$ instead of QL. 
% By contrast, we do not need to appeal to $T$ in order to provide a theory of identity.


Although one might attempt to provide a theory of the taller-than relation, doing so reaches beyond the subject-matter of logic.
Moreover, it would be natural to use a language like QL$^=$ in order to develop such a theory. 
The same cannot so easily be said for identity.
Instead of falling outside the subject-matter of logic, identity is taken to fit squarely within our present aim to develop the conceptual resources that we need to articulate theories in the first place.\footnote{A prominent example is set theory where the predicate `$\in$' may be axiomatized in QL$^=$.}
Instead of requiring that we develop an independent theory of identity, the semantics for identity will rely on our understanding of identity in the metalanguage in much the same way that the semantics for negation relied on an understanding of negation in the metalanguage.


Before pressing on, it is worth considering three more cases involving identity.
To begin with, consider the following example originally presented by Gottlob Frege:

\begin{multicols}{2}

\begin{ekey}
  % \begin{multicols}{2}
    \item[Rx:] $x$ is rising.
    \item[h:] Hesperus
    \item[p:] Phosphorus
  % \end{multicols}
\end{ekey}

\begin{earg}
  \item[] Hesperus is rising.
  \item[] Hesperus is Phosphorus.
  \item[\therefore] Phosphorus is rising.
\end{earg}

\end{multicols}

As specified below, identity is a primitive symbol of QL$^=$.
Accordingly, we do not need to include identity in the symbolization key given above to provide the following regimentation.

\begin{earg}
  \item[] $Rh$
  \item[] $h=p$
  \item[\therefore] $Rp$
\end{earg}

This is a valid argument.
Instead of restricting consideration to an intended interpretation, or else adding some further assumptions, the conclusion is entailed by the premises given the semantics that we will provide for QL$^=$.

% However, insofar as different models may have different domains, the interpretation of the identity predicate will have to change accordingly.
% Instead of assigning the identity predicate to some subset of $\D^2$ for some particular domain $\D$ once and for all, we will provide a semantic clause for identity in much the same way that we did for the other logical terms included in QL. 
% We will provide these details in due course, but for now we will focus on the motivations for doing so.

Next consider the regimentation of the following argument:

\begin{multicols}{2}

\begin{ekey}
  \item[Lxy:] $x$ loves $y$
  \item[c:] Cara
  \item[p:] Pedro
  \item[d:] DJ Faro
\end{ekey}

\vfill
\strut
\columnbreak

\begin{earg}
  \item[] Only Cara loves Pedro.
  \item[] DJ Faro loves Pedro.
  \item[\therefore] Cara is DJ Faro.
\end{earg}

\begin{earg}
  \item[] $Lcp \eand \forall x(Lxp \eif x=c)$
  \item[] $Ldp$
  \item[\therefore] $c=d$
\end{earg}

\end{multicols}

This is a valid argument.
Although we could say that Cara loves Pedro in QL, we could not say that \textit{only} Cara loves Pedro in QL since to do so we would need to say that anything that loves Pedro is identical to Cara.
Moreover, given that DJ Faro loves Pedro, we may conclude that DJ Faro must be identical to Cara.
Reasoning in this way requires that we extend the expressive power of QL by including identity in the language.

Here is a third example. 
Consider the following regimentations of sentence $\ref{M1}$:

\begin{earg}
  \item[\ex{M1}] Mozart composed at least two things.
\end{earg}

\begin{multicols}{2}

\begin{ekey}
  \item[Cxy:] $x$ composed $y$
  % \item[Sx:] $x$ is a symphony. 
  \item[m:] Mozart
  \item[] ~
\end{ekey}

\begin{earg}
  \item[\ex{M2}] $\qt{\exists}{x} Cmx \eand \qt{\exists}{y} Cmy$.
  \item[\ex{M3}] $(\qt{\exists}{x} Cmx \eand \qt{\exists}{y} Cmy) \eand x\neq y$.
  \item[\ex{M4}] $\qt{\exists}{x}\qt{\exists}{y}((Cmx \eand Cmy) \eand x\neq y)$.
\end{earg}

\end{multicols}

Although sentence $\ref{M2}$ can be stated in QL, this regimentation does not require that there are more than two things that Mozart composed.
This is because both conjuncts could be satisfied by the same thing, and so the sentence would be true if there was just one thing that Mozart composed.
Sentence $\ref{M3}$ is worse since this is not even a sentence. 
Rather, it includes free variables which fall outside of the scope of both quantifiers.
By contrast, sentence $\ref{M4}$ provides an adequate regimentation, though does so by making the quantifiers have scope over all instances of $x$ and $y$. 
The success of this regimentation has profound consequences for it means that we can regiment `at least two'.
As we will see, we may also regiment `at most two', where `exactly two' will be regimented by their conjunction.

What all of these cases show us is that if we want to reflect the logical relationships having to do with identity, we need special logical vocabulary to do so.
Just as we introduced the `$\forall$' and `$\exists$' to regiment quantified claims, we also need a special symbol `$=$' for identity.




\section{The Syntax of QL$^=$}

It may be obvious how to build up sentences in our extended language QL$^=$, but officially we need to define the wffs of QL$^=$ afresh. 
Nevertheless, much will be as it was before.

\begin{enumerate}
  \item $\F^n\alpha_1,\ldots,\alpha_n$ is a wff if $\F^n$ is an $n$-place predicate and $\alpha_1,\ldots,\alpha_n$ are singular terms.
  \item $\alpha=\beta$ is a wff if $\alpha$ and $\beta$ are singular terms.
\item If \metaA and \metaB are wffs and $\alpha$ is a variable, then:
	\begin{enumerate}
    % \begin{multicols}{2}
      \item $\qt{\exists}{\alpha}\metaA$ is a wff;
      \item $\qt{\forall}{\alpha}\metaA$ is a wff;
      \item $\enot\metaA$ is a wff;
      % \item[] ~
      \item $(\metaA\eand\metaB)$ is a wff;
      \item $(\metaA\eor\metaB)$ is a wff;
      \item $(\metaA\eif\metaB)$ is a wff; and
      \item $(\metaA\eiff\metaB)$ is a wff.
    % \end{multicols}
	\end{enumerate}
\item Nothing else is a wff.
\end{enumerate}

Here we have two ways to form atomic wffs.
Whereas the first way is exactly as we did in QL, we may also form wffs with the identity predicate.
Nevertheless, nothing requires identity wffs to be sentences since they may include free variables.
This means that we will also have to extend our definition of free variables in as corresponding manner:

\begin{enumerate}
  \item $\alpha$ is free in $\F^n\alpha_1,\ldots,\alpha_n$ if $\alpha=\alpha_i$ for some $1\leq i\leq n$ where $\alpha$ is a variable, $\F^n$ is an $n$-place predicate, and $\alpha_1,\ldots,\alpha_n$ are singular terms.
  \item $\alpha$ is free in $\beta=\gamma$ if $\alpha=\beta$ or $\alpha=\gamma$ where $\alpha$ is a variable.
  \item If $\metaA$ and $\metaB$ are wffs and $\alpha$ and $\beta$ are variables, then:
    \begin{enumerate}
        \item $\alpha$ is free in $\qt{\exists}{\beta}\metaA$ if $\alpha$ is free in $\metaA$ and $\alpha\neq\beta$;
        \item $\alpha$ is free in $\qt{\forall}{\beta}\metaA$ if $\alpha$ is free in $\metaA$ and $\alpha\neq\beta$;
        \item $\alpha$ is free in $\enot\metaA$ if $\alpha$ is free in $\metaA$;
        \item $\alpha$ is free in $(\metaA\eand\metaB)$ if $\alpha$ is free in $\metaA$ or $\alpha$ is free in $\metaB$;
        \item $\alpha$ is free in $(\metaA\eor\metaB)$ if $\alpha$ is free in $\metaA$ or $\alpha$ is free in $\metaB$;
        \item $\alpha$ is free in $(\metaA\eif\metaB)$ if $\alpha$ is free in $\metaA$ or $\alpha$ is free in $\metaB$;
        \item $\alpha$ is free in $(\metaA\eiff\metaB)$ if $\alpha$ is free in $\metaA$ or $\alpha$ is free in $\metaB$;
    \end{enumerate}
  \item Nothing else is a free variable. 
\end{enumerate}








\section{Identity and `no one else'}

Consider again sentence \ref{onlyyou}:

\begin{ekey}
\item[\ref{onlyyou}.] Only you can prevent forest fires.
\end{ekey}

In the introduction we tried translating this into QL with a predicate `only  \blank can prevent forest fires'; now we can reflect its logical structure more fully. So we'll let our predicate just indicate the ability to prevent forest fires:

\begin{ekey}
\item[UD:] people
\item[Px:] $x$ can prevent forest fires
\item[u:] you
\end{ekey}

If only you can prevent forest fires, that means that you can prevent forest fires, and, moreover, no one \emph{else} --- no one who is not you --- can prevent forest fires. The first part is simple. You can prevent forest fires: $Pu$. Now we must say that no one else can prevent forest fires. Another way to say that is this: it is \emph{not} the case that there is someone \emph{who is not you} who can prevent forest fires. So you can think of that as a negated existential: $\enot \qt{\exists}{x} (x {\neq} u \eand Px)$. Putting these two pieces together as a conjunction, we can translate sentence \ref{onlyyou} as:

\begin{earg}
\item[\ref{onlyyou}.] $Pu \eand \enot \qt{\exists}{x} (x {\neq} u \eand Px)$
\end{earg}

A second way of characterizing the `no one else' clause would translate it as a universal claim, saying, of everything, that if it is not you, then it cannot prevent forest fires: $\qt{\forall}{x} (x {\neq} u \eif \enot Px)$. This is equivalent to $\enot \qt{\exists}{x} (x {\neq} u \eand Px)$; either is an acceptable translation. (By the end of this chapter we'll be able to prove this equivalence.)

Using similar reasoning, one can translate other kinds of sentences that talk about objects \emph{other than} ones just mentioned. For example, suppose we want to say that Rebecca only thinks about herself. She thinks about herself, and there is no one else that she thinks about. Using $r$ for Rebecca and $Txy$ for `$x$ thinks about $y$', we could say: $$Trr \eand \enot \qt{\exists}{x} (x {\neq} r \eand Trx)$$

There are more examples of similar kinds of translation exercises in the practice problems at the end of this chapter.

\section{Identical objects satisfy identical predicates}

In \S\ref{sec.identitymotivation}, we saw that treating identity as a simple predicate prevented the validity of intuitively valid arguments like  this one:

\begin{earg}
\item[\ref{ppq}] Peter Parker lives in Queens.
\item[\ref{pps}] Peter Parker is Spider-Man.
\item[\ref{sq}] Spider-Man lives in Queens.
\end{earg}

The problem was that if the extension of the identity predicate can simply be presented in a model, without regard for the other features of the model, there was no guarantee that $p$ and $s$ --- the names for Peter Parker and Spider-Man --- were related in any particular way, just because \ntuple{Peter Parker, Spider-Man} happened to be assigned in the extension of the $I$ predicate.

But if we translate the identity predicate with the QL identity claim $p{=}s$, this requires that the names $s$ and $p$ be assigned to the \emph{very same object} in the model. Consequently, for any sentence \metaA{} involving the name $p$, \metaA{}\substitute{p}{s} --- the sentence that results from replacing each $p$ in \metaA{} with an $s$ --- will have the same truth value as \metaA{}. If $Fp$ is true, then the object named by $p$ is in the extension of $F$. And if $p{=}s$, then the object named by $p$ is \emph{the very same object as} the object named by $s$. So of course the object named by $s$ (that same object) must also be in the extension of $F$. In general, identical objects have identical properties.

(The converse is not true in general. There is no rule in QL that says that if all the same wffs are true of two different names, they must be two names for the same object.)

If Peter is Spider-Man, then everything true of Peter is also true of Spider-Man. So this argument form, unlike the first translation we attempted, is valid in QL:

\begin{earg}
\item[] $Lpq$
\item[] $p{=}s$
\item[\therefore] $Lsq$
\end{earg}

In \S\ref{sec.identity.trees} below we'll extend our tree method to claims with identity, which will give us a formal means for proving the validity of arguments like this one. (The natural deduction system for QL given in Chapter \ref{ch.QLND} will give us another.)





\section{Quantity}
\label{sec.quantity}

Identity also lets us talk about quantity in a way that wasn't available before. In \S\ref{sec.identitymotivation} we observed some challenges with translating claims about the number of objects that satisfy a particular description. For example, we struggled with sentences like `Mozart composed more than one opera'. But identity makes such claims straightforward.

\begin{ekey}
\item[UD:] people and operas
\item[Cxy:] $x$ composed $y$
\item[Ox:] $x$ is an opera
\item[m:] Mozart
\item[n:] \emph{Le Nozze di Figaro}
\item[g:] \emph{Don Giovanni}
\end{ekey}

We want to say that there are two things, that have the following features: they are different from each other, they are both operas, and they are both composed by Mozart. A double-existential sentence, listing those conjuncts, will suffice: 
$$\qt{\exists}{x} \qt{\exists}{y} (x {\neq} y \eand Ox \eand Oy \eand Cmx \eand Cmy)$$
Strictly speaking, QL conjunctions only have two conjuncts, so to write this sentence scrupulously, we'd need to include brackets to signify that we're talking about conjunctions of conjunctions:
$$\qt{\exists}{x} \qt{\exists}{y} (x {\neq} y \eand [(Ox \eand Oy) \eand (Cmx \eand Cmy)])$$
In sentences like these --- and the longer ones listing more conditions that will feature soon --- it is usually preferable for readability to leave these internal brackets out. We will write as if our system allows arbitrary numbers of conjuncts, with the understanding that, should the need arise, we could always put them back in explicitly. (We'll rarely have occasion to do so.)

This sentence says that Mozart wrote at least two operas. To say that he wrote at least \emph{three} operas would require another quantifier with a new variable $z$, and the specification that $z$ be an opera, written by Mozart, and non-identical to both of the ones previously mentioned:
\begin{multline*}
\qt{\exists}{x} \qt{\exists}{y} \qt{\exists}{z} (x {\neq} y \eand x {\neq} z \eand y {\neq} z \eand 
Ox \eand Oy \eand Oz \eand Cmx \eand Cmy \eand Cmz)
\end{multline*}

As you can see, these sentences get long and complicated rather quickly.

Suppose we wanted to say that Mozart composed \emph{exactly} two operas --- no more, and no fewer. There are two reasonably natural choices for how to say that. One is to conjoin the first QL sentence of this section --- Mozart composed at least two operas --- with the negation of the second --- Mozart did not compose at least three operas. The result is:
\begin{multline*}
\qt{\exists}{x} \qt{\exists}{y} (x {\neq} y \eand Ox \eand Oy \eand Cmx \eand Cmy) \eand \\ \enot \qt{\exists}{x} \qt{\exists}{y} \qt{\exists}{z} (x {\neq} y \eand x {\neq} z \eand y {\neq} z \eand Ox \eand Oy \eand Oz \eand Cmx \eand Cmy \eand Cmz)
\end{multline*}

A slightly more efficient way of saying the same thing, rather than conjoining a new negated triple existential, would be to add, within the scope of the first two quantifiers, a conjunct to the effect that every opera composed by Mozart is one of the two mentioned in that first conjunction. To say that any opera composed by Mozart is either $x$ or $y$ is to say that, for any $z$, if $z$ is an opera composed by Mozart, then it is either $x$ or $y$. In other words: $\qt{\forall}{z} [(Oz \eand Cmz) \eif (z{=}x \eor z{=}y)]$. So another way to say that Mozart composed exactly two operas is:
\begin{multline*}
\qt{\exists}{x} \qt{\exists}{y} ((x {\neq} y  \eand  Ox \eand Oy \eand  Cmx \eand Cmy) \eand \qt{\forall}{z} [(Oz \eand Cmz) \eif (z{=}x \eor z{=}y)])
\end{multline*}

So identity gives us a way to talk about quantities, albeit not a particularly efficient one.



\section{Definite descriptions}
\label{sec.defdesc}
In 1905, Bertrand Russell famously characterized \emph{definite descriptions} in terms of identity. A definite description is a description that implies that only one object satisfies it. Paradigmatically, definite descriptions are ones that use the definite article `the'. If I say `the baby is hungry', I'm saying that the \emph{one and only baby we might be talking about} is hungry. Russell was motivated in part by the apparent fact that one can use this sort of language in a meaningful way even if one is wrong about whether there's any baby around. If there is no baby --- the crying I'm hearing is a recording --- my statement is false, but it's still meaningful. For this reason, Russell was reluctant to suppose that we should understand `the baby' as a name. Remember, in QL, all names have to refer to objects in the UD. Instead, my sentence can be understood as an existentially quantified claim about a unique baby. If I say `the baby is hungry', according to Russell, I'm in effect saying three things: there is a baby, there's no other baby than that one, and that baby is hungry. That second element, the uniqueness claim, can be expressed in QL with identity. 

\begin{ekey}
\item[UD:]People in this house
\item[Bx:]$x$ is a baby
\item[Hx:]$x$ is hungry
\item[j:]Jonathan
\end{ekey}

A sentence like `Jonathan is hungry' is straightforwardly translated as $Hj$. According to Russell's theory of definite descriptions, `the baby is hungry' has a much more complex logical form: there is a baby $x$, there is no baby other than $x$, and $x$ is hungry.

\begin{equation*}
\qt{\exists}{x} [Bx \eand \enot \qt{\exists}{y} (By \eand y {\neq} x) \eand Hx]
\end{equation*}

One of the interesting features of Russell's theory is that `the baby is not hungry' is not the negation of `the baby is hungry'. Instead, the negation applies only to the hunger predication in the last conjunct:

\begin{equation*}
\qt{\exists}{x} [Bx \eand \enot \qt{\exists}{y} (By \eand y {\neq} x) \eand \enot Hx]
\end{equation*}

The reason Russell designed his theory this way was that he thought that both of these sentences equally implied that there is a baby. If there is no baby, then you'd be mistaken in saying either `the baby is hungry' or `the baby is not hungry'. Consequently, one can't be the negation of the other. As a treatment of the truth conditions of English sentences, Russell's theory is controversial. Some philosophers of language think that sentences that seem to presuppose the existence of something that isn't there aren't straightforwardly false, but are rather defective in some other way --- perhaps they fail to be meaningful at all, or perhaps they take on some truth value other than true or false. These matters are beyond our present scope. We will remain neutral on whether Russell's theory is an accurate treatment of English; it is relevant for us because it provides an interesting and useful case for translation of sentences into QL with identity.

The general statement of Russell's theory of definite descriptions is, if you have a sentence applying a predicate \script{P} to the referent of a definite description \script{D}, translate it thus: there is something \script{x} that is \script{D}, there is nothing other than \script{x} that is \script{D}, and \script{x} is \script{P}.


\section{Identity and trees}
\label{sec.identity.trees}

Because we have extended QL to include claims of identity, we also need to modify our tree system. Notice that if we do not do so, the system will not be complete. For example, the rules offered in Chapter \ref{ch.QLsoundcomplete} do not provide a way to demonstrate that $Fa, \enot Fb, a{=}b \models \bot$, even though those sentences are obviously inconsistent. Since each of those sentences are atoms or negated atoms in QL, there is nothing to resolve, and there is no contradiction to close the tree. We need to add new rules to deal with identity.

Here is an obvious one:

\factoidbox{If a branch contains an identity claim \script{a}{=}\script{b} and some sentence \metaA{}, then you may add \metaA{}\substitute{\script{a}}{\script{b}} or \metaA{}\substitute{\script{b}}{\script{a}} to the branch.}

Recall that `\metaA{}\substitute{\script{a}}{\script{b}}' just means the sentence you get by replacing every `\script{a}' in \metaA{} with `\script{b}'. With this rule, we can easily demonstrate that the set of sentences mentioned above closes:

\begin{prooftree}
{
to prove={\{Fa, \enot Fb, a{=}b\} \vdash{}\bot}
}
	[Fa
	[\enot Fb, grouped
	[a{=}b, grouped
		[Fb, just={1, 3 =}, close={2, 4}]
	]
	]
	]
\end{prooftree}

We will add this rule to our tree system. Notice that it is not a \emph{resolution} rule --- we do not put a check mark next to either sentence referenced. They may be used again.

Since our tree system is supposed to be \emph{complete}, we need to \emph{ensure} that the tree will close; it's not enough that we have a rule that allows that it might. So, as in the case of the general rules discussed in Chapter \ref{ch.QLTrees}, we will also add an additional requirement governing branch completion. What we need is to make sure that we've made enough identity substitutions to demonstrate everything that needs demonstrating. The way we'll do this is by requiring, for every identity claim in the branch, that, for at least one of its directions (left-to-right or right-to-left) the substitution has been performed in that direction on every atomic sentence or negated atomic sentence in the branch.

More precisely stated, an open branch is complete only if, for any identity claim $\script{a}{=}\script{b}$ in the branch, either, for any atomic sentence or negated atomic sentence \metaA{} containing \script{a} in the branch, \metaA{}\substitute{\script{a}}{\script{b}} is in the branch, or, for any atomic sentence or negated atomic sentence \metaA{} containing \script{b} in the branch, \metaA{}\substitute{\script{b}}{\script{a}} is in the branch.

So, adding this requirement to the definition of branch completion given on page \pageref{branchcompletion.defined}, we get:

\factoidbox{
A branch is \define{complete} if and only if either (i) it is closed, or (ii) all of the following conditions are met:

\begin{enumerate}
\item Every resolvable sentence in the branch has been resolved;
\item For every general quantified sentence \metaA{} and every name \script{a} in the branch, the \script{a} instance of \metaA{} is in the branch; and
\item For every identity claim $\script{a}{=}\script{b}$ in the branch, either:
	\begin{enumerate}
	\item for every atomic sentence or negated atomic sentence \metaA{} containing \script{a} in the branch, \metaA{}\substitute{\script{a}}{\script{b}} is in the branch, or 
	\item for every atomic sentence or negated atomic sentence \metaA{} containing \script{b} in the branch, \metaA{}\substitute{\script{b}}{\script{a}} is in the branch.
	\end{enumerate}
\end{enumerate}}

We must also add one more rule to our tree system. Previously we said that branches only close when they contain some sentence along with its negation. We add one more condition that suffices for branch closure. If any branch contains a sentence $\script{a}{\neq}\script{a}$, then that branch closes. In no model can something be non-identical with itself.

Adding this to the rule given on page \pageref{branchclosure.defined}:

\factoidbox{
A branch closes if and only if either (i) it contains some sentence \metaA{} along with its negation, \enot\metaA{}, or (ii) it contains, for some name \script{a}, the sentence $\script{a}{\neq}\script{a}$.
}

We need this rule, for example, to prove with a tree that $\qt{\forall}{x} \:  a{=}x$ is inconsistent with $\qt{\exists}{x} \:  x{\neq}a$:

\begin{prooftree}
{
to prove={\{\qt{\forall}{x} \: a{=}x, \qt{\exists}{x} \: x{\neq}a\} \vdash \bot}
}
	[\qt{\forall}{x} \:  a{=}x, subs={b}
	[\qt{\exists}{x} \:  x{\neq}a, grouped, checked=b
		[b {\neq} a, just=2 $\exists$
			[a{=}b, just=1 $\forall$
				[b{\neq}b, just={3, 4 {=}}, close=5
				]
			]
		]
	]
	]
\end{prooftree}

We must also take care, when constructing models from completed open branches, to respect identity claims. If for example the sentence $b{=}c$ appears in an open branch, we will not construct a model with two different objects, b and c --- instead, we'll just pick one of them as the object indicated, and assign both names to it. For example, consider this tree:

\begin{prooftree}
{}
	[\qt{\forall}{x} (Rax \eif x{=}b), subs={a, b, c}
	[\qt{\exists}{x} Rax, grouped, checked=c
		[Rac, just=2 $\exists$
			[Raa \eif a{=}b, just=1 $\forall$, checked
			[Rab \eif b{=}b, grouped, just=1 $\forall$, checked
			[Rac \eif c{=}b, grouped, just=1 $\forall$, checked
				[\enot Rac, just=6 \eif, close={3, 7}
				]
				[c{=}b
					[Rab, just={3, 7 {=}}
						[\enot Rab, just=5 \eif, close={8, 9}]
						[b{=}b
							[\enot Raa, just=4 \eif, open
							]
							[a{=}b
								[Rbb, just={8, 10 =}
									[Rbc, just={3, 10 =}, open
									]
								]
							]
						]
					]
				]
			]
			]
			]
		]
	]
	]
\end{prooftree}

We end up with two open branches. We only need one to demonstrate that the root is satisfiable, but it is useful practice to consider both. Let's begin with the shorter open branch to the left, that completes at line 10. Examining that branch, we see three names, $a$, $b$, and $c$, and three atomic sentences concerning the extension of $R$: $Rac$, $Rab$, and $\enot Raa$. Using our previous method for constructing models, we would have posited a three-object UD and related those objects via $R$ in the appropriate way. Now, however, we also have identity claims to consider. There are two identity claims in the branch. $b{=}b$ doesn't tell us anything interesting --- of \emph{course} that object is identical with itself --- but the presence of $c{=}b$ indicates that our model will not include separate objects b and c. We'll only posit one object in the UD for those two names, and another object for $a$. We can pick either letter for the object; let's call it $b$. (Remember, it doesn't matter what kinds of objects we pick for the UD; it could be Reed Richards for all it matters. We typically pick letters because they are easy to keep track of.)

So the model suggested by the first open branch here is:

\begin{partialmodel}
	UD & \{a, b\}\\
	\referent{a} & a\\
	\referent{b} & b\\
	\referent{c} & b\\
	\extension{R} & 
	\begin{tabular}{l|lllll}
	$Rxy$   & $a$ & $b$ \\ \hline
	$a$   & 0 & 1   \\
	$b$   & - & - \\
	\end{tabular}
\end{partialmodel}

The longer open branch includes additional identity claims. It includes $a{=}b$ and $c{=}b$, which of course implies that all three of these names are names for the same object. So the UD for the model corresponding to the right branch will have only one object, which all three names denote.

\begin{partialmodel}
	UD & \{a\}\\
	\referent{a} & a\\
	\referent{b} & a\\
	\referent{c} & a\\
	\extension{R} & 
	\begin{tabular}{l|lll}
	$Rxy$   & $a$  \\ \hline
	$a$   & 1    \\
	\end{tabular}
\end{partialmodel}

It it sometimes helpful, for an intuitive grip on what is going on in these trees, to think about an English translation alongside the formalisms. For example, suppose that $Rxy$ is interpreted as `$x$ loves $y$'. Line 1 of the tree says that person $a$ loves at most one person; line 2 says that $a$ loves at least one person. The tree works out two ways that might be: the one and only person $a$ loves could be $a$, or it could be someone else.




\iffalse

\practiceproblems

\solutions
\problempart
\label{pr.QL-ID-spies}
Using the symbolization key given, translate each English-language sentence into QL with identity. For sentences containing definite descriptions, assume Russell's theory.
\begin{ekey}
\item[UD:] people
\item[Kx:] $x$ knows the combination to the safe.
\item[Sx:] $x$ is a spy.
\item[Vx:] $x$ is a vegetarian.
\item[Txy:] $x$ trusts $y$.
\item[h:] Hofthor
\item[i:] Ingmar
\end{ekey}
\begin{earg}
\item Hofthor is a spy, but no vegetarian is a spy.
\item No one knows the combination to the safe unless Ingmar does.
\item No spy knows the combination to the safe.
\item Neither Hofthor nor Ingmar is a vegetarian.
\item Hofthor trusts a vegetarian.
\item Everyone who trusts Ingmar trusts a vegetarian.
\item Everyone who trusts Ingmar trusts someone who trusts a vegetarian.
\item Only Ingmar knows the combination to the safe.
\item Ingmar trusts Hofthor, but no one else.
\item The person who knows the combination to the safe is a vegetarian.
\item The person who knows the combination to the safe is not a spy.
\end{earg}

\solutions
\problempart
\label{pr.QL-ID-cards}
Using the symbolization key given, translate each English-language sentence into QL with identity. For sentences containing definite descriptions, assume Russell's theory.
\begin{ekey}
\item[UD:] cards in a standard deck
\item[Bx:] $x$ is black.
\item[Cx:] $x$ is a club.
\item[Dx:] $x$ is a deuce.
\item[Jx:] $x$ is a jack.
\item[Mx:] $x$ is a man with an axe.
\item[Ox:] $x$ is one-eyed.
\item[Wx:] $x$ is wild.
\end{ekey}
\begin{earg}
\item All clubs are black cards.
\item There are no wild cards.
\item There are at least two clubs.
\item There is more than one one-eyed jack.
\item There are at most two one-eyed jacks.
\item There are exactly two black jacks.
\item There are exactly four deuces.
\item The deuce of clubs is a black card.
\item One-eyed jacks and the man with the axe are wild.
\item If the deuce of clubs is wild, then there is exactly one wild card.
\item The man with the axe is not a jack.
\item The deuce of clubs is not the man with the axe.
\end{earg}

\solutions
\problempart
\label{pr.QLbuffy}
Using the symbolization key given, translate each English-language sentence into QL with identity.
\begin{ekey}
\item[UD:] people, generations, and monsters
\item[Gx:] $x$ is a generation.
\item[Hx:] $x$ is human.
\item[Sx:] $x$ is a slayer.
\item[Vx:] $x$ is a vampire.
\item[Dx:] $x$ is a demon.
\item[Wx:] $x$ is a werewolf.
\item[Fx:] $x$ is a force of darkness.
\item[Axy:] $x$ will stand against $y$.
\item[Bxy:] $x$ is born in generation $y$.
\item[Kxy:] $x$ will kick $y$.
\item[b:] Buffy
\item[f:] Faith
\item[w:] Willow
\end{ekey}
\begin{earg}
\item Buffy and Willow were born unto the same generation.
\item There is no more than one slayer born in each generation.
\item A slayer other than Buffy is one of the forces of darkness.
\item Willow will stand against any force of darkness other than a werewolf.
\item Faith will kick everyone except herself.
\item Buffy will kick anyone who stands against a slayer, unless they are also kicking vampires or demons.
\item In every generation a slayer is born.
\item In every generation a slayer is born. She will stand against the vampires, demons, and forces of darkness.
\item In every generation a slayer is born. She alone will stand against the vampires, demons, and forces of darkness.
\end{earg}



\problempart Using the symbolization key given, translate each English-language sentence into QL with identity. For sentences containing definite descriptions, assume Russell's theory.
\begin{ekey}
\item[UD:] animals in the world
\item[Bx:] $x$ is in Farmer Brown's field.
\item[Hx:] $x$ is a horse.
\item[Px:] $x$ is a Pegasus.
\item[Wx:] $x$ has wings.
\end{ekey}
\begin{earg}
\item There are at least three horses in the world.
\item There are at least three animals in the world.
\item There is more than one horse in Farmer Brown's field.
\item There are three horses in Farmer Brown's field.
\item There is a single winged creature in Farmer Brown's field; any other creatures in the field must be wingless.
\item The Pegasus is a winged horse.
\item The animal in Farmer Brown's field is not a horse.
\item The horse in Farmer Brown's field does not have wings.
\end{earg}

\solutions
\problempart Demonstrate each of the following, either by constructing a model, or by explaining why it's impossible to do so. If you wish, you can draw a tree to help you answer these questions; however, it is good conceptual practice to tackle some of these questions directly by thinking about just what you'd need to put in your model.
\label{pr.IdentityModels}
\begin{earg}
\item Show that $\{{\enot}Raa, \qt{\forall}{x} (x{=}a \eor Rxa)\}$
is consistent.
%There are many possible answers. Here is one:
%\begin{partialmodel}
%UD & \{Harry, Sally\}\\
%\extension{R} &\{\ntuple{Sally, Harry}\}\\
%\referent{a} & Harry
%\end{partialmodel}
\item\ Show that $\{\qt{\forall}{x}\qt{\forall}{y}\qt{\forall}{z}(x{=}y \eor y{=}z \eor x{=}z),
\qt{\exists}{x}\qt{\exists}{y}\ x{\neq} y\}$ is consistent.
%There are no predicates or constants, so we only need to give a UD.
%Any UD with 2 members will do.
\item\ Show that $\{\qt{\forall}{x}\qt{\forall}{y}\ x{=}y, \qt{\exists}{x}\ x {\neq} a\}$ is inconsistent.
%We need to show that it is impossible to construct a model in which these are both true. Suppose $\qt{\exists}{x}\ x {\neq} a\$ is true in a model. There is something in the universe of discourse that is \emph{not} the referent of $a$. So there are at least two things in the universe of discourse: \referent{a} and this other thing. Call this other thing \metaB{}--- we know $a {\neq} \metaB{}$. But if $a {\neq} \metaB{}$, then $\qt{\forall}{x}\qt{\forall}{y}\ x=y$ is false. So the first sentence must be false if the second sentence is true is true. As such, there is no model in which they are both true. Therefore, they are inconsistent.
\item Show that $\qt{\exists}{x} (x {=} h \eand x {=} i)$ is contingent.
\item Show that \{$\qt{\exists}{x}\qt{\exists}{y}(Zx \eand Zy \eand x{=}y)$, $\enot Zd$, $d{=}s$\} is consistent.
\item Show that `$\qt{\forall}{x}(Dx \eif \qt{\exists}{y} Tyx)$ \therefore\ $\qt{\exists}{y} \qt{\exists}{z}\ y{\neq} z$' is invalid.
\end{earg}

\solutions
\problempart Construct a tree to test the following entailment claims. If they are false, provide a model that demonstrates this.
\label{pr.IdentityTrees}
\begin{earg}
\item\  $\models \qt{\forall}{x} \qt{\forall}{y} (x{=}y \eif y{=}x)$
\item\ $\models \qt{\forall}{x} \qt{\exists}{y} \: x{=}y$
\item\  $\models \qt{\exists}{x} \qt{\forall}{y} \: x{=}y$
\item   $\qt{\exists}{x} \qt{\forall}{y} \: x{=}y \models \qt{\forall}{x} \qt{\forall}{y} (Rxy \eiff Ryx)$
\item   $\models \enot \qt{\forall}{x} \qt{\forall}{y} \qt{\forall}{z} [(Axy \eand Azx \eand y{=}z) \eif Axx] $
\item  $\qt{\forall}{x} \qt{\forall}{y} \: x{=}y \models \qt{\exists}{x} Fx \eiff \qt{\forall}{x} Fx$
\item $\qt{\forall}{x} (x{=}a \eor x{=}b), Ga \eiff \enot Gb \models \enot \qt{\exists}{x} \qt{\exists}{y} \qt{\exists}{z} (Gx \eand Gy \eand \enot Gz)$
\item $\qt{\forall}{x} (Fx \eif x{=}f), \qt{\exists}{x} (Fx \eor \qt{\forall}{y} \: y{=}x) \models Ff$
\item $\qt{\exists}{x} \qt{\exists}{y} Dxy \models \qt{\forall}{x_{1}} \! \qt{\forall}{x_{2}}\! \qt{\forall}{x_{3}}\! \qt{\forall}{x_{4}}\! [(Dx_{1}x_{2} \eand Dx_{3}x_{4}) \eif (x_{2}{\neq}x_{3} \eor Dx_{1}x_{4})]$
\end{earg}

\problempart In \S \ref{sec.quantity} we looked at two different translations of `Mozart wrote exactly two operas'. Use trees to prove that they are equivalent.

\problempart Translate these arguments into QL with identity, and evaluate them for validity with a tree. (Don't be surprised or discouraged if some of these trees end up very complex.)
\label{pr.IdentityArguments}
\begin{earg}
\item Dudley will threaten anyone who threatens anyone. Therefore, Dudley will threaten himself.
\item The exam is easy. Therefore every exam Sheila took was easy. (Use Russell's theory of definite descriptions.)
\item Three wise men visited Jesus. Every wise man who visited Jesus gave Jesus a gift. Therefore, Jesus received more than one gift.
\item Worf is the only Klingon in Starfleet. Everyone in Starfleet is brave. All brave Klingons are warriors. Therefore, there is at least one brave warrior in Starfleet.
\item Worf is the only Klingon in Starfleet. Everyone in Starfleet is brave. All brave Klingons are warriors. Therefore, there is exactly one brave warrior in Starfleet.
\item Every person likes every kind of sandwich that is tasty. Jack is a person. Jack likes exactly one kind of sandwich. Therefore, no more than one kind of sandwich is tasty.
\end{earg}


\fi 
