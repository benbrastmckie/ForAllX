%!TEX root = ../forallx-mit.tex
\chapter{Natural Deduction in $\FI$}
\label{ch.FOL-deduction}


% Trees employ a kind of `brute force' strategy for proving entailment claims.
% When the logical structure of the relevant sentences is rather simple, as it is in PL and in some FOL$^=$ cases, it can be an effective strategy.
% But in other cases, trees become tedious and complex.
% It is useful to have a proof system that allows one to reason in a more targeted way --- especially if you already have an intuitive understanding of why a given argument should be expected to turn out valid.

This chapter extends our system PL to provide a natural deduction system for $\FI$ which we will refer to as FOL$^=$.
% Like our natural deduction system for PL, our system can only be used to demonstrate that an argument \emph{is} valid since natural deduction systems do not demonstrate that an argument is \emph{invalid}.
% In this respect natural deduction differs from trees.
As we will show in later chapters, FOL$^=$ is both sound and complete with respect to the semantics for $\FI$.
That means that there are natural deduction proofs corresponding to all and only the logical consequences in $\FI$.

Our proof system FOL$^=$ will include the same introduction and elimination rules that we provided for the sentential operators included in PL, but now we will add introduction and elimination rules for the quantifiers and identity, deriving a number of new rules.



\section{Substitution Instances}

%to reformat the substitution instances, see the commands \unisub and \freesub in the style file. 

Consider the following claims:

\begin{earg} \label{strength}
  \eitem{Kin loves everything.}
  \eitem{Kin loves Cassandra.}
  \eitem{Kin loves something.}
\end{earg}

Sentence \eref{strength}{2} is referred to as an \textit{instance} of both \eref{strength}{1} and \eref{strength}{3}. % since it is about something particular.
Whereas \eref{strength}{1} makes a universal claim about everything and \eref{strength}{3} makes an existential claim about something, \eref{strength}{2} makes a claim about two things in particular.
It is important to distinguish between all three types of sentences, where one preliminary way to do this is to appeal to their logical strength, i.e., which sentences are a logical consequence which.
Specifically, \eref{strength}{2} is a logical consequence of \eref{strength}{1} but not \textit{vice versa}, and \eref{strength}{3} is a logical consequence of \eref{strength}{2} but not \textit{vice versa}.
Similarly, \eref{strength}{3} is a logical consequence of \eref{strength}{1} but not \textit{vice versa}.
It is worth nothing that certain existential claims may fail to be logical consequences of universal claims if we had permitted models to have an empty domain since given an empty domain. %, \eref{strength}{1} could be true while \eref{strength}{3} is false.
We will contemplate this shortly.

% We will refer to sentence \ref{I2} as an \define{instance} of sentence \ref{I1}, and refer to \ref{I3} as an \define{existential generalization} of \ref{I2}.

We may regiment the sentences above with the following symbolization key:

\begin{multicols}{2}
  \begin{ekey}
    \item[Lxy:] $x$ loves $y$ 
    \item[k:] Kin
    \item[c:] Cassandra
  \end{ekey}

  \columnbreak

  \begin{earg} \label{KCstrength}
    \eitem{$\forall xLkx$.}
    \eitem{$Lkc$.}
    \eitem{$\exists xLkx$.}
  \end{earg}
\end{multicols}

Given that \eref{KCstrength}{2} is a logical consequence of \eref{KCstrength}{1} and that \eref{KCstrength}{3} is a logical consequence of \eref{KCstrength}{2}, we should expect a complete logic for $\FI$ to include rules by which to derive \eref{KCstrength}{3} from \eref{KCstrength}{2}, and to derive \eref{KCstrength}{2} from \eref{KCstrength}{1}. 
In order to state these rules in a sufficiently general way we will need to make use of the notion of substitution from before.
In particular, recall the following definition from $\S\ref{sec:Quantities}$ where $\alpha$ and $\beta$ are any singular terms of $\FI$:

\factoidbox{
  $\beta$ is \define{free for} $\alpha$ in $\metaA$ just in case there is no free occurrence of $\alpha$ in $\metaA$ in the scope of a quantifier that binds $\beta$.
}

Roughly speaking, $\beta$ is free for $\alpha$ just in case $\beta$ can replace $\alpha$ without resulting in any extra binding.
Whereas $z$ is free for $x$ in $\qt{\forall}{y}(Fxy \eif Fyx)$ since replacing $x$ with $z$ would yield $\qt{\forall}{y}(Fzy \eif Fyz)$, the variable $y$ is not free for $x$ in $\qt{\forall}{y}(Fxy \eif Fyx)$ since replacing $x$ with $y$ yields $\qt{\forall}{y}(Fyy \eif Fyy)$ where the quantifier $\forall y$ ends up binding an extra variable.

If $\beta$ is a constant, it follows that $\beta$ is free for any $\alpha$ in any wff $\metaA$. 
Given this definition, we may define substitution as in $\S\ref{sec:Quantities}$, where $\alpha$ and $\beta$ are any singular terms of the language.

\factoidbox{
   If $\beta$ is free for $\alpha$ in $\metaA$, then the \define{substitution} $\metaA\unisub{\beta}{\alpha}$ is the result of replacing all free occurrences of $\alpha$ in $\metaA$ with $\beta$. 
}

We may take $\metaA\unisub{\beta}{\alpha}$ to read: $\beta$ for $\alpha$ in $\metaA$.
For instance, $\qt{\forall}{y}(Fxy \eif Fyx)\unisub{z}{x}$ is the wff $\qt{\forall}{y}(Fzy \eif Fyz)$ and $\qt{\forall}{y}(Fxy \eif Fyx)\unisub{y}{x}$ is undefined since $y$ is not free for $x$.
We may also observe that $\qt{\forall}{y}(Fxy \eif Fyx)\unisub{y}{z}$ and $\qt{\forall}{y}(Fxy \eif Fyx)\unisub{z}{y}$ are both $\qt{\forall}{y}(Fxy \eif Fxy)$.

This new vocabulary permits us to define the substitution instances of both universal and existential generalizations of the form $\qt{\forall}{\alpha}\metaA$ and $\qt{\exists}{\alpha}\metaA$.
In particular, consider the following:

\factoidbox{
  $\metaA\unisub{\beta}{\alpha}$ is a \define{substitution instance} of $\qt{\forall}{\alpha}\metaA$ and $\qt{\exists}{\alpha}\metaA$ if $\beta$ is a constant. 
}

Since $\beta$ is a constant, the requirement that $\beta$ is free for $\alpha$ in $\metaA$ is satisfied.
In particular, $(Fxy \eif Fyx)\unisub{c}{y} = (Fxc \eif Fcx)$ is a substitution instance of $\qt{\forall}{y}(Fxy \eif Fyx)$ where this is the result of stripping off the quantifier binding $y$ and replacing all free occurrences of $y$ with $c$. 
Nothing forced us to choose the constant $c$.
Instead, we could have used $d$, producing the instance $(Fxd \eif Fdx)$ where we may then drop outermost parentheses as usual.
In general, there will be a different instance for every constant in the language.
For contrast, the instances of $\qt{\forall}{y}(Fxy \eif \qt{\exists}{y}Fyx)$ include such wffs as $Fxc \eif \qt{\exists}{y}Fyx$ and $Fxd \eif \qt{\exists}{y}Fyx$ where in both cases the second occurrence of $y$ is not replaced since it is not free. 
It will often be convenient to refer to the constants here as \define{instantiating constants}.




\section{Universal Elimination}
  \label{sec:UniElim}

Recall $\qt{\forall}{x} Lkx$ from before.
We claimed that $Lkc$ is a logical consequence of $\qt{\forall}{x} Lkx$.
We are now in a position to state this a little more precisely.
To begin with, we may observe that $Lkc$ is a substitution instance of $\qt{\forall}{x} Lkx$ with instantiating constant $c$.
More generally, universally quantified claims entail all of their substitution instances.
In order to maintain completeness, we may include the following elimination rule ($\forall$E) so that the substitution instances of a universally quantified claim can be derived from that universally quantified claim:

\begin{proof}
	\have[m]{a}{\qt{\forall}{\alpha}\metaA}
	\have[ ]{c}{\metaA\unisub{\beta}{\alpha}} \by{$\forall$E ~~($\beta$ is a constant)}{a} 
\end{proof}

Remember that the notation for a substitution instance is not a part of $\FI$, so you cannot write it directly in a proof.
Instead, you write the substitution instance itself including whichever constant $\beta$ is being used to replace the variable $\alpha$ as in this example:

\begin{proof}
	\hypo{a}{\qt{\forall}{x}(Mx \eif Rxd)} \pr{}
	\have{c}{Ma \eif Rad} \Ae{a}
	\have{d}{Md \eif Rdd} \Ae{a}
\end{proof}

%This rule is very similar to the tree rule for universals, which, in our tree system, allowed one to develop a branch containing a universal with any instance of it one likes. 
You are permitted to write down any instance you like on a new line. In this example, we have used the rule twice to produce two instances. In the first case, we instantiate with the constant $a$ and we instantiate with the constant $d$ in the second case. 

Before moving on, it is worth noting that this rule is both easy and natural.
It is easy insofar as there are no extra conditions that have to be satisfied in order to apply the rule, and it is natural insofar as we reason this way all the time.
These same virtues will not be shared by all of the quantifier rules that we will introduce, and so it is worth noting which rules are easier to remember and apply than others.
In particular, universal introduction is a much trickier rule to state and apply.
Before moving on to consider this case, we will continue with existential introduction which is another easy rule that is natural to apply.





\section{Existential Introduction}
  \label{sec:ExistIntro}

Recall that $Lkc$ was said to be a logical consequence of $\qt{\exists}{x} Lkx$.
Given that Kin loves Cassandra, it follows that Kin loves someone.
More generally, any existentially quantified claim is a logical consequence of its substitution instances.
In order to preserve completeness, we may include the following existential introduction rule ($\exists$I) in our proof system:

\begin{proof}
  \have[m]{a}{\metaA\unisub{\beta}{\alpha}} \by{($\beta$ is a constant and $\alpha$ is a variable)}{}  
	\have[\ ]{c}{\qt{\exists}{\alpha}\metaA} \Ei{a}  
\end{proof}

In the example above, $\metaA\unisub{\beta}{\alpha}=Lkx\unisub{c}{x}=Lkc$.
Given $\exists$I, we may derive $\qt{\exists}{\alpha}\metaA=\exists xLkx$ by existentially generalizing on the instantiating constant $c$.
Alternatively, we could have existentially generalized on $k$, deriving $\exists xLxc$ given that $\metaA\unisub{\beta}{\alpha}=Lxc\unisub{k}{x}=Lkc$. 
Both $Lkx\unisub{c}{x}$ and $Lxc\unisub{k}{x}$ are identical to $Lkc$. 
Similarly, in addition to deriving $\qt{\exists}{x}Lkx$ and $\qt{\exists}{x}Lxc$ from $Lkc$, we can also use the variable $y$ to derive $\qt{\exists}{y}Lky$ and $\qt{\exists}{y}Lyc$ since $Lkc$ is also identical to $Lky\unisub{c}{y}$ and $Lyc\unisub{k}{y}$.
Something similar may be said for other variables.

The example above only included one occurrence of each constant.
By contrast, the sentence $Ma \eif Rad$ has two occurrences of the constant $a$.
As a result, we may existentially generalize on either occurrence of $a$ by itself, both occurrences together, or neither.
Consider:

\begin{proof}
	\hypo{a}{Ma \eif Rad} \pr{}
	\have{d}{\qt{\exists}{x}(Mx \eif Rad)} \Ei{a}
	\have{b}{\qt{\exists}{x}(Ma \eif Rxd)} \Ei{a}
	\have{c}{\qt{\exists}{x}(Mx \eif Rxd)} \Ei{a}
	\have{k}{\qt{\exists}{x}(Ma \eif Rad)} \Ei{a}
	\have{e}{\qt{\exists}{y}\qt{\exists}{x}(Mx \eif Ryd)} \Ei{d}
	\have{f}{\qt{\exists}{z}\qt{\exists}{y}\qt{\exists}{x}(Mx \eif Ryz)} \Ei{e}
\end{proof}

Whereas line $2$ existentially generalizes on the first occurrence of the constant $a$, line $3$ generalizes on the second occurrence, and line $4$ generalizes on both. 
Focusing on line $2$, $\metaA\unisub{\beta}{\alpha}=(Mx \eif Rad)\unisub{a}{x}=(Ma \eif Rad)$, where similar identities hold for the other lines.
For line $4$ we have $\metaA\unisub{\beta}{\alpha}=(Mx \eif Rxd)\unisub{a}{x}=(Ma \eif Rad)$, and for line $5$ we have $\metaA\unisub{\beta}{\alpha}=(Ma \eif Rad)\unisub{a}{x}=(Ma \eif Rad)$.
In lines $6$ and $7$, one existential generalization is staged after the next, generalizing on difference occurrences of the same constant. 

Put roughly, existential generalization permits one to replace any number of occurrences of a constant with a variable that is then bound by an existential quantifier.
Strictly speaking, this approximation is not correct since we cannot generalize as follows:

\begin{proof}
	\hypo{a}{\qt{\exists}{x}(Mx \eif Rad)} \pr{}
  \have{e}{\qt{\exists}{x}\qt{\exists}{x}(Mx \eif Rxd)} \by{$\exists$I (\textsc{incorrect})}{a}
	\have{c}{\qt{\exists}{y}\qt{\exists}{x}(Mx \eif Ryd)} \Ei{d}
\end{proof}

Whereas line $3$ is the same as line $6$ above and perfectly correct, line $2$ does not follow by existential generalization.
The reason is that we cannot construct an appropriate $\metaA\unisub{\beta}{\alpha}$.
For instance, we cannot take $\metaA\unisub{\beta}{\alpha}=\qt{\exists}{x}(Mx \eif Rxd)\unisub{a}{x}$ given the scope of the quantifier since $\qt{\exists}{x}(Mx \eif Rxd)\unisub{a}{x}$ is not identical to the premise $\qt{\exists}{x}(Mx \eif Rad)$.
By contrast, $\metaA\unisub{\beta}{\alpha}=\qt{\exists}{x}(Mx \eif Ryd)\unisub{a}{y}$ is acceptable since $\qt{\exists}{x}(Mx \eif Ryd)\unisub{a}{y}=\qt{\exists}{x}(Mx \eif Rad)$ which is identical to the premise.
Thus we may derive $\exists y\qt{\exists}{x}(Mx \eif Ryd)$ on line $3$ by $\exists$I.

Whereas replacing $a$ with $x$ results in a quantifier which is already present and so picks up an extra bound variable, this does not happen if we replace $a$ with $y$ instead. 
The existential generalization rule is stated in such a way so as to ensure that this extra binding cannot occur without breaking the rule.
Nevertheless, it is important to be careful to accurately follow the rule for existentially generalizing.
An easy way to see if you are following the rule correctly is to check to see if you pick up any extra variable binding.




\section{Universal Introduction}
  \label{sec:UniIntro}

The rules provided above allow us to derive \eref{KCstrength}{2} from \eref{KCstrength}{1} and to derive \eref{KCstrength}{3} from \eref{KCstrength}{2}.
As we noted above, the converse derivations do not hold.
After all, just because Kin loves Cassandra (\eref{KCstrength}{2}), it does not follow that Kin loves everything (\eref{KCstrength}{1}).
Similarly, just because Kin loves something (\eref{KCstrength}{3}), it does not follow that Kin loves Cassandra (\eref{KCstrength}{2}).
More generally, universal claims are not logical consequences of their substitution instances, not do particular substitution instances of an existential claim follow as logical consequences.
Nevertheless, it is possible derive universal claims from their instances in specific circumstances and it is possible to make use of certain instances of existential claims to derive further claims.
The following two section will introduce these derivation rules, discussing the conditions of their application.
Whereas universal elimination was easy and existential introduction was only slightly trickier, these cases are much more constrained.

One way to think about a universal claim of the form $\qt{\forall}{\alpha}\metaA\alpha$ is as a long conjunction $\metaA\unisub{a}{\alpha} \eand \metaA\unisub{b}{\alpha} \eand\ldots$ where the constants $a,b,\ldots$ name every element in the domain.
However, this way of thinking is limited since we may not have enough constants to name every element in the domain, and even if there were enough constants to go around, they could all be interpreted as referring to the same element of the domain.
These considerations are what motivated the introduction of variable assignments which we used to provide the semantics for the quantifiers.
In particular, $\VV{\I}{\va{a}}(\qt{\forall}{\alpha}\metaA)=1$ just in case $\VV{\I}{\va{c}}(\metaA)=1$ for every $\alpha$-variant $\va{c}$ of $\va{a}$, and $\VV{\I}{\va{a}}(\qt{\exists}{\alpha}\metaA)=1$ just in case $\VV{\I}{\va{c}}(\metaA)=1$ for some $\alpha$-variant $\va{c}$ of $\va{a}$.
We may simulate something analogous in the proof system for $\FI$ by way of arbitrary constants.

The following examples will help to illustrate what it is for a constant to be arbitrary:
% Consider the following sentences:

\begin{earg} \label{arb}
  \eitem{$\qt{\forall}{x} Mx$.}
  \eitem{$\qt{\forall}{y} My$.}
\end{earg}

These sentences entail each other for indeed they say the very same thing, i.e., that everything is $M$.
Insofar as the logical equivalence of these two sentences are to be reflected in the proof system, we need a way to derive sentence \eref{arb}{2} from sentence \eref{arb}{1} and \textit{vice versa}.

Consider the following derivation:

\begin{proof}
	\hypo{x}{\qt{\forall}{x} Mx} \pr{}
	\have{a}{Ma} \Ae{x}
	\have{y}{\qt{\forall}{y} My} \Ai{a}
\end{proof}

In line $2$, we have derived $Ma$ from $\qt{\forall}{x}Mx$ by $\forall$E given above.
We could have equally derived $M\alpha$ for any other constant $\alpha$.
This much should come as no surprise.
What is more surprising is the derivation of $\qt{\forall}{y}My$ in line $3$ from $Ma$ in line $2$.
After all, this is like the inference from `Alan is mad' to `Everyone is mad' which is easy to invalidate.
You might wonder what kind of constraints would make this inference count as logically valid.

The key idea behind the inference from line $2$ to line $3$ is that $a$ is an \textit{arbitrary} constant. 
In particular, $a$ does not occur in the premise, nor does $a$ occur in line $3$ which we are deriving, and so there are no constraints on what $a$ might name. 
Rather, the constant $a$ could name anything whatsoever. 
You can think of $a$ as analogous to $\va{c}(x)$ for an arbitrary $x$-variant $\va{c}$ by which we generalized over the elements in the domain to which $x$ may refer.
Given that $a$ could refer to anything, we may derive line $3$.
Although we used the variable $y$ in line $3$, we could have used $x$, or indeed any other variable since there is no threat of any extra variable binding taking place.
More generally, the universal introduction rule ($\forall$I) is stated as follows:

\begin{proof}
  \have[m]{a}{\metaA\unisub{\beta}{\alpha}} \by{($\beta$ is a constant and $\alpha$ is a variable)}{}  
  \have[n]{c}{\qt{\forall}{\alpha}\metaA} \by{$\forall$I ~~($\beta$ does not occur in $n$ or a premise or undischarged assumption)}{a}
\end{proof}

It is easy to see that the inference from line $2$ to line $3$ in the proof given above follows this rule.
For contrast, consider the following incorrect application:

\begin{proof}
	\hypo{a}{\qt{\forall}{x} Rax} \pr{}
	\have{b}{Raa} \Ae{a}
  \have{c}{\qt{\forall}{y} Ryy} \by{$\forall$I (\textsc{incorrect})}{b}
\end{proof}

Intuitively, this argument would be like inferring the conclusion that everything respects itself from the premise that Arthur respects everything.
Even if it follows from the premise that Arthur respects himself, it does not follow that everything respects itself.
% The derivation above goes wrong in that the constant $a$ occurs in the premise which is an assumption that we never discharge. 
The reason the derivation goes astray is that $a$ is not an arbitrary constant since it occurs in the premise which is an undischarged assumption.
In particular, we might take $a$ to name Arthur.
Even if $a$ named something else, it's interpretation would still be constrained in any interpretation in which the premise is true.
% Although $Raa$ may hold, the same cannot be said for $Rbb$ and so on for any arbitrary constant $b$ that does not occur in any undischarged assumption since then there would not be any constraint on what $b$ might name in an interpretation that makes the premises true. 
As a result, the constant $a$ is not arbitrary in way that we need it to be if we are to universally generalize on $a$ with the rule $\forall$I. 

We have just seen one way that $\forall$I can go wrong by offending the constraint that the instantiating constant not occur in a premise, where something similar may be said for undischarged assumptions.
What about the other constraint?
Consider the following:

\begin{proof}
	\hypo{a}{\qt{\forall}{x} Rxx} \pr{}
	\have{b}{Raa} \Ae{a}
  \have{c}{\qt{\forall}{x} Rax} \by{$\forall$I (\textsc{incorrect})}{b}
\end{proof}

This argument infers that Arthur respects everything from the premise that everything respects itself.
Letting $\metaA\unisub{\beta}{\alpha}=Rax\unisub{a}{x}=Raa$, we may observe that $\qt{\forall}{x}\metaA=\qt{\forall}{x}Rax$, and so one might have thought that we could derive $\qt{\forall}{x}Rax$ from $Raa$.
This would have been correct but for the provision that $\beta$ not occur in $\qt{\forall}{\alpha}\metaA$.
In the case above, this requires that $a$ not occur in $\qt{\forall}{x}Rax$.
Since $a$ does occur in $\qt{\forall}{x}Rax$, line $3$ does not follow from line $2$.

A good way to remember the restrictions on the $\forall$I rule is to remember that these restriction are put in place to require the instantiating constant to be arbitrary.
In particular, we want the instantiating constant that we are generalizing on to be anything, and so it cannot occur in a premise, undischarged assumptions, or in the sentence that we are deriving.
The incorrect inferences above are paradigmatic of cases in which these requirements are not satisfied.

Although the constant $\alpha$ is not permitted to occur in any undischarged assumption, it may occur in an assumption of a subproof that we have already closed.
For example, here is a perfectly respectable proof of $\qt{\forall}{z}(Dz \eif Dz)$ from no premises.

\begin{proof}
	\open
		\hypo{f1}{Df} \as{}
		\have{f2}{Df \eor Ff} \oi{f1}
	\close
	\have{ff}{Df \eif (Df \eor Ff)}\ci{f1-f2}
	\have{zz}{\qt{\forall}{z}(Dz \eif (Dz \eor Fz))}\Ai{ff}
\end{proof}

Reasoning of the kind given above is as common as it is important: if we can show that an arbitrary differentiable function is either differentiable or smooth, it follows that any differentiable function is either differentiable or smooth.
Since the assumption given in line $1$ above has been discharged, the instantiating constant $f$ does not occur in any undischarged assumptions, and so line $4$ follows from line $3$ by $\forall$I without offending any restrictions. 



\section{Existential Elimination}
  \label{sec:ExistElim}

A sentence with an existential quantifier tells us that \textit{something} satisfies a given condition.
For example, letting `$S$' regiment `is sad' and `$M$' regiment `is mad', the existential claims $\qt{\exists}{x} Sx$ and $\qt{\exists}{y} My$ say that something is sad and that something is mad but they don't tell us \textit{what} is sad or mad.
In particular, we cannot conclude that the same thing is sad and mad.
This worry can be brought out with the following incorrect derivation:

\begin{proof}
  \hypo{b}{\qt{\exists}{x} Sx} \pr{}
	\hypo{a}{\qt{\exists}{y} My} \pr{}
  \have{d}{Sa} \by{$\exists$I (\textsc{incorrect})}{b} 
  \have{c}{Ma} \by{$\exists$I (\textsc{incorrect})}{a}
  \have{e}{Sa \eand Ma} \ai{c,d}
  \have{f}{\qt{\exists}{z}(Sz \eand Mz)} \Ei{e}
\end{proof}

Whereas $a$ is a perfectly arbitrary constant when it is introduced in line $3$, reusing $a$ in line $4$ leads to the conclusion that the same thing is both sad and mad.
Were we permitted to introduce lines $3$ and $4$ in this way, nothing would stop us from conjoining these claims and existentially generalizing, concluding that something is both sad and mad even though this might not be the case.
For instance, one thing could be sad and something else could be mad where nothing requires these to be the same thing. 
Somehow we must prevent these two existential claims from running together as they do above.

Although it is important to avoid concluding too much, this does not mean that we cannot draw any inferences at all from an existential claim.
For instance, suppose that we knew that $\qt{\exists}{x} Sx$ and $\qt{\forall}{x}(Sx \eif Mx)$, or in English, something is sad and, moreover, everything that is sad is also mad.
It is natural to reason in the following way:

\begin{quote}
  \texttt{Bob:} By assumption, something is sad.
  Although we do not know what that thing is, call it `Bob' for the purposes of this argument.
  We also know by assumption that everything that is sad is mad.
  In particular, if Bob is sad, then Bob is mad.
  Thus Bob is mad.
  Since `Bob' was a name we introduced only for the sake of the argument, we may revert to the more general claim that something is mad.
\end{quote}

Especially for long lines of reasoning, it is often useful to introduce a temporary constant in the manner employed above.
In particular, we want the constant to be arbitrary, and so it cannot occur in any undischarged assumptions.
At the same time, we also need to keep track of this constant, being careful not to make any other assumptions about the object to which this temporary constant refers, or to draw any conclusions which include this constant.
% It will be convenient to refer to an arbitrary constant that is used to temporarily refer to whatever it is that satisfies an existential claim as a \define{proxy}.
% Accordingly, our use of a proxy must be restricted to a subproof, where it is in this sense arbitrary and temporary.
The existential elimination rule ($\exists$E) will achieve all of this by way of a subproof:

\begin{proof}
	\have[m]{a}{\qt{\exists}{\alpha}\metaA}
	\open	
    \hypo[n]{b}{\metaA\unisub{\beta}{\alpha}} \as{\strut\hspace{.07in}(where $\beta$ is a constant and does not occur in}
    \have[ ]{x}{\vdots} \by{\raisebox{5pt}{\strut\hspace{.4in}$m$, $p$, or any undischarged assumptions)}}{}
		\have[p]{c}{\metaB}
	\close
	\have[\ ]{d}{\metaB{}} \Ee{a,b-c}
\end{proof}

Note that existential elimination cites both the existential claim that is being instantiated (line $m$) as well as the subproof (lines $n$--$p$) which follows from its instantiation.
The restriction on what $\beta$ can be is what prevents $\exists$E from producing invalid arguments as brought out above. 
One easy way to satisfy these restrictions is to always choose a new instantiating constant $\beta$ that does not appear anywhere outside the subproof. 
This practice is in keeping with the idea that $\beta$ is an arbitrary place holder that we make temporary use of inside a subproof in order to expedite the reasoning we wish to develop.

Like the rules for conditional introduction and both negation introduction and elimination, the rule for existential elimination involves discharging an assumption.
The pattern is to: (1) assume a substitution instance with an arbitrary constant; (2) reason your way to a conclusion that does not include that constant; and (3) discharge the assumption, closing the subproof.
As before, the lines of a closed subproof are \define{dead} thereafter, where every line of a proof that is not dead at a line in a proof is \define{live} at that line.
The rules that cite individual lines (as opposed to subproofs) can only appeal to lines that are live at that line.

Having introduced the existential elimination rule, we are now in a position to regiment the informal argument given above in which `Bob' served as our arbitrary constant.

\begin{proof}
	\hypo{es}{\qt{\exists}{x} Sx} \pr{}
	\hypo{ast}{\qt{\forall}{x}(Sx \eif Mx)} \pr{} 
	\open
		\hypo{s}{Sa} \as{for $\exists$E}
		\have{st}{Sa \eif Ma}\Ae{ast}
		\have{t}{Ma} \ce{s,st}
		\have{et1}{\qt{\exists}{x} Mx}\Ei{t}
	\close
	\have{et2}{\qt{\exists}{x} Tx}\Ee{es,s-et1}
\end{proof}

Given the introduction and elimination rules for both the existential and universal quantifiers, we may turn to derive the quantifier exchange rules which will often be useful.
In addition to being extremely intuitive, these derivations will provide a good test that the rules that the quantifier introduction and elimination rules are in good order, allowing us to derive the logical consequences that we should expect of a complete proof system for $\FI$.




\section{Quantifier Exchange Rules}
  \label{QER}

Sentences of the form $\enot\qt{\exists}{\alpha}\metaA$ and $\qt{\forall}{\alpha}\enot\metaA$ are logically equivalent, as are sentences of the form $\enot\qt{\forall}{\alpha}\metaA$ and $\qt{\exists}{\alpha}\enot\metaA$.
Accordingly, we may assert the following entailments: 

\factoidbox{
  \textsc{Quantifier Exchange:}
  \begin{enumerate}[leftmargin=.75in]
    \vspace{-.1in}
    \begin{multicols}{2}
      \item[$(\enot\exists)$] $\enot\qt{\exists}{\alpha}\metaA \vDash \qt{\forall}{\alpha}\enot\metaA$.
      \item[$(\enot\forall)$] $\enot\qt{\forall}{\alpha}\metaA \vDash \qt{\exists}{\alpha}\enot\metaA$.
      \item[$(\forall\enot)$] $\qt{\forall}{\alpha}\enot\metaA \vDash \enot\qt{\exists}{\alpha}\metaA$.
      \item[$(\exists\enot)$] $\qt{\exists}{\alpha}\enot\metaA \vDash \enot\qt{\forall}{\alpha}\metaA$.
    \end{multicols}
  \end{enumerate}
  \vspace{-.1in}
}

Given the introduction and elimination rules for the quantifiers, we may derive rules which correspond to these entailments.
Consider the derivation of $(\enot\exists)$ given below:

\begin{proof}
	\hypo{a}{\enot\qt{\exists}{\alpha} \metaA}      \pr{}
    \open
      \hypo{b}{\metaA\unisub{\beta}{\alpha}}      \as{for $\enot$I where $\beta$ is a new constant}
      \have{c}{\qt{\exists}{\alpha} \metaA}       \Ei{b}
      \have{d}{\enot\qt{\exists}{\alpha} \metaA}  \r{a}
    \close
  \have{e}{\enot\metaA\unisub{\beta}{\alpha}}     \ni{b-d}
  \have{f}{\qt{\forall}{\alpha}\enot\metaA}       \Ai{e}
\end{proof}

This proof works by instantiating $\metaA$ with a new constant $\beta$ in line $2$ and then existentially generalizing on $\beta$ in order to derive a contradiction.
As a result, $\enot\metaA\unisub{\beta}{\alpha}$ follows by negation introduction. 
Since $\beta$ does not occur in any undischarged assumptions, we may universally generalize on $\beta$ in order to derive the conclusion in line $6$. 
Consider the derivation of $(\forall\enot)$: 

\begin{proof}
	\hypo{a}{\qt{\forall}{\alpha} \enot\metaA}      \pr{}
    \open
      \hypo{b}{\qt{\exists}{\alpha}\metaA}        \as{for $\enot$I}
        \open
          \hypo{c}{\metaA\unisub{\beta}{\alpha}}  \as{for $\exists$E where $\beta$ is a new constant}
            \open
              \hypo{d}{\qt{\exists}{\alpha}\metaA}  \as{for $\enot$I}
              \have{e}{\metaA\unisub{\beta}{\alpha}}  \r{c}
              \have{f}{\enot\metaA\unisub{\beta}{\alpha}}  \Ae{a}
            \close
          \have{g}{\enot\qt{\exists}{\alpha}\metaA}  \ni{d-f}
        \close
      \have{h}{\enot\qt{\exists}{\alpha}\metaA}  \Ee{b,c-g}
    \close
  \have{i}{\enot\qt{\exists}{\alpha}\metaA}       \ni{b-h}
\end{proof}

The proof begins as expected by stating the premise and assuming line $2$ for negation introduction. 
We then assume an instance of line $2$ in line $3$.
Although we could instantiate line $1$ on line $4$ in order to produce a contradiction with line $3$, this is not what we need.
Instead, we are looking to derive something which will contradict with line $2$ that does not include $\beta$. 
Accordingly, we assume line $4$ for negation introduction. 
We may now rewrite line $3$ in line $5$ and instantiate line $1$ on line $6$, producing a contradiction. 
By negation introduction on line $7$, we have what we wanted, and since $\beta$ does not occur in line $7$, we may close the subproof with existential elimination on line $8$.
This produces another contradiction, and so we may conclude in line $9$ with negation introduction. 

Although we could go on to prove $(\enot\forall)$ and $(\exists\enot)$ in a similar fashion, there is another approach which turns on the following \define{metarule} which takes one derivation to follow from another instead of taking one sentence to follow from some others.
\begin{enumerate}[leftmargin=.75in]
  \item[(MCP)] If $\metaA \vdash \metaB$, then $\enot\metaB \vdash \enot\metaA$.
\end{enumerate}
Given any $\metaA$ and $\metaB$, this rule says that if we can derive $\metaB$ from $\metaA$, then we may also derive $\enot\metaA$ from $\enot\metaB$, referring to this rule as \textit{meta-contraposition}.
It is worth comparing our standard contraposition rule CP which we derived before: $\metaA \eif \metaB \vdash \enot\metaB \eif \enot\metaA$.
Whereas CP concerns the material conditional $\eif$, MCP concerns $\vdash$.
Nevertheless, the proof is similar where we begin by assuming $\metaA \vdash \metaB$ for some otherwise arbitrary wfss $\metaA$ and $\metaB$ of $\FI$, calling this assumption $(\star)$.
We may then write the following proof:

\begin{proof}
	\hypo{a}{\enot\metaB}     \pr{}
    \open
      \hypo{b}{\metaA}      \as{for $\enot$I}
      \have{c}{\metaB}      \by{$(\star)$}{b}
      \have{d}{\enot\metaB} \r{a}
    \close
  \have{e}{\enot\metaA}     \ni{b-d}
\end{proof}

Since we know that $\metaA \vdash \metaB$ by assumption, there is some proof of $\metaB$ from $\metaA$.
Accordingly, we may think of the proof given above as abbreviating a longer proof in which $(\star)$ is replaced with the proof of $\metaB$ from $\metaA$.
The result is a complete proof of $\enot\metaA$ from $\enot\metaB$. 

There are two more derived rules ($\forall$DN) and (DN$\forall$) which will come in handy:

\begin{multicols}{2}
  
\begin{proof}
	\hypo{a}{\qt{\forall}{\alpha} \enot\enot\metaA}   \pr{}
  \have{b}{\enot\enot\metaA\unisub{\beta}{\alpha}}  \Ae{a}
  \have{c}{\metaA\unisub{\beta}{\alpha}}            \by{DN}{b}
  \have{d}{\qt{\forall}{\alpha}\metaA}              \Ai{c}
\end{proof}

\begin{proof}
	\hypo{a}{\qt{\exists}{\alpha} \enot\enot\metaA}   \pr{}
    \open
      \hypo{b}{\enot\enot\metaA\unisub{\beta}{\alpha}}  \as{}
      \have{c}{\metaA\unisub{\beta}{\alpha}}            \by{DN}{b}
      \have{d}{\qt{\exists}{\alpha} \metaA}             \Ei{c}
    \close
  \have{e}{\qt{\exists}{\alpha} \metaA}             \Ee{a,b-d}
\end{proof}

\end{multicols}
% \vspace{-.1in}

Without too much trouble, we may reverse the direction of the proofs above to derive: $\qt{\forall}{\alpha}\metaA \vdash \qt{\forall}{\alpha} \enot\enot \metaA$ and $\qt{\exists}{\alpha} \metaA \vdash \qt{\exists}{\alpha} \enot\enot \metaA$. 
We now have all the ingredients that we need to provide proofs which correspond to $(\enot\forall)$ and $(\exists\enot)$ from before.
Since these proofs will make essential use of MCP, these proofs will take place in the metalanguage and be presented informally.

\begin{Lthm}[$\enot\forall$] \label{lemma:NotForAll}
    $\enot\qt{\forall}{\alpha}\metaA \vdash \qt{\exists}{\alpha}\enot\metaA$.
\end{Lthm}

\begin{quote}
  \textit{Proof:}
  Consider the result of replacing $\metaA$ with $\enot\metaA$ in the derivation of $(\enot\exists)$ given above, where this constitutes a proof of $\enot\qt{\exists}{\alpha}\enot\metaA \vdash \qt{\forall}{\alpha}\enot\enot\metaA$.
  Since $\qt{\forall}{\alpha}\enot\enot\metaA \vdash \qt{\forall}{\alpha}\metaA$ by $\forall$DN, we may chain these proofs together to derive $\enot\qt{\exists}{\alpha}\enot\metaA \vdash \qt{\forall}{\alpha}\metaA$.
  If follows by MCP that $\enot\qt{\forall}{\alpha}\metaA \vdash \enot\enot\qt{\exists}{\alpha}\enot\metaA$, and so $\enot\qt{\forall}{\alpha}\metaA \vdash \qt{\exists}{\alpha}\enot\metaA$ by DN. 
  \qed
\end{quote}
  
\begin{Lthm}[$\exists\enot$] \label{lemma:ExistsNot}
     $\qt{\exists}{\alpha}\enot\metaA \vdash \enot\qt{\forall}{\alpha}\metaA$.
\end{Lthm}

\begin{quote}
  \textit{Proof:}
  (Exercise for the reader.)
  % Consider the result of replacing $\metaA$ with $\enot\metaA$ in the derivation of $(\forall\enot)$ given above, where this constitutes a proof of $\qt{\forall}{\alpha}\enot\enot\metaA \vdash \enot\qt{\exists}{\alpha}\enot\metaA$.
  % Since $\qt{\forall}{\alpha}\metaA \vdash \qt{\forall}{\alpha}\enot\enot\metaA$ by $\exists$DN, we may chain these proofs together to derive $\enot\qt{\forall}{\alpha}\enot\metaA \vdash \qt{\exists}{\alpha}\metaA$.
  % If follows by MCP that $\enot\qt{\exists}{\alpha}\metaA \vdash \enot\enot\qt{\forall}{\alpha}\enot\metaA$, and so $\enot\qt{\exists}{\alpha}\metaA \vdash \qt{\forall}{\alpha}\enot\metaA$ by DN. 
  \qed
\end{quote}

You can think of these proofs as instruction manuals for constructing the appropriate derivations.
In this case, it might have been easier to provide derivations for $(\enot\forall)$ and $(\exists\enot)$ in the same manner that we did for $(\enot\exists)$ and $(\forall\enot)$.
Even so, the metarule MCP and derived rules ($\forall$DN) and ($\exists$DN) are important in their own right.
It is important to note, however, that whereas ($\forall$DN) and ($\exists$DN) may be applied in the course of a derivation, MCP cannot.
This is because MCP draws the conclusion $\enot\metaB \vdash \enot\metaA$ from $\metaA \vdash \metaB$, where the instances of these claims are not sentences in $\FI$ since they include `$\vdash$'.
It was for this reason that we provided informal proofs of $(\enot\forall)$ and $(\exists\enot)$ in the metalanguage. 

% \begin{proof}
% 	\hypo{Aa}{\qt{\forall}{y} Ay} \pr{want $\enot\qt{\exists}{y}\enot Ay$}
% 	\open
% 		\hypo{Ena}{\qt{\exists}{y}\enot Ay}\as{for reductio}
% 		\open
% 			\hypo{nc}{\enot Ac}\as{for $\exists$E}
% 			\open
% 				\hypo{Aa2}{\qt{\forall}{y} Ay}\as{for reductio}
% 				\have{c2}{Ac}\Ae{Aa}
% 				\have{nc2}{\enot Ac}\by{R}{nc}
% 			\close
% 			\have{nAa}{\enot\qt{\forall}{y} Ay}\ni{Aa2-nc2}
% 		\close
% 		\have{nAa3}{\enot\qt{\forall}{y} Ay}\Ee{Ena, nc-nAa}
% 		\have{Aa3}{\qt{\forall}{y} Ay}\by{R}{Aa}
% 	\close
% 	\have{nEna}{\enot\qt{\exists}{y}\enot Ay}\ni{Ena-Aa3, Ena-nAa3}
% \end{proof}







\section{Identity}

We turn now to the introduction and elimination rules for identity, both of which are a lot easier to work with than the quantifier rules.
To begin with, the introduction rule for identity is in keeping with the idea that everything is identical to itself.
Accordingly, for any constant $\alpha$, one may always write $\alpha = \alpha$ on any line of a proof.
Moreover, instead of \textit{assuming} $\alpha = \alpha$ for some particular constant $\alpha$ where this would constitute a further undischarged assumption, we may justify any instance of $\alpha = \alpha$ by citing the following rule: 

\begin{proof}
  \have[\ ]{a}{\alpha = \alpha} \by{:=I ~~($\alpha$ is a constant)}{}
\end{proof}

The $=$I rule is unlike the other rules in that it does appeal to any prior lines of the proof and so may be referred to as an \define{axiom schema}, meaning that for any constant $\alpha$, we may add $\alpha=\alpha$ to a proof without any justification apart from citing $=$I itself. 
% An instance of $=$I is called an \define{axiom}.
% Something similar may be said for the theorems we may derive

The elimination rule for identity is more complicated, but only slightly.
% Nevertheless, we will need a new piece of notation in order to articulate identity elimination.
%
% \factoidbox{
%    If $\beta$ is free for $\alpha$ in $\metaA$, then a \define{free substitution} $\metaA\freesub{\beta}{\alpha}$ is the result of replacing one or more free occurrences of $\alpha$ in $\metaA$ with $\beta$. 
% } %TODO move above to section on substitution; discuss why we should not state the quantifier rules with freesub
%
% Note the indefinite article `a' above where we refer to $\metaA\freesub{\beta}{\alpha}$ as \textit{a} free substitution of $\beta$ for $\alpha$ in $\metaA$. 
% This is because there could be multiple occurrences of $\alpha$ in $\metaA$ and since a free substitution of $\beta$ for $\alpha$ in $\metaA$ replaces one or more occurrences of $\alpha$ with $\beta$, there need not be unique result of replacing one or more such occurrence of $\alpha$ with $\beta$. 
% As a result, we cannot use identify ``the'' free substitution of $\beta$ for $\alpha$ in $\metaA$ as brought out by the following cases: 
%
% \begin{earg}
%   \item[\ex{F1}] $\forall x(Fxy \eif Fyx)\freesub{z}{y}=\forall x(Fxz \eif Fyx)$. ~~(\textsc{incorrect})
%   \item[\ex{F2}] $\forall x(Fxy \eif Fyx)\freesub{z}{y}=\forall x(Fxy \eif Fzx)$. ~~(\textsc{incorrect})
%   \item[\ex{F3}] $\forall x(Fxy \eif Fyx)\freesub{z}{y}=\forall x(Fxz \eif Fzx)$. ~~(\textsc{incorrect})
% \end{earg}
%
% The reason that the identities above must be avoided follows from the fact that the wffs on the left are all identical, but the wffs on the right are not.
% But distinct wffs cannot be identical to the same wff.
% Nevertheless, the following claims are true:
%
% \begin{earg}
%   % \item[\ex{F1}] $\forall x(Fxy \eif \exists yFyx)\freesub{z}{y}$.
%   \item[\ex{F4}] $\forall x(Fxz \eif Fyx)$ is a free substitution instance of $\forall x(Fxy \eif Fyx)\freesub{z}{y}$.
%   \item[\ex{F5}] $\forall x(Fxy \eif Fzx)$ is a free substitution instance of $\forall x(Fxy \eif Fyx)\freesub{z}{y}$.
%   \item[\ex{F6}] $\forall x(Fxz \eif Fzx)$ is a free substitution instance of $\forall x(Fxy \eif Fyx)\freesub{z}{y}$.
% \end{earg}
%
% Even though it could take a number of different forms, we will write $\metaA\freesub{\beta}{\alpha}$ to indicate a free substitution of $\beta$ for $\alpha$ in $\metaA$.
% We may now state the elimination rule for identity.
If you have derived $\metaA$ and $\alpha = \beta$ for some constants $\alpha$ and $\beta$, then we may replace any occurrence of $\alpha$ with $\beta$ in $\metaA$ and similarly, we may replace any occurrence of $\beta$ with $\alpha$ in $\metaA$.
More specifically, the identity elimination rules ($=$E) may be stated as follows:

\begin{multicols}{2}
  
\begin{proof}
  \have[m]{a}{\alpha = \beta} 
  \have[n]{b}{\metaA\unisub{\alpha}{\gamma}}
	\have[\ ]{c}{\metaA\unisub{\beta}{\gamma}} \by{=E}{a,b}
\end{proof}

\begin{proof}
  \have[m]{a}{\alpha = \beta} 
  \have[n]{b}{\metaA\unisub{\beta}{\gamma}}
	\have[\ ]{c}{\metaA\unisub{\alpha}{\gamma}} \by{=E}{a,b}
\end{proof}

\end{multicols}

It is important to note that not all occurrences of $\alpha$ (similarly $\beta$) need to be replaced with $\beta$ ($\alpha$) in any given $\metaA$.
The identity elimination rules capture this by including $\metaA\unisub{\alpha}{\gamma}$ and $\metaA\unisub{\beta}{\gamma}$.
For example, consider the following derivations:

\begin{proof}
  \hypo{a}{Raa} 
  \hypo{b}{a=b} 
  \have{c}{Rab} \by{$=$E}{a,b}
  \have{d}{Rba} \by{$=$E}{a,b} 
  \have{d}{Rbb} \by{$=$E}{a,b} 
  % \have{e}{Raa} \by{$=$E}{a,b} 
\end{proof}

Given the premises $Raa$ and $a=b$, we may derive $Rab$, $Rba$, and $Rbb$.
This is because $Raa=Rac\unisub{a}{c}=Rca\unisub{a}{c}=Rcc\unisub{a}{c}$, leading to the replacements $Rac\unisub{b}{c}=Rab$, $Rca\unisub{b}{c}=Rba$, and $Rcc\unisub{b}{c}=Rbb$, respectively.
Although the justifications for each inference is the same, the inferences are licensed on account of different values of $\metaA$.
% In practice, it is not always important to construct the appropriate value of $\metaA$ since it is easy to apply the existential elimination rules by simply replacing one constant with another.

Here is a derivation of the transitivity law for identity:

\begin{proof}
	\open
		\hypo{a}{a{=}b \eand b{=}c}\pr{}
		\have{b}{a{=}b} \ae{a}
		\have{c}{b{=}c} \ae{a}
		\have{d}{a{=}c}\by{$=$E}{b,c}
	\close
	\have{e}{(a = b \eand b = c)\eif a = c} \ci{a-d}
	\have{f}{\qt{\forall}{z}((a = b \eand b = z)\eif a = z)} \Ai{e}
	\have{g}{\qt{\forall}{y}\qt{\forall}{z}((a = y \eand y = z)\eif a = z)} \Ai{f}
	\have{h}{\qt{\forall}{x}\qt{\forall}{y}\qt{\forall}{z}((x = y \eand y = z)\eif x = z)} \Ai{g}
\end{proof}

At line $4$, we employed the identity on line $3$ in order to replace $b$ in line $2$ with a $c$.
After discharging the assumption with the conditional introduction rule, the rest of the proof proceeded by universal introduction given that $a$, $b$, and $c$ do not occur in any undischarged assumptions. 
A similar proof shows that identity is symmetric.

As a somewhat special case, it is worth considering a proof that identity is reflexive.

\begin{proof}
  \have{a}{a=a} \by{$=$I}{} 
  \have{b}{\qt{\forall}{x}(x=x)} \by{$\forall$I}{a}
\end{proof}

Notice that there is no horizontal line below line $1$.
This signifies that there is no premise.
Rather, identity introduction has been used in its unique capacity to introduce an identity claim which does not appeal to any other lines.
Accordingly, line $1$ is neither a premise nor an undischarged assumption.
Since the constant $a$ does not occur in any premises or undischarged assumptions, we may use universal introduction to conclude the proof.




\section{Proofs and Provability in $\FI$}

We will refer to the natural deduction rules specified above together with the natural deduction rules provided in Chapter \ref{ch.PL-deduction} as the natural deduction rules for FOL$^=$.
We may then adapt the definition of a proof from before by replacing PL with FOL$^=$ as follows:

\factoidbox{
  A \define{derivation} (or \define{proof}) of $\metaA$ from $\MetaG$ in FOL$^=$ is any finite sequence of wfs of $\FI$ ending in $\metaA$ where every wfs in the sequence is either: (1) a premise in $\MetaG$; (2) an assumption which is eventually discharged; or (3) follows from previous lines by a natural deduction rule for FOL$^=$ besides AS. 
}

A wfs $\metaA$ of $\FI$ is \define{derivable} (or \define{provable}) from $\MetaG$ in FOL$^=$ just in case there is a natural deduction derivation (proof) of $\metaA$ from $\MetaG$ in FOL$^=$, where we may write this $\MetaG \vdash_{\textsc{fol}^=} \metaA$, or just $\MetaG \vdash \metaA$ when it is clear from context which proof system we intend.  

In keeping with the definitions given before, a wfs $\metaA$ of $\FI$ is a \define{theorem} of FOL$^=$ just in case $\vdash\metaA$ which abbreviates $\varnothing\vdash\metaA$, indicating that $\metaA$ is derivable in FOL$^=$ from no premises.
Since FOL$^=$ includes all the same rules and expressive resources of PL, all of the theorems of PL are also theorems of FOL$^=$.
More generally, $\MetaG \vdash_{\textsc{fol}^=} \metaA$ whenever $\MetaG \vdash_{\textsc{pl}} \metaA$. 
Put otherwise, FOL$^=$ is an \define{extension} of PL.
As brought out in Chapters \ref{ch.FOL-soundness} - \ref{ch.FOL-completeness}, we will similarly extend the soundness and completeness results for PL to cover FOL$^=$.

Two sentences $\metaA$ and $\metaB$ are \define{interderivable} (or \define{provably equivalent}) in FOL$^=$ if and only if both $\metaA\vdash\metaB$ and $\metaB\vdash\metaA$.
A set of sentences $\MetaG$ is \define{inconsistent} if and only if $\MetaG\vdash\bot$ where $\bot$ is our arbitrarily chosen contradiction, e.g., $A\eand\enot A$ from before.




\section{Soundness of FOL$^=$}

% TODO: recall how important soundness is to avoid leading us astray
% soundness also allows us to avoid writing semantic proofs
% add

% In order to show that something is a theorem we have to derive it from no premises.
Recall the challenge of showing that a wfs $\metaA$ of $\PL$ is not derivable in PL from a set of wfss $\MetaG$ of $\PL$.
Whereas providing a derivation of $\metaA$ from $\MetaG$ in PL is all that is required to show that $\metaA$ is derivable from $\MetaG$, it is not possible to survey the space of all PL derivations to show that there is no derivation when none exists.
The same predicament arises in attempting to show that $\metaA$ cannot be derived from $\MetaG$ in FOL$^=$.
As before, we will overcome this difficulty by appealing to the following metalogical property:

\factoidbox{
  \textsc{FOL$^=$ Soundness:} $\MetaG \vdash_{\textsc{fol}^=} \metaA$ only if $\MetaG \models \metaA$.
} %\vspace{-.4in}

In order to show that $\MetaG \nvdash_{\textsc{fol}^=} \metaA$, we may show that $\MetaG \nmodels \metaA$ by providing a model in which $\VV{\I}{}(\metaG) = 1$ for all $\metaG \in \MetaG$ but $\VV{\I}{}(\metaA) = 0$.
Given \textsc{FOL$^=$ Soundness}, it follows that $\MetaG \nvdash_{\textsc{fol}^=} \metaA$, and so there is no derivation of $\metaA$ from $\MetaG$ in FOL$^=$.
% This is a lot easier that attempting survey the entire space of possible proofs in FOL$^=$.
In the case where $\MetaG=\varnothing$, we need only provide a countermodel to $\metaA$ in order to show that $\metaA$ is not a theorem, i.e., $\nvdash_{\textsc{fol}^=} \metaA$.

In addition to these advantages, \textsc{FOL$^=$ Soundness} shows that FOL$^=$ can be relied on to only derive logical consequences from a set of premises.
% Since we may appeal to \textsc{FOL$^=$ Soundness} in order to establish that $\MetaG \vDash \metaA$ by deriving $\metaA$ from $\metaG$ in FOL$^=$, thereby avoiding the need to write a semantic proof.
Since writing semantic proofs is difficult and prone to error, establishing that $\MetaG \vDash \metaA$ by deriving $\metaA$ from $\metaG$ in FOL$^=$ is often much easier and more reliable.
Moreover, given that there is at least one model $\M$ of $\FI$, it follows that $\metaA$ is true in $\M$ for any theorem $\vdash_{\textsc{fol}^=} \metaA$. 
As a result, the set of all theorems of FOL$^=$ are satisfiable and so consistent since if $\bot$ was derivable from the set of theorems in FOL$^=$, then $\bot$ would be true in $\M$, but this leads to a contradiction.
For these reasons, the following chapter will extend the proof of \textsc{PL Soundness} to establish \textsc{FOL$^=$ Soundness}.





\iffalse

\practiceproblems

\solutions
\problempart
\label{pr.justifyFOL$^=$proof}
Provide a justification (rule and line numbers) for each line of proof that requires one.
\begin{multicols}{2}
%$\{\qt{\forall}{x}(\qt{\exists}{y})(Rxy \eor Ryx),\qt{\forall}{x}\enot Rmx\}\vdash\qt{\exists}{x}Rxm$
\begin{proof}
\hypo{p1}{\qt{\forall}{x}\qt{\exists}{y}(Rxy \eor Ryx)}
\have{p2}{\qt{\forall}{x}\enot Rmx}
\have{3}{\qt{\exists}{y}(Rmy \eor Rym)}{}
	\open
		\hypo{a1}{Rma \eor Ram}
		\have{a2}{\enot Rma}{}
		\have{a3}{Ram}{}
		\have{a4}{\qt{\exists}{x} Rxm}{}
	\close
\have{n}{\qt{\exists}{x} Rxm} {}
\end{proof}

%$\{\qt{\forall}{x}(\qt{\exists}{y}Lxy \eif \qt{\forall}{z}Lzx), Lab\} \vdash \qt{\forall}{x}Lxx$
\begin{proof}
\hypo{1}{\qt{\forall}{x}(\qt{\exists}{y}Lxy \eif \qt{\forall}{z}Lzx)}
\hypo{2}{Lab}
\have{3}{\qt{\exists}{y} Lay \eif \qt{\forall}{z}Lza}{}
\have{4}{\qt{\exists}{y} Lay} {}
\have{5}{\qt{\forall}{z} Lza} {}
\have{6}{Lca}{}
\have{7}{\qt{\exists}{y} Lcy \eif \qt{\forall}{z}Lzc}{}
\have{8}{\qt{\exists}{y} Lcy}{}
\have{9}{\qt{\forall}{z} Lzc}{}
\have{10}{Lcc}{}
\have{11}{\qt{\forall}{x} Lxx}{}
\end{proof}


% $\{\qt{\forall}{x}(Jx \eif Kx), \qt{\exists}{x}\qt{\forall}{y} Lxy, \qt{\forall}{x} Jx\} \vdash \qt{\exists}{x}(Kx \eand Lxx)$
\begin{proof}
\hypo{a}{\qt{\forall}{x}(Jx \eif Kx)}
\hypo{b}{\qt{\exists}{x}\qt{\forall}{y} Lxy}
\hypo{c}{\qt{\forall}{x} Jx}
\open
	\hypo{2}{\qt{\forall}{y} Lay}
	\have{d}{Ja}{}
	\have{e}{Ja \eif Ka}{}
	\have{f}{Ka}{}
	\have{3}{Laa}{}
	\have{4}{Ka \eand Laa}{}
	\have{5}{\qt{\exists}{x}(Kx \eand Lxx)}{}
\close
\have{j}{\qt{\exists}{x}(Kx \eand Lxx)}{}
\end{proof}


%$\vdash \qt{\exists}{x} Mx \eor \qt{\forall}{x}\enot Mx$
\begin{proof}
	\open
		\hypo{p1}{\enot (\qt{\exists}{x} Mx \eor \qt{\forall}{x}\enot Mx)}
		\have{p2}{\enot \qt{\exists}{x} Mx \eand \enot \qt{\forall}{x}\enot Mx}{}
		\have{p3}{\enot \qt{\exists}{x} Mx}{}
		\have{p4}{\qt{\forall}{x}\enot Mx}{}
		\have{p5}{\enot \qt{\forall}{x}\enot Mx}{}
	\close
\have{n}{\qt{\exists}{x} Mx \eor \qt{\forall}{x}\enot Mx} {}
\end{proof}
\end{multicols}

\solutions
\problempart
\label{pr.someFOL$^=$proofs}
Provide a natural deduction proof of each claim.
\begin{earg}
\item $\vdash \qt{\forall}{x} Fx \eor \enot \qt{\forall}{x} Fx$
\item $\{\qt{\forall}{x}(Mx \eiff Nx), Ma\eand\qt{\exists}{x} Rxa\}\vdash \qt{\exists}{x} Nx$
\item $\{\qt{\forall}{x}(\enot Mx \eor Ljx), \qt{\forall}{x}(Bx\eif Ljx), \qt{\forall}{x}(Mx\eor Bx)\}\vdash \qt{\forall}{x}Ljx$
\item $\qt{\forall}{x}(Cx \eand Dt)\vdash \qt{\forall}{x}Cx \eand Dt$
\item $\qt{\exists}{x}(Cx \eor Dt)\vdash \qt{\exists}{x} Cx \eor Dt$
\end{earg}

\problempart
Provide a proof of the argument about Billy on p.~\pageref{surgeon2}.



\problempart
\label{pr.BarbaraEtc.proof1}
Look back at Part \ref{pr.BarbaraEtc} on p.~\pageref{pr.BarbaraEtc}. Provide proofs to show that each of the argument forms is valid in FOL$^=$.




\solutions
\problempart
\label{pr.FOL$^=$proofsNDe}
Provide a natural deduction proof of each claim.
\begin{earg}
\item $\qt{\forall}{x} \qt{\forall}{y} Gxy\vdash\qt{\exists}{x} Gxx$
\item $\qt{\forall}{x} \qt{\forall}{y} (Gxy \eif Gyx) \vdash \qt{\forall}{x}\qt{\forall}{y} (Gxy \eiff Gyx)$
\item $\{\qt{\forall}{x}(Ax\eif Bx), \qt{\exists}{x} Ax\} \vdash \qt{\exists}{x} Bx$
\item $\{Na \eif \qt{\forall}{x}(Mx \eiff Ma), Ma, \enot Mb\}\vdash \enot Na$
\item $\vdash\qt{\forall}{z} (Pz \eor \enot Pz)$
\item $\vdash\qt{\forall}{x} Rxx\eif \qt{\exists}{x} \qt{\exists}{y} Rxy$
\item $\vdash\qt{\forall}{y} \qt{\exists}{x} (Qy \eif Qx)$
\end{earg}



\problempart
Show that each pair of sentences is provably equivalent.
\begin{earg}
\item $\qt{\forall}{x} (Ax\eif \enot Bx)$, $\enot\qt{\exists}{x}(Ax \eand Bx)$
\item $\qt{\forall}{x} (\enot Ax\eif Bd)$, $\qt{\forall}{x} Ax \eor Bd$
\item $\qt{\exists}{x} Px \eif Qc$, $\qt{\forall}{x} (Px \eif Qc)$
\end{earg}



\problempart
Show that each of the following is provably inconsistent.
\begin{earg}
\item \{$Sa\eif Tm$, $Tm \eif Sa$, $Tm \eand \enot Sa$\}
\item \{$\enot\qt{\exists}{x} Rxa$, $\qt{\forall}{x} \qt{\forall}{y} Ryx$\}
\item \{$\enot\qt{\exists}{x} \qt{\exists}{y} Lxy$, $Laa$\}
\item \{$\qt{\forall}{x}(Px \eif Qx)$, $\qt{\forall}{z}(Pz \eif Rz)$, $\qt{\forall}{y} Py$, $\enot Qa \eand \enot Rb$\}
\end{earg}



\solutions
\problempart
\label{pr.likes}
Write a symbolization key for the following argument, translate it, and prove it:
\begin{quote}
There is someone who likes everyone who likes everyone that first person likes. Therefore, there is someone who likes themself.
\end{quote}

\problempart
\label{pr.identity}
Provide a proof of each claim.
\begin{earg}
\item $\{Pa \eor Qb, Qb \eif b{=}c, \enot Pa\}\vdash Qc$
\item $\{m{=}n \eor n{=}o, An\}\vdash Am \eor Ao$
\item $\{\qt{\forall}{x} \: x{=}m, Rma\}\vdash \qt{\exists}{x} Rxx$
\item $\enot \qt{\exists}{x} \: x {\neq} m \vdash \qt{\forall}{x}\qt{\forall}{y} (Px \eif Py)$
\item $\qt{\forall}{x}\qt{\forall}{y}(Rxy \eif x{=}y)\vdash Rab \eif Rba$
\item $\{\qt{\exists}{x} Jx, \qt{\exists}{x} \enot Jx\}\vdash \qt{\exists}{x} \qt{\exists}{y}\ x{\neq} y$
\item $\{\qt{\forall}{x}(x{=}n \eiff Mx), \qt{\forall}{x}(Ox \eor \enot Mx)\}\vdash On$
\item $\{\qt{\exists}{x} Dx, \qt{\forall}{x}(x{=}p \eiff Dx)\}\vdash Dp$
\item $\{\qt{\exists}{x}\bigl[Kx \eand \qt{\forall}{y}(Ky \eif x{=}y) \eand Bx\bigr], Kd\}\vdash Bd$
\item $\vdash Pa \eif \qt{\forall}{x}(Px \eor x {\neq} a)$
\end{earg}



\solutions
\problempart
\label{pr.FOL$^=$equivornot}
For each of the following pairs of sentences: If they are logically equivalent in FOL$^=$, give proofs to show this. If they are not, construct a model to show this.
% TODO: this isn't a great problem set in the context, as ND isn't an appropriate method for demonstrating invalidity. Figure out what to do about this.
\begin{earg}
\item $\qt{\forall}{x} Px \eif Qc$, $\qt{\forall}{x} (Px \eif Qc)$
\item $\qt{\forall}{x} Px \eand Qc$, $\qt{\forall}{x} (Px \eand Qc)$
\item $Qc \eor \qt{\exists}{x} Qx$, $\qt{\exists}{x} (Qc \eor Qx)$
\item $\qt{\forall}{x}\qt{\forall}{y} \qt{\forall}{z} Bxyz$, $\qt{\forall}{x} Bxxx$
\item $\qt{\forall}{x}\qt{\forall}{y} Dxy$, $\qt{\forall}{y}\qt{\forall}{x} Dxy$
\item $\qt{\exists}{x}\qt{\forall}{y} Dxy$, $\qt{\forall}{y}\qt{\exists}{x} Dxy$
\end{earg}

\solutions
\problempart
\label{pr.FOL$^=$validornot}
For each of the following arguments: If it is valid in FOL$^=$, give a proof. If it is invalid, construct a model to show that it is invalid.
% TODO: this isn't a great problem set in the context, as ND isn't an appropriate method for demonstrating invalidity. Figure out what to do about this.
\begin{earg}
\item $\qt{\forall}{x}\qt{\exists}{y} Rxy$, \therefore\ $\qt{\exists}{y}\qt{\forall}{x} Rxy$
\item $\qt{\exists}{y}\qt{\forall}{x} Rxy$, \therefore\ $\qt{\forall}{x}\qt{\exists}{y} Rxy$
\item $\qt{\exists}{x}(Px \eand \enot Qx)$, \therefore\ $\qt{\forall}{x}(Px \eif \enot Qx)$
\item $\qt{\forall}{x}(Sx \eif Ta)$, $Sd$, \therefore\ $Ta$
\item $\qt{\forall}{x}(Ax\eif Bx)$, $\qt{\forall}{x}(Bx \eif Cx)$, \therefore\ $\qt{\forall}{x}(Ax \eif Cx)$
\item $\qt{\exists}{x}(Dx \eor Ex)$, $\qt{\forall}{x}(Dx \eif Fx)$, \therefore\ $\qt{\exists}{x}(Dx \eand Fx)$
\item $\qt{\forall}{x}\qt{\forall}{y}(Rxy \eor Ryx)$, \therefore\ $Rjj$
\item $\qt{\exists}{x}\qt{\exists}{y}(Rxy \eor Ryx)$, \therefore\ $Rjj$
\item $\qt{\forall}{x} Px \eif \qt{\forall}{x} Qx$, $\qt{\exists}{x} \enot Px$, \therefore\ $\qt{\exists}{x} \enot Qx$
\item $\qt{\exists}{x} Mx \eif \qt{\exists}{x} Nx$, $\enot \qt{\exists}{x} Nx$, \therefore\ $\qt{\forall}{x} \enot Mx$
\end{earg}

\problempart
\label{pr.FOL$^=$ND.trees1}
Look at the arguments given in Chapter \ref{ch.FOL$^=$Trees}, Problem Part \ref{pr.FOL$^=$.trees.translation.and.validity} (page \pageref{pr.FOL$^=$.trees.translation.and.validity}). For those arguments whose FOL$^=$ translations are valid, prove their validity via natural deduction.

\problempart
\label{pr.FOL$^=$ND.trees2}
Look at the entailment claims given in Chapter \ref{ch.identity}, Problem Part \ref{pr.IdentityTrees} (page \pageref{pr.IdentityTrees}). For those entailment claims that are true, prove them via natural deduction.

\problempart
\label{pr.FOL$^=$ND.trees3}
Look at the arguments given in Chapter \ref{ch.identity}, Problem Part \ref{pr.IdentityArguments} (page \pageref{pr.IdentityArguments}). For those arguments whose FOL$^=$ translations are valid, prove their validity via natural deduction.

\fi
