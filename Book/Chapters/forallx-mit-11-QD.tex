%!TEX root = ../forallx-mit.tex
\chapter{Natural Deduction in QL$^=$}
\label{ch.QLND}


% Trees employ a kind of `brute force' strategy for proving entailment claims.
% When the logical structure of the relevant sentences is rather simple, as it is in SL and in some QL cases, it can be an effective strategy.
% But in other cases, trees become tedious and complex.
% It is useful to have a proof system that allows one to reason in a more targeted way --- especially if you already have an intuitive understanding of why a given argument should be expected to turn out valid.

This chapter extends our system SD to provide a natural deduction system for QL$^=$ which we will refer to as QD.
% Like our natural deduction system for SL, our system can only be used to demonstrate that an argument \emph{is} valid since natural deduction systems do not demonstrate that an argument is \emph{invalid}.
% In this respect natural deduction differs from trees.
As we will show in later chapters, QD is both sound and complete with respect to the semantics for QL$^=$.
That means that there are natural deduction proofs corresponding to all and only the valid arguments in QL$^=$.

Our QL system will include the same introduction and elimination rules that we provided for the sentential connectives included in SL, but now we will add introduction and elimination rules for the quantifiers and identity, deriving a number of new rules.



\section{Substitution Instances}

%to reformat the substitution instances, see the commands \unisub and \freesub in the style file. 

Consider the following claims:

\begin{earg}
  \item[\ex{I1}] Kin loves everything.
  \item[\ex{I2}] Kin loves Cassandra.
  \item[\ex{I3}] Kin loves something.
\end{earg}

Sentence \ref{I2} is referred to as an \textit{instance} of both sentences \ref{I1} and \ref{I3}. % since it is about something particular.
Whereas sentence \ref{I1} makes a universal claim about everything and sentence \ref{I3} makes an existential claim about something, sentence \ref{I2} makes a claim about two things in particular.
It is important to distinguish between all three types of sentences, where one preliminary way to do this is to appeal to their logical strength, i.e., which sentences entail which.
Specifically, sentence \ref{I1} entails sentence \ref{I2} but not \textit{vice versa}, and sentence \ref{I2} entails sentence \ref{I3} but not \textit{vice versa}.
Similarly, sentence \ref{I1} entails sentence \ref{I3} but not \textit{vice versa}.
It is worth nothing that this final entailment would not hold if we permitted the domain to be empty since given an empty domain, sentence \ref{I1} could be true while sentence \ref{I3} is false.

% We will refer to sentence \ref{I2} as an \define{instance} of sentence \ref{I1}, and refer to \ref{I3} as an \define{existential generalisation} of \ref{I2}.

We may regiment the sentences above with the following symbolization key:

\begin{multicols}{2}
  
\begin{ekey}
  \item[Lxy:] $x$ loves $y$ 
  \item[k:] Kin
  \item[c:] Cassandra
\end{ekey}

\begin{earg}
  \item[\ex{I4}] $\forall xLkx$.
  \item[\ex{I5}] $Lkc$.
  \item[\ex{I6}] $\exists xLkx$.
\end{earg}

\end{multicols}

Given that sentence \ref{I4} entails sentence \ref{I5} and sentence $\ref{I5}$ entails sentence $\ref{I6}$, we should expect a complete logic for QL$^=$ to include rules by which to derive sentence $\ref{I6}$ from sentence $\ref{I5}$, and to derive sentence $\ref{I5}$ from sentence $\ref{I4}$. 
In order to state these rules in a sufficiently general way we will need to make use of the notion of substitution from before.
In particular, recall the following definition from $\S\ref{sec:Quantities}$ where $\alpha$ and $\beta$ are any singular terms:

\factoidbox{
  $\beta$ is \define{free for} $\alpha$ in $\metaA$ just in case there is no free occurrence of $\alpha$ in $\metaA$ in the scope of a quantifier that binds $\beta$.
}

Roughly speaking, $\beta$ is free for $\alpha$ just in case $\beta$ can replace $\alpha$ without resulting in any extra binding.
Whereas $z$ is free for $x$ in `$\qt{\forall}{y}(Fxy \supset Fyx)$' since replacing `$x$' with `$z$' would yield `$\qt{\forall}{y}(Fzy \supset Fyz)$', the variable $y$ is not free for $x$ in `$\qt{\forall}{y}(Fxy \supset Fyx)$' since replacing `$x$' with `$y$' yields `$\qt{\forall}{y}(Fyy \supset Fyy)$' where the quantifier `$\forall y$' ends up binding an extra variable.

If $\beta$ is a constant, it follows that $\beta$ is free for any $\alpha$ in any wff $\metaA$. 
Given this definition, we may define substitution as in $\S\ref{sec:Quantities}$, where $\alpha$ and $\beta$ are any singular terms of the language.

\factoidbox{
   If $\beta$ is free for $\alpha$ in $\metaA$, then the \define{substitution} $\metaA\unisub{\beta}{\alpha}$ is the result of replacing all free occurrences of $\alpha$ in $\metaA$ with $\beta$. 
}

We may read `$\metaA\unisub{\beta}{\alpha}$' as `$\beta$ for $\alpha$ in $\metaA$'.
For instance, $\qt{\forall}{y}(Fxy \supset Fyx)\unisub{z}{x}$ is the wff $\qt{\forall}{y}(Fzy \supset Fyz)$ and $\qt{\forall}{y}(Fxy \supset Fyx)\unisub{y}{x}$ is undefined since $y$ is not free for $x$.
We may also observe that $\qt{\forall}{y}(Fxy \supset Fyx)\unisub{y}{z}$ and $\qt{\forall}{y}(Fxy \supset Fyx)\unisub{z}{y}$ are both $\qt{\forall}{y}(Fxy \supset Fxy)$.

This new vocabulary permits us to define the substitution instances of both universal and existential generalisations of the form $\qt{\forall}{\alpha}\metaA$ and $\qt{\exists}{\alpha}\metaA$.
In particular, consider the following:

\factoidbox{
  $\metaA\unisub{\beta}{\alpha}$ is a \define{substitution instance} of $\qt{\forall}{\alpha}\metaA$ and $\qt{\exists}{\alpha}\metaA$ if $\beta$ is a constant. 
}

Since $\beta$ is a constant, the requirement that $\beta$ is free for $\alpha$ in $\metaA$ is satisfied.
In particular, $(Fxy \supset Fyx)\unisub{c}{y}=(Fxc \supset Fcx)$ is a substitution instance of $\qt{\forall}{y}(Fxy \supset Fyx)$ where this is the result of stripping off the quantifier binding $y$ and replacing all free occurrences of $y$ with $c$. 
Nothing forced us to choose the constant $c$.
Instead, we could have used $d$, producing the instance $Fxd \supset Fdx$.
Both of these are instances, and in general, there will be a different instance for every constant in the language.
By contrast, the instances of $\qt{\forall}{y}(Fxy \supset \qt{\exists}{y}Fyx)$ include such wffs as $Fxc \supset \qt{\exists}{y}Fyx$ and $Fxd \supset \qt{\exists}{y}Fyx$ where in both cases the second occurrence of $y$ is not replaced since it is not free. 
The constants here are referred to as \define{instantiating constants}.




\section{Universal Elimination}
  \label{sec:UniElim}

Recall $\qt{\forall}{x} Lkx$ from before.
We claimed that $Lkc$ was entailed by $\qt{\forall}{x} Lkx$.
We are now in a position to state this a little more precisely.
To begin with, we may observe that $Lkc$ is a substitution instance of $\qt{\forall}{x} Lkx$.
More generally, universally quantified claims entail all of their substitution instances.
In order to maintain completeness, we may include the following elimination rule ($\forall$E) so that the substitution instances of a universally quantified claim can be derived from that universally quantified claim:

\begin{proof}
	\have[m]{a}{\qt{\forall}{\alpha}\metaA}
	\have[ ]{c}{\metaA\unisub{\beta}{\alpha}} \by{$\forall$E ~~where $\beta$ is a constant}{a} 
\end{proof}

Remember that the notation for a substitution instance is not a part of QL$^=$, so you cannot write it directly in a proof.
Instead, you write the substitution instance itself including whichever constant $\beta$ is being used to replace the variable $\alpha$ as in this example:

\begin{proof}
	\hypo{a}{\qt{\forall}{x}(Mx \eif Rxd)} \pr{}
	\have{c}{Ma \eif Rad} \Ae{a}
	\have{d}{Md \eif Rdd} \Ae{a}
\end{proof}

%This rule is very similar to the tree rule for universals, which, in our tree system, allowed one to develop a branch containing a universal with any instance of it one likes. 
You are permitted to write down any instance you like on a new line. In this example, we have used the rule twice to produce two instances. In the first case, we instantiate with the constant $a$ and we instantiate with the constant $d$ in the second case. 






\section{Existential Introduction}
  \label{sec:ExistIntro}

Recall that $Lkc$ was said to entail $\qt{\exists}{x} Lkx$.
Given that Kin loves Cassandra, it follows that Kin loves someone.
More generally, any existentially quantified claim is entailed by its substitution instances.
In order to preserve completeness, we may capture these entailments in our proof system by including the following existential introduction rule ($\exists$I):

\begin{proof}
  \have[m]{a}{\metaA\unisub{\beta}{\alpha}} \by{where $\beta$ is a constant and $\alpha$ is a variable}{}  
	\have[\ ]{c}{\qt{\exists}{\alpha}\metaA} \Ei{a}  
\end{proof}

In the example above, $\metaA\unisub{\beta}{\alpha}=Lkx\unisub{c}{x}=Lkc$.
Given $\exists$I, we may derive $\qt{\exists}{\alpha}\metaA=\exists xLkx$ by existentially generalising on $c$.
Alternatively, we could have existentially generalised on $k$, deriving $\exists xLxc$ given that $\metaA\unisub{\beta}{\alpha}=Lxc\unisub{k}{x}=Lkc$. 
Both $Lkx\unisub{c}{x}$ and $Lxc\unisub{k}{x}$ are identical to $Lkc$. 
Similarly, instead of deriving $\qt{\exists}{x}Lkx$ and $\qt{\exists}{x}Lxc$ from $Lkc$, we could have used the variable $y$ to derive $\qt{\exists}{y}Lky$ and $\qt{\exists}{y}Lyc$ since $Lkc$ is also identical to $Lky\unisub{c}{y}$ and $Lyc\unisub{k}{y}$.
Something similar may be said for other variables.

The example above only included one occurrence of each constant.
By contrast, the sentence $Ma \eif Rad$ has two occurrences of the constant $a$.
As a result, we may existentially generalise on either occurrence of $a$ by itself, both occurrences together, or neither.
Consider:

\begin{proof}
	\hypo{a}{Ma \eif Rad} \pr{}
	\have{d}{\qt{\exists}{x}(Mx \eif Rad)} \Ei{a}
	\have{b}{\qt{\exists}{x}(Ma \eif Rxd)} \Ei{a}
	\have{c}{\qt{\exists}{x}(Mx \eif Rxd)} \Ei{a}
	\have{k}{\qt{\exists}{x}(Ma \eif Rad)} \Ei{a}
	\have{e}{\qt{\exists}{y}\qt{\exists}{x}(Mx \eif Ryd)} \Ei{d}
	\have{f}{\qt{\exists}{z}\qt{\exists}{y}\qt{\exists}{x}(Mx \eif Ryz)} \Ei{e}
\end{proof}

Whereas line $2$ existentially generalises on the first occurrence of the constant $a$, line $3$ generalises on the second occurrence, and line $4$ generalises on both. 
Focusing on line $2$, $\metaA\unisub{\beta}{\alpha}=(Mx \supset Rad)\unisub{a}{x}=(Ma \supset Rad)$, where similar identities hold for the other lines.
For line $4$ we have $\metaA\unisub{\beta}{\alpha}=(Mx \supset Rxd)\unisub{a}{x}=(Ma \supset Rad)$, and for line $5$ we have $\metaA\unisub{\beta}{\alpha}=(Ma \supset Rad)\unisub{a}{x}=(Ma \supset Rad)$.
In lines $6$ and $7$, one existential generalisation is staged after the next, generalising on difference occurrences of the same constant. 

Put roughly, existential generalisation permits one to replace any number of occurrences of a constant with a variable that is then bound by an existential quantifier.
Strictly speaking, this approximation is not correct since we cannot generalise as follows:

\begin{proof}
	\hypo{a}{\qt{\exists}{x}(Mx \eif Rad)} \pr{}
  \have{e}{\qt{\exists}{x}\qt{\exists}{x}(Mx \eif Rxd)} \by{$\exists$I (\textsc{incorrect})}{a}
	\have{c}{\qt{\exists}{y}\qt{\exists}{x}(Mx \eif Ryd)} \Ei{d}
\end{proof}

Whereas line $3$ is the same as line $6$ above and perfectly correct, line $2$ does not follow by existential generalisation.
The reason is that we cannot construct an appropriate $\metaA\unisub{\beta}{\alpha}$.
For instance, we cannot take $\metaA\unisub{\beta}{\alpha}=\qt{\exists}{x}(Mx \eif Rxd)\unisub{a}{x}$ given the scope of the quantifier since $\qt{\exists}{x}(Mx \eif Rxd)\unisub{a}{x}$ is not identical to the premise $\qt{\exists}{x}(Mx \eif Rad)$.
By contrast, $\metaA\unisub{\beta}{\alpha}=\qt{\exists}{x}(Mx \eif Ryd)\unisub{a}{y}$ is acceptable since $\qt{\exists}{x}(Mx \eif Ryd)\unisub{a}{y}=\qt{\exists}{x}(Mx \eif Rad)$ which is identical to the premise.
Thus we may derive $\exists y\qt{\exists}{x}(Mx \eif Ryd)$ on line $3$ by $\exists$I.

Whereas replacing $a$ with $x$ results in a quantifier which is already present and so picks up an extra bound variable, this does not happen if we replace $a$ with $y$ instead. 
The existential generalisation rule is stated in such a way so as to ensure that this extra binding cannot occur without breaking the rule.
Nevertheless, it is important to be careful to accurately follow the rule for existentially generalising.
An easy way to see if you are following the rule correctly is to check to see if you pick up any extra variable binding.




\section{Universal Introduction}
  \label{sec:UniIntro}

The rules provided above permit us to derive sentence $\ref{I5}$ from $\ref{I4}$ and to derive $\ref{I6}$ from $\ref{I5}$.
As we noted above, the converse derivations do not hold.
After all, just because Kin loves Cassandra (\ref{I5}), it does not follow that Kin loves everything (\ref{I4}).
Similarly, just because Kin loves something (\ref{I6}), it does not follow that Kin loves Cassandra (\ref{I5}).
More generally, universal claims are not entailed by their substitution instances, and existential claims do not entail their substitution instances.
Nevertheless, it is possible derive universal claims from their instances in specific circumstances and it is possible to make use of a certain instances of an existential claim to derive further sentences.
The following two section will introduce these derivation rules, discussing the conditions of their application.

One way to think about a universal claim of the form $\qt{\forall}{\alpha}\metaA\alpha$ is as a long conjunction $\metaA\unisub{a}{\alpha} \eand \metaA\unisub{b}{\alpha} \eand\ldots$ where the constants $a,b,\ldots$ name every element in the domain.
However, this way of thinking is limited since we may not have enough constants to name every element in the domain, and even if there were enough constants to go around, they could all be interpreted as referring to the same element of the domain.
These considerations are what motivated the introduction of variable assignments which we used to provide the semantics for the quantifiers.
In particular, $\VV{\I}{\va{a}}(\qt{\forall}{\alpha}\metaA)=1$ just in case $\VV{\I}{\va{c}}(\metaA)=1$ for every $\alpha$-variant $\va{c}$ of $\va{a}$, and $\VV{\I}{\va{a}}(\qt{\exists}{\alpha}\metaA)=1$ just in case $\VV{\I}{\va{c}}(\metaA)=1$ for some $\alpha$-variant $\va{c}$ of $\va{a}$.
We may simulate something analogous in the proof system for QL$^=$ by way of arbitrary constants.
Some examples will help to illustrate what it is for a constant to be arbitrary.

Consider the following sentences:

\begin{earg}
  \item[\ex{I7}] $\qt{\forall}{x} Mx$.
  \item[\ex{I8}] $\qt{\forall}{y} My$.
\end{earg}

These sentences entail each other for indeed they say the very same thing, i.e., that everything is $M$.
Insofar as the entailments between these sentences are to be reflected in the proof system, we need a way to derive sentence \ref{I8} from sentence \ref{I7} and \textit{vice versa}.

Consider the following derivation:

\begin{proof}
	\hypo{x}{\qt{\forall}{x} Mx} \pr{}
	\have{a}{Ma} \Ae{x}
	\have{y}{\qt{\forall}{y} My} \Ai{a}
\end{proof}

In line $2$, we have derived $Ma$ from $\qt{\forall}{x}Mx$ by $\forall$E given above.
We could have equally derived $M\alpha$ for any other constant $\alpha$.
This much should come as no surprise.
What is more surprising is the derivation of $\qt{\forall}{y}My$ in line $3$ from $Ma$ in line $2$.
After all, this is like the inference from `Alan is mad' to `Everyone is mad' which is easy to invalidate.
You might wonder what kind of constraints would make this inference to hold.

The key idea behind the inference from line $2$ to line $3$ is that $a$ is an arbitrary constant. 
In particular, $a$ does not occur in the premise, nor does $a$ occur in line $3$ which we are deriving, and so there are no constraints on what $a$ might name. 
Rather, the constant $a$ could name anything whatsoever. 
You can think of $a$ as analogous to $\va{c}(x)$ for an arbitrary $x$-variant $\va{c}$ which permits us to generalise over all elements of the domain.
Given that $a$ could refer to anything, we may derive line $3$.
Although we used the variable $y$ in line $3$, we could have used $x$, or indeed any other variable since there is no threat of any extra variable binding taking place.
More generally, the universal introduction rule ($\forall$I) is stated as follows:

\begin{proof}
  \have[m]{a}{\metaA\unisub{\beta}{\alpha}} \by{where $\beta$ is a constant and $\alpha$ is a variable}{}  
  \have[ ]{c}{\qt{\forall}{\alpha}\metaA} \by{$\forall$I where $\beta$ does not occur here or in any undischarged assumptions}{a}
\end{proof}

It is easy to see that the inference from line $2$ to line $3$ in the proof given above follows this rule.
For contrast, consider the following incorrect application:

\begin{proof}
	\hypo{a}{\qt{\forall}{x} Rxa} \pr{}
	\have{b}{Raa} \Ae{a}
  \have{c}{\qt{\forall}{y} Ryy} \by{$\forall$I (\textsc{incorrect})}{b}
\end{proof}

Intuitively, this argument would be like inferring the conclusion that everything respects itself from the premise that everything respects Arthur.
Even if it follows from the premise that Arthur respects himself, it does not follow that everything respects itself.
% The derivation above goes wrong in that the constant $a$ occurs in the premise which is an assumption that we never discharge. 
The reason the derivation goes astray is that $a$ is not an arbitrary constant since it occurs in the premise which is an undischarged assumption.
In particular, we might take $a$ to name Arthur.
Even if $a$ named something else, it's interpretation would still be constrained in any interpretation in which the premise is true.
% Although $Raa$ may hold, the same cannot be said for $Rbb$ and so on for any arbitrary constant $b$ that does not occur in any undischarged assumption since then there would not be any constraint on what $b$ might name in an interpretation that makes the premises true. 
As a result, the constant $a$ is not arbitrary in way that we need it to be if we are to universally generalise on $a$ with the rule $\forall$I. 

We have just seen one way that $\forall$I can go wrong by offending the constraint that the instantiating constant not occur in an undischarged assumption.
What about the other constraint?
In order to bring this out, consider the following:

\begin{proof}
	\hypo{a}{\qt{\forall}{x} Rxx} \pr{}
	\have{b}{Raa} \Ae{a}
  \have{c}{\qt{\forall}{x} Rax} \by{$\forall$I (\textsc{incorrect})}{b}
\end{proof}

This argument infers that Arthur respects everything from the premise that everything respects itself.
Letting $\metaA\unisub{\beta}{\alpha}=Rax\unisub{a}{x}=Raa$, we may observe that $\qt{\forall}{x}\metaA=\qt{\forall}{x}Rax$, and so one might have thought that we could derive $\qt{\forall}{x}Rax$ from $Raa$.
This would have been correct but for the provision that $\beta$ not occur in $\qt{\forall}{\alpha}\metaA$ which in the case above requires that $a$ not occur in $\qt{\forall}{x}Rax$.
Since $a$ does occur in $\qt{\forall}{x}Rax$, line $3$ does not follow from line $2$.

A good way to remember the restrictions on the $\forall$I rule is to remember that these restriction are put in place to require the instantiating constant to be arbitrary.
In particular, we want the instantiating constant that we are generalising on to be anything, and so it cannot occur in any undischarged assumptions or in the sentence that we are deriving.
The incorrect inferences above are paradigmatic of cases where these requirements are not satisfied.

Although the constant $\alpha$ is not permitted to occur in any undischarged assumption, it may occur in an assumption of a subproof that we have already closed.
For example, here is a perfectly respectable proof of $\qt{\forall}{z}(Dz \eif Dz)$ from no premises.

\begin{proof}
	\open
		\hypo{f1}{Df} \as{}
		\have{f2}{Df} \by{R}{f1}
	\close
	\have{ff}{Df \eif Df}\ci{f1-f2}
	\have{zz}{\qt{\forall}{z}(Dz \eif Dz)}\Ai{ff}
\end{proof}

Since the assumption given in line $1$ above has been discharged, the instantiating constant $f$ does not occur in any undischarged assumptions, and so line $4$ follows from line $3$ by $\forall$I. 



\section{Existential Elimination}
  \label{sec:ExistElim}

A sentence with an existential quantifier tells us that \textit{something} satisfies a given condition.
For example, letting `$S$' regiment `is sad' and `$M$' regiment `is mad', the existential claims $\qt{\exists}{x} Sx$ and $\qt{\exists}{y} My$ say that something is sad and that something is mad but they don't tell us \textit{what} is sad or mad.
In particular, we cannot conclude that the same thing is sad and mad.
This worry can be brought out with the following incorrect derivation:

\begin{proof}
  \hypo{b}{\qt{\exists}{x} Sx} \pr{}
	\hypo{a}{\qt{\exists}{y} My} \pr{}
  \have{d}{Sa} \by{$\exists$I (\textsc{incorrect})}{b} 
  \have{c}{Ma} \by{$\exists$I (\textsc{incorrect})}{a}
  \have{e}{Sa \eand Ma} \ai{c,d}
  \have{f}{\qt{\exists}{z}(Sz \eand Mz)} \Ei{e}
\end{proof}

Whereas $a$ is a perfectly arbitrary constant when it is introduced in line $3$, reusing $a$ in line $4$ leads to the conclusion that the same thing is both sad and mad.
Were we permitted to introduce lines $3$ and $4$ in this way, nothing would stop us from conjoining these claims and existentially generalising, concluding that something is both sad and mad even though this might not be the case.
For instance, one thing could be sad and something else could be mad where nothing requires these to be the same thing. 
Somehow we must prevent these two existential claims from running together as they do above.

Although it is important to avoid concluding too much, this does not mean that we cannot draw any inferences at all from an existential claim.
For instance, suppose that we knew that $\qt{\exists}{x} Sx$ and $\qt{\forall}{x}(Sx \eif Mx)$, or in English, something is sad and, moreover, everything that is sad is also mad.
It is natural to reason in the following way:

\begin{quote}
  By assumption, something is sad.
  Although we do not know what that thing is, call it `Bob' for the purposes of this argument.
  We also know by assumption that everything that is sad is mad.
  In particular, if Bob is sad, then Bob is mad.
  Thus Bob is mad.
  Since `Bob' was a name we introduced only for the sake of the argument, we may revert to the more general claim that something is mad.
\end{quote}

Especially for long lines of reasoning, it is often useful to introduce a temporary constant in the manner employed above.
In particular, we want the constant to be arbitrary, and so it cannot occur in any undischarged assumptions.
At the same time, we also need to keep track of this constant, being careful not to make any other assumptions about the object to which this temporary constant refers, or to draw any conclusions which include this constant.
% It will be convenient to refer to an arbitrary constant that is used to temporarily refer to whatever it is that satisfies an existential claim as a \define{proxy}.
% Accordingly, our use of a proxy must be restricted to a subproof, where it is in this sense arbitrary and temporary.
The existential elimination rule ($\exists$E) will achieve all of this by way of a subproof:

\begin{proof}
	\have[m]{a}{\qt{\exists}{\alpha}\metaA}
	\open	
    \hypo[n]{b}{\metaA\unisub{\beta}{\alpha}} \as{\strut\hspace{.07in}where $\beta$ is a constant and does not in occur}
    \have[ ]{x}{\vdots} \by{\strut\hspace{.4in}lines $m$, $p$, or any undischarged assumptions}{}
		\have[p]{c}{\metaB}
	\close
	\have[\ ]{d}{\metaB{}} \Ee{a,b-c}
\end{proof}

Note that existential elimination cites both the existential claim that is being instantiated (line $m$ above) as well as the subproof (lines $n$--$p$) which follows from its instantiation.
The restriction on what $\beta$ can be is what prevents $\exists$E from producing invalid arguments as brought out above. 
One easy way to satisfy these restrictions is to always choose a new instantiating constant $\beta$ that does not appear anywhere outside the subproof. 
This practice is in keeping with the idea that $\beta$ is an arbitrary place holder that we make temporary use of inside a subproof in order to expedite the lines of reasoning that we wish to draw.

Like the rules for conditional introduction and both negation introduction and elimination, the rule for existential elimination involves discharging an assumption.
The pattern is to: (1) assume a substitution instance with an arbitrary constant; (2) reason your way to a conclusion that does not include that constant; and (3) discharge the assumption, closing the subproof.
As before, the lines of a closed subproof are \define{dead}, where every line of a proof that is not dead is \define{live}.
The rules that cite individual lines (as opposed to subproofs) can only appeal to lines that are live at that point in the proof.

Having introduced the existential elimination rule, we are now in a position to regiment the informal argument given above in which `Bob' served as our arbitrary constant.

\begin{proof}
	\hypo{es}{\qt{\exists}{x} Sx} \pr{}
	\hypo{ast}{\qt{\forall}{x}(Sx \eif Mx)} \pr{} 
	\open
		\hypo{s}{Sa}\as{}
		\have{st}{Sa \eif Ma}\Ae{ast}
		\have{t}{Ma} \ce{s,st}
		\have{et1}{\qt{\exists}{x} Mx}\Ei{t}
	\close
	\have{et2}{\qt{\exists}{x} Tx}\Ee{es,s-et1}
\end{proof}

Given the introduction and elimination rules for both the existential and universal quantifiers, we may turn to derive the quantifier exchange rules which will often be useful.




\section{Quantifier Exchange Rules}

Sentences of the form $\enot\qt{\exists}{\alpha}\metaA$ and $\qt{\forall}{\alpha}\enot\metaA$ are logically equivalent, as are sentences of the form $\enot\qt{\forall}{\alpha}\metaA$ and $\qt{\exists}{\alpha}\enot\metaA$.
Accordingly, we may assert the following entailments: 

\vspace{.1in}
\begin{enumerate}[leftmargin=.75in]
  \begin{multicols}{2}
    \item[$(\enot\exists)$] $\enot\qt{\exists}{\alpha}\metaA \vDash \qt{\forall}{\alpha}\enot\metaA$.
    \item[$(\enot\forall)$] $\enot\qt{\forall}{\alpha}\metaA \vDash \qt{\exists}{\alpha}\enot\metaA$.
    \item[$(\forall\enot)$] $\qt{\forall}{\alpha}\enot\metaA \vDash \enot\qt{\exists}{\alpha}\metaA$.
    \item[$(\exists\enot)$] $\qt{\exists}{\alpha}\enot\metaA \vDash \enot\qt{\forall}{\alpha}\metaA$.
  \end{multicols}
\end{enumerate}
\vspace{-.05in}

Given the introduction and elimination rules for the quantifiers, we may derive rules which correspond to these entailments.
Consider the proof which corresponds to $(\enot\exists)$:

\begin{proof}
	\hypo{a}{\enot\qt{\exists}{\alpha} \metaA}      \pr{}
    \open
      \hypo{b}{\metaA\unisub{\beta}{\alpha}}      \as{where $\beta$ is a new constant}
      \have{c}{\qt{\exists}{\alpha} \metaA}       \Ei{b}
      \have{d}{\enot\qt{\exists}{\alpha} \metaA}  \r{a}
    \close
  \have{e}{\enot\metaA\unisub{\beta}{\alpha}}     \ni{b-d}
  \have{f}{\qt{\forall}{\alpha}\enot\metaA}       \Ai{e}
\end{proof}

This proof works by instantiating $\metaA$ with a new constant $\beta$ in line $2$ and then existentially generalising on $\beta$ in order to derive a contradiction.
As a result, $\enot\metaA\unisub{\beta}{\alpha}$ follows by negation introduction. 
Since $\beta$ does not occur in any undischarged assumptions, we may universally generalise on $\beta$ in order to derive the conclusion in line $6$. 

Consider the proof corresponding to $(\forall\enot)$: 

\begin{proof}
	\hypo{a}{\qt{\forall}{\alpha} \enot\metaA}      \pr{}
    \open
      \hypo{b}{\qt{\exists}{\alpha}\metaA}        \as{}
        \open
          \hypo{c}{\metaA\unisub{\beta}{\alpha}}  \by{$\exists$E where $\beta$ is a new constant}{b}
            \open
              \hypo{d}{\qt{\exists}{\alpha}\metaA}  \as{}
              \have{e}{\metaA\unisub{\beta}{\alpha}}  \r{c}
              \have{f}{\enot\metaA\unisub{\beta}{\alpha}}  \Ae{a}
            \close
          \have{g}{\enot\qt{\exists}{\alpha}\metaA}  \ni{d-f}
        \close
      \have{h}{\enot\qt{\exists}{\alpha}\metaA}  \Ee{b,c-g}
    \close
  \have{i}{\enot\qt{\exists}{\alpha}\metaA}       \ni{b-h}
\end{proof}

The proof begins as expected by stating the premise and assuming line $2$ for negation introduction. 
We then assume an instance of line $2$ in line $3$.
Although we could instantiate line $1$ on line $4$ in order to produce a contradiction with line $3$, this is not what we need.
Instead, we are looking to derive something which will contradict with line $2$ that does not include $\beta$. 
Accordingly, we assume line $4$ for negation introduction. 
We may now rewrite line $3$ in line $5$ and instantiate line $1$ on line $6$, producing a contradiction. 
By negation introduction on line $7$, we have what we wanted, and since $\beta$ does not occur in line $7$, we may close the subproof with existential elimination on line $8$.
The produces another contradiction, and so we may conclude in line $9$ with negation introduction. 

Although we could go on to prove $(\enot\forall)$ and $(\exists\enot)$ in a similar fashion, there is another approach which turns on the following \define{metarule} which takes one derivation to follow from another instead of taking one sentence to follow from some others.

\begin{enumerate}[leftmargin=.75in]
  \item[(MCP)] If $\metaA \proves \metaB$, then $\enot\metaB \proves \enot\metaA$.
\end{enumerate}

Given any $\metaA$ and $\metaB$, this rule says that if we can derive $\metaB$ from $\metaB$, then we may also derive $\enot\metaA$ from $\enot\metaB$, referring to this rule as \textit{meta-contraposition}.
It is worth comparing our standard contraposition rule CP which we derived before: $\metaA \eif \metaB \proves \enot\metaB \eif \enot\metaA$.
Whereas CP concerns the material conditional $\eif$, MCP concerns $\proves$.
Nevertheless, the proof is similar where we begin by assuming $\metaA \proves \metaB$ for some otherwise arbitrary sentences $\metaA$ and $\metaB$, calling this assumption $(\star)$.
We may then write the following proof:

\begin{proof}
	\hypo{a}{\enot\metaB}     \pr{}
    \open
      \hypo{b}{\metaA}      \as{}
      \have{c}{\metaB}      \by{$(\star)$}{}
      \have{d}{\enot\metaB} \r{a}
    \close
  \have{e}{\enot\metaA}     \ni{b-d}
\end{proof}

Since we know that $\metaA \proves \metaB$ by assumption, there is some proof of $\metaB$ from $\metaA$.
Accordingly, we may think of the proof given above as abbreviating a longer proof in which $(\star)$ is replaced with the proof of $\metaB$ from $\metaA$.
The result is a complete proof of $\enot\metaA$ from $\enot\metaB$. 

There are two more derived rules ($\forall$DN) and ($\exists$DN) which will come in handy:

\begin{multicols}{2}
  
\begin{proof}
	\hypo{a}{\qt{\forall}{\alpha} \enot\enot\metaA}   \pr{}
  \have{b}{\enot\enot\metaA\unisub{\beta}{\alpha}}  \Ae{a}
  \have{c}{\metaA\unisub{\beta}{\alpha}}            \by{DN}{b}
  \have{d}{\qt{\forall}{\alpha}\metaA}              \Ai{c}
\end{proof}

\begin{proof}
	\hypo{a}{\qt{\exists}{\alpha} \enot\enot\metaA}   \pr{}
    \open
      \hypo{b}{\enot\enot\metaA\unisub{\beta}{\alpha}}  \as{}
      \have{c}{\metaA\unisub{\beta}{\alpha}}            \by{DN}{b}
      \have{d}{\qt{\exists}{\alpha} \metaA}             \Ei{c}
    \close
  \have{e}{\qt{\exists}{\alpha} \metaA}             \Ee{a,b-d}
\end{proof}

\end{multicols}
% \vspace{-.1in}

We now have all the ingredients that we need to provide proofs which correspond to $(\enot\forall)$ and $(\exists\enot)$ from before.
Since these proofs will make essential use of MCP, these proofs will take place in the metalanguage and be presented informally.

\vspace{-.1in}
\begin{quote}
  $(\enot\forall)$:
  Consider the result of replacing $\metaA$ with $\enot\metaA$ in the proof of $(\enot\exists)$ given above, where this constitutes a proof of $\enot\qt{\exists}{\alpha}\enot\metaA \proves \qt{\forall}{\alpha}\enot\enot\metaA$.
  Since $\qt{\forall}{\alpha}\enot\enot\metaA \proves \qt{\forall}{\alpha}\metaA$ by $\forall$DN, we may chain these proofs together to derive $\enot\qt{\exists}{\alpha}\enot\metaA \proves \qt{\forall}{\alpha}\metaA$.
  If follows by MCP that $\enot\qt{\forall}{\alpha}\metaA \proves \enot\enot\qt{\exists}{\alpha}\enot\metaA$, and so $\enot\qt{\forall}{\alpha}\metaA \proves \qt{\exists}{\alpha}\enot\metaA$ by DN. 
  
  $(\exists\enot)$:
  Consider the result of replacing $\metaA$ with $\enot\metaA$ in the proof of $(\enot\forall)$ given above, where this constitutes a proof of $\enot\qt{\forall}{\alpha}\enot\metaA \proves \qt{\exists}{\alpha}\enot\enot\metaA$.
  Since $\qt{\exists}{\alpha}\enot\enot\metaA \proves \qt{\exists}{\alpha}\metaA$ by $\exists$DN, we may chain these proofs together to derive $\enot\qt{\forall}{\alpha}\enot\metaA \proves \qt{\exists}{\alpha}\metaA$.
  If follows by MCP that $\enot\qt{\exists}{\alpha}\metaA \proves \enot\enot\qt{\forall}{\alpha}\enot\metaA$, and so $\enot\qt{\exists}{\alpha}\metaA \proves \qt{\forall}{\alpha}\enot\metaA$ by DN. 
\end{quote}
\vspace{.1in}

You can think of these proofs as instruction manuals for constructing the appropriate derivations.
In this case, it might have been easier to provide derivations for $(\enot\forall)$ and $(\exists\enot)$ in the same manner that we did for $(\enot\exists)$ and $(\forall\enot)$.
Even so, the metarule MCP and derived rules ($\forall$DN) and ($\exists$DN) are important in their own right.
It is important to note, however, that whereas ($\forall$DN) and ($\exists$DN) may be applied in the course of a derivation, MCP cannot.
This is because MCP draws the conclusion $\enot\metaB \proves \enot\metaA$ from $\metaA \proves \metaB$, where the instances of these claims are not sentences in QL$^=$ since they include `$\proves$'.
It was for this reason that we provided informal proofs of $(\enot\forall)$ and $(\exists\enot)$ in the metalanguage. 

% \begin{proof}
% 	\hypo{Aa}{\qt{\forall}{y} Ay} \pr{want $\enot\qt{\exists}{y}\enot Ay$}
% 	\open
% 		\hypo{Ena}{\qt{\exists}{y}\enot Ay}\as{for reductio}
% 		\open
% 			\hypo{nc}{\enot Ac}\as{for $\exists$E}
% 			\open
% 				\hypo{Aa2}{\qt{\forall}{y} Ay}\as{for reductio}
% 				\have{c2}{Ac}\Ae{Aa}
% 				\have{nc2}{\enot Ac}\by{R}{nc}
% 			\close
% 			\have{nAa}{\enot\qt{\forall}{y} Ay}\ni{Aa2-nc2}
% 		\close
% 		\have{nAa3}{\enot\qt{\forall}{y} Ay}\Ee{Ena, nc-nAa}
% 		\have{Aa3}{\qt{\forall}{y} Ay}\by{R}{Aa}
% 	\close
% 	\have{nEna}{\enot\qt{\exists}{y}\enot Ay}\ni{Ena-Aa3, Ena-nAa3}
% \end{proof}







\section{Identity}

We turn now to the introduction and elimination rules for identity, both of which are a lot easier to work with than the quantifier rules.
To begin with, the introduction rule for identity is in keeping with the idea that everything is identical to itself.
Accordingly, for any constant $\alpha$, one may always write $\alpha = \alpha$ on any line of a proof.
Moreover, instead of \textit{assuming} $\alpha = \alpha$ for some particular constant $\alpha$ where this would constitute a further undischarged assumption, we may justify any instance of $\alpha = \alpha$ by citing the following rule: 

\begin{proof}
  \have[\ ]{a}{\alpha = \alpha} \by{:=I where $\alpha$ is a constant}{}
\end{proof}

The $=$I rule is unlike the other rules in that it does appeal to any prior lines of the proof.
Rather, $\alpha=\alpha$ is an axiom schema, meaning that for any constant $\alpha$, we may add $\alpha=\alpha$ to a proof without justification apart from citing $=$I itself. 
% Something similar may be said for the theorems we may derive

The elimination rule for identity is more complicated, but only slightly.
% Nevertheless, we will need a new piece of notation in order to articulate identity elimination.
%
% \factoidbox{
%    If $\beta$ is free for $\alpha$ in $\metaA$, then a \define{free substitution} $\metaA\freesub{\beta}{\alpha}$ is the result of replacing one or more free occurrences of $\alpha$ in $\metaA$ with $\beta$. 
% } %TODO move above to section on substitution; discuss why we should not state the quantifier rules with freesub
%
% Note the indefinite article `a' above where we refer to $\metaA\freesub{\beta}{\alpha}$ as \textit{a} free substitution of $\beta$ for $\alpha$ in $\metaA$. 
% This is because there could be multiple occurrences of $\alpha$ in $\metaA$ and since a free substitution of $\beta$ for $\alpha$ in $\metaA$ replaces one or more occurrences of $\alpha$ with $\beta$, there need not be unique result of replacing one or more such occurrence of $\alpha$ with $\beta$. 
% As a result, we cannot use identify ``the'' free substitution of $\beta$ for $\alpha$ in $\metaA$ as brought out by the following cases: 
%
% \begin{earg}
%   \item[\ex{F1}] $\forall x(Fxy \supset Fyx)\freesub{z}{y}=\forall x(Fxz \supset Fyx)$. ~~(\textsc{incorrect})
%   \item[\ex{F2}] $\forall x(Fxy \supset Fyx)\freesub{z}{y}=\forall x(Fxy \supset Fzx)$. ~~(\textsc{incorrect})
%   \item[\ex{F3}] $\forall x(Fxy \supset Fyx)\freesub{z}{y}=\forall x(Fxz \supset Fzx)$. ~~(\textsc{incorrect})
% \end{earg}
%
% The reason that the identities above must be avoided follows from the fact that the wffs on the left are all identical, but the wffs on the right are not.
% But distinct wffs cannot be identical to the same wff.
% Nevertheless, the following claims are true:
%
% \begin{earg}
%   % \item[\ex{F1}] $\forall x(Fxy \supset \exists yFyx)\freesub{z}{y}$.
%   \item[\ex{F4}] $\forall x(Fxz \supset Fyx)$ is a free substitution instance of $\forall x(Fxy \supset Fyx)\freesub{z}{y}$.
%   \item[\ex{F5}] $\forall x(Fxy \supset Fzx)$ is a free substitution instance of $\forall x(Fxy \supset Fyx)\freesub{z}{y}$.
%   \item[\ex{F6}] $\forall x(Fxz \supset Fzx)$ is a free substitution instance of $\forall x(Fxy \supset Fyx)\freesub{z}{y}$.
% \end{earg}
%
% Even though it could take a number of different forms, we will write $\metaA\freesub{\beta}{\alpha}$ to indicate a free substitution of $\beta$ for $\alpha$ in $\metaA$.
% We may now state the elimination rule for identity.
If you have derived $\metaA$ and $\alpha = \beta$ for some constants $\alpha$ and $\beta$, then we may replace any occurrence of $\alpha$ with $\beta$ in $\metaA$ and similarly, we may replace any occurrence of $\beta$ with $\alpha$ in $\metaA$.
More specifically, the identity elimination rules ($=$E) may be stated as follows:

\begin{multicols}{2}
  
\begin{proof}
  \have[m]{a}{\alpha = \beta} 
  \have[n]{b}{\metaA\unisub{\alpha}{\gamma}}
	\have[\ ]{c}{\metaA\unisub{\beta}{\gamma}} \by{=E}{a,b}
\end{proof}

\begin{proof}
  \have[m]{a}{\alpha = \beta} 
  \have[n]{b}{\metaA\unisub{\beta}{\gamma}}
	\have[\ ]{c}{\metaA\unisub{\alpha}{\gamma}} \by{=E}{a,b}
\end{proof}

\end{multicols}

It is important to note that not all occurrences of $\alpha$ (similarly $\beta$) need to be replaced with $\beta$ ($\alpha$) in any given $\metaA$.
The identity elimination rules capture this by including $\metaA\unisub{\alpha}{\gamma}$ and $\metaA\unisub{\beta}{\gamma}$.
For example, consider the following derivations:

\begin{proof}
  \hypo{a}{Raa} 
  \hypo{b}{a=b} 
  \have{c}{Rab} \by{$=$E}{a,b}
  \have{d}{Rba} \by{$=$E}{a,b} 
  \have{d}{Rbb} \by{$=$E}{a,b} 
  % \have{e}{Raa} \by{$=$E}{a,b} 
\end{proof}

Given the premises $Raa$ and $a=b$, we may derive $Rab$, $Rba$, and $Rbb$.
This is because $Raa=Rac\unisub{a}{c}=Rca\unisub{a}{c}=Rcc\unisub{a}{c}$, leading to the replacements $Rac\unisub{b}{c}=Rab$, $Rca\unisub{b}{c}=Rba$, and $Rcc\unisub{b}{c}=Rbb$, respectively.
Although the justifications for each inference is the same, the inferences are licensed on account of different values of $\metaA$.
% In practice, it is not always important to construct the appropriate value of $\metaA$ since it is easy to apply the existential elimination rules by simply replacing one constant with another.

Here is a proof that identity is transitive:

\begin{proof}
	\open
		\hypo{a}{a{=}b \eand b{=}c}\pr{}
		\have{b}{a{=}b} \ae{a}
		\have{c}{b{=}c} \ae{a}
		\have{d}{a{=}c}\by{$=$E}{b,c}
	\close
	\have{e}{(a = b \eand b = c)\eif a = c} \ci{a-d}
	\have{f}{\qt{\forall}{z}((a = b \eand b = z)\eif a = z)} \Ai{e}
	\have{g}{\qt{\forall}{y}\qt{\forall}{z}((a = y \eand y = z)\eif a = z)} \Ai{f}
	\have{h}{\qt{\forall}{x}\qt{\forall}{y}\qt{\forall}{z}((x = y \eand y = z)\eif x = z)} \Ai{g}
\end{proof}

At line $4$, we employed the identity claim $b = c$ on line $3$ in order to replace $b$ in line $2$ with a $c$.
After discharging the assumption with the conditional introduction rule, the rest of the proof proceeded by universal introduction given that $a$, $b$, and $c$ do not occur in any undischarged assumptions. 
A similar proof shows that identity is symmetric.

As a somewhat special case, it is worth considering a proof that identity is reflexive.

\begin{proof}
  \have{a}{a=a} \by{$=$I}{} 
  \have{b}{\qt{\forall}{x}(x=x)} \by{$\forall$I}{a}
\end{proof}

Notice that there is no horizontal line below line $1$.
This signifies that there is no premise.
Rather, identity introduction has been used in its unique capacity to introduce an identity claim which does not appeal to any other lines.
Accordingly, line $1$ is neither a premise nor assumption, and so the constant $a$ does not occur in any undischarged assumptions.
As a result, we may use universal introduction in order to conclude the proof.




\section{Proofs and Provability in QL$^=$}

We will refer to the natural deduction rules specified above together with the natural deduction rules provided in Ch.~\ref{ch.ND.proofs} as the natural deduction rules for QD.
We may then adapt the definition of a proof from before as follows:

\factoidbox{
  A natural deduction \define{proof} (or \define{derivation}) of a conclusion $\metaA$ from a set of premises $\Gamma$ in QD is any sequence of lines ending with $\metaA$ on a live line where every line in the sequence is either: (1) a premise in $\Gamma$; (2) a discharged assumption; or (3) follows from previous lines by one of the natural deduction rules for QD. 
}

A QL$^=$ sentence $\metaA$ is \define{provable} (or \define{derivable}) from $\Gamma$ in QD just in case there is a natural deduction proof (derivation) of $\metaA$ from $\Gamma$ in QD, where we may write this $\Gamma \proves_{\textsc{qd}} \metaA$, or just $\Gamma \proves \metaA$ when it is clear from context which proof system we intend. 

In keeping with the definitions given before, we will refer to a QL$^=$ sentence $\metaA$ as a \define{theorem} of QD just in case $\proves\metaA$, i.e., $\varnothing\proves\metaA$.
Since QD includes all the same rules and expressive resources of SD, all of the theorems of SD are also theorems of QD.
Put otherwise, QD is an \define{extension} of SD.
Two sentences $\metaA$ and $\metaB$ are \define{provably equivalent} (or \define{interderivable}) in QD if and only if both $\metaA\proves\metaB$ and $\metaB\proves\metaA$.
A set of sentences $\Gamma$ is \define{provably inconsistent} if and only if $\Gamma\proves\bot$ where $\bot$ is our arbitrarily chosen contradiction, e.g., $A\eand\enot A$.




\section{Soundness and Completeness of QD}

% In order to show that something is a theorem we have to derive it from no premises.
Recall from before the challenge of showing that a sentence is not a theorem.
Whereas providing a derivation of the sentence from no premises is all that is required to show that the sentence is a theorem, it is not possible to survey the space of all possible proofs to show that a sentence is not a theorem.
Instead, we may appeal to the following metalogical properties:

\factoidbox{
  \textsc{soundness:} $\Gamma \proves_{\textsc{qd}} \metaA$ only if $\Gamma \models \metaA$.
}\vspace{-.4in}
\factoidbox{
  \textsc{completeness:} $\Gamma \proves_{\textsc{qd}} \metaA$ if $\Gamma \models \metaA$.
}

In order to show that $\Gamma \nproves \metaA$, we may show that $\Gamma \nmodels \metaA$ by providing a model which satisfies $\Gamma$ but does not satisfy $\metaA$.
It then follows by soundness that $\Gamma \nproves \metaA$, and so there is no proof in QD of $\metaA$ from $\Gamma$.
This is a lot easier that attempting survey the entire space of possible proofs in QD.
In the case where $\Gamma=\varnothing$, we need only provide a countermodel to $\metaA$ in order to show that $\metaA$ is not a theorem, i.e., $\nproves \metaA$.

In the opposite direction, showing that $\Gamma \models \metaA$ is enough to conclude that $\Gamma \proves \metaA$ by appealing to completeness.
This tells us that there is a proof of $\metaA$ from the premises $\Gamma$, but it does not identify that proof for us.
Nevertheless, we know that there is good reason to look for one.

Recall the contrast between our two proof systems for SL.
Whereas attempting to prove that $\Gamma \proves_{\textsc{sd}} \metaA$ was not guaranteed to lead to a proof or to the conclusion that no proof exists, the tree method for SL always returned an answer. 
Given the soundness and completeness of the tree method for SL, we had an effective procedure for determining whether $\Gamma\models\metaA$ or not. 
Put otherwise, logical entailment is \define{decidable} in SL insofar as there is an effective procedure for determining in a finite number of steps whether $\Gamma \models \metaA$ or not given soundness and completeness.
By contrast, logical entailment in QL$^=$ is \define{undecidable} insofar as there is no such method for determining whether or not $\Gamma \models \metaA$.
Even though we may construct a tree method for QL$^=$, this method is not guaranteed to lead to either a positive or negative determination in the way that it did for SL.
This makes the tree method a lot less interesting for QL$^=$.
As a result, the following chapters will establish soundness and completeness for QD rather than for an extension of the tree method for QL$^=$.



\iffalse

\practiceproblems

\solutions
\problempart
\label{pr.justifyQLproof}
Provide a justification (rule and line numbers) for each line of proof that requires one.
\begin{multicols}{2}
%$\{\qt{\forall}{x}(\qt{\exists}{y})(Rxy \eor Ryx),\qt{\forall}{x}\enot Rmx\}\vdash\qt{\exists}{x}Rxm$
\begin{proof}
\hypo{p1}{\qt{\forall}{x}\qt{\exists}{y}(Rxy \eor Ryx)}
\have{p2}{\qt{\forall}{x}\enot Rmx}
\have{3}{\qt{\exists}{y}(Rmy \eor Rym)}{}
	\open
		\hypo{a1}{Rma \eor Ram}
		\have{a2}{\enot Rma}{}
		\have{a3}{Ram}{}
		\have{a4}{\qt{\exists}{x} Rxm}{}
	\close
\have{n}{\qt{\exists}{x} Rxm} {}
\end{proof}

%$\{\qt{\forall}{x}(\qt{\exists}{y}Lxy \eif \qt{\forall}{z}Lzx), Lab\} \vdash \qt{\forall}{x}Lxx$
\begin{proof}
\hypo{1}{\qt{\forall}{x}(\qt{\exists}{y}Lxy \eif \qt{\forall}{z}Lzx)}
\hypo{2}{Lab}
\have{3}{\qt{\exists}{y} Lay \eif \qt{\forall}{z}Lza}{}
\have{4}{\qt{\exists}{y} Lay} {}
\have{5}{\qt{\forall}{z} Lza} {}
\have{6}{Lca}{}
\have{7}{\qt{\exists}{y} Lcy \eif \qt{\forall}{z}Lzc}{}
\have{8}{\qt{\exists}{y} Lcy}{}
\have{9}{\qt{\forall}{z} Lzc}{}
\have{10}{Lcc}{}
\have{11}{\qt{\forall}{x} Lxx}{}
\end{proof}


% $\{\qt{\forall}{x}(Jx \eif Kx), \qt{\exists}{x}\qt{\forall}{y} Lxy, \qt{\forall}{x} Jx\} \vdash \qt{\exists}{x}(Kx \eand Lxx)$
\begin{proof}
\hypo{a}{\qt{\forall}{x}(Jx \eif Kx)}
\hypo{b}{\qt{\exists}{x}\qt{\forall}{y} Lxy}
\hypo{c}{\qt{\forall}{x} Jx}
\open
	\hypo{2}{\qt{\forall}{y} Lay}
	\have{d}{Ja}{}
	\have{e}{Ja \eif Ka}{}
	\have{f}{Ka}{}
	\have{3}{Laa}{}
	\have{4}{Ka \eand Laa}{}
	\have{5}{\qt{\exists}{x}(Kx \eand Lxx)}{}
\close
\have{j}{\qt{\exists}{x}(Kx \eand Lxx)}{}
\end{proof}


%$\vdash \qt{\exists}{x} Mx \eor \qt{\forall}{x}\enot Mx$
\begin{proof}
	\open
		\hypo{p1}{\enot (\qt{\exists}{x} Mx \eor \qt{\forall}{x}\enot Mx)}
		\have{p2}{\enot \qt{\exists}{x} Mx \eand \enot \qt{\forall}{x}\enot Mx}{}
		\have{p3}{\enot \qt{\exists}{x} Mx}{}
		\have{p4}{\qt{\forall}{x}\enot Mx}{}
		\have{p5}{\enot \qt{\forall}{x}\enot Mx}{}
	\close
\have{n}{\qt{\exists}{x} Mx \eor \qt{\forall}{x}\enot Mx} {}
\end{proof}
\end{multicols}

\solutions
\problempart
\label{pr.someQLproofs}
Provide a natural deduction proof of each claim.
\begin{earg}
\item $\vdash \qt{\forall}{x} Fx \eor \enot \qt{\forall}{x} Fx$
\item $\{\qt{\forall}{x}(Mx \eiff Nx), Ma\eand\qt{\exists}{x} Rxa\}\vdash \qt{\exists}{x} Nx$
\item $\{\qt{\forall}{x}(\enot Mx \eor Ljx), \qt{\forall}{x}(Bx\eif Ljx), \qt{\forall}{x}(Mx\eor Bx)\}\vdash \qt{\forall}{x}Ljx$
\item $\qt{\forall}{x}(Cx \eand Dt)\vdash \qt{\forall}{x}Cx \eand Dt$
\item $\qt{\exists}{x}(Cx \eor Dt)\vdash \qt{\exists}{x} Cx \eor Dt$
\end{earg}

\problempart
Provide a proof of the argument about Billy on p.~\pageref{surgeon2}.



\problempart
\label{pr.BarbaraEtc.proof1}
Look back at Part \ref{pr.BarbaraEtc} on p.~\pageref{pr.BarbaraEtc}. Provide proofs to show that each of the argument forms is valid in QL.




\solutions
\problempart
\label{pr.QLproofsNDe}
Provide a natural deduction proof of each claim.
\begin{earg}
\item $\qt{\forall}{x} \qt{\forall}{y} Gxy\vdash\qt{\exists}{x} Gxx$
\item $\qt{\forall}{x} \qt{\forall}{y} (Gxy \eif Gyx) \vdash \qt{\forall}{x}\qt{\forall}{y} (Gxy \eiff Gyx)$
\item $\{\qt{\forall}{x}(Ax\eif Bx), \qt{\exists}{x} Ax\} \vdash \qt{\exists}{x} Bx$
\item $\{Na \eif \qt{\forall}{x}(Mx \eiff Ma), Ma, \enot Mb\}\vdash \enot Na$
\item $\vdash\qt{\forall}{z} (Pz \eor \enot Pz)$
\item $\vdash\qt{\forall}{x} Rxx\eif \qt{\exists}{x} \qt{\exists}{y} Rxy$
\item $\vdash\qt{\forall}{y} \qt{\exists}{x} (Qy \eif Qx)$
\end{earg}



\problempart
Show that each pair of sentences is provably equivalent.
\begin{earg}
\item $\qt{\forall}{x} (Ax\eif \enot Bx)$, $\enot\qt{\exists}{x}(Ax \eand Bx)$
\item $\qt{\forall}{x} (\enot Ax\eif Bd)$, $\qt{\forall}{x} Ax \eor Bd$
\item $\qt{\exists}{x} Px \eif Qc$, $\qt{\forall}{x} (Px \eif Qc)$
\end{earg}



\problempart
Show that each of the following is provably inconsistent.
\begin{earg}
\item \{$Sa\eif Tm$, $Tm \eif Sa$, $Tm \eand \enot Sa$\}
\item \{$\enot\qt{\exists}{x} Rxa$, $\qt{\forall}{x} \qt{\forall}{y} Ryx$\}
\item \{$\enot\qt{\exists}{x} \qt{\exists}{y} Lxy$, $Laa$\}
\item \{$\qt{\forall}{x}(Px \eif Qx)$, $\qt{\forall}{z}(Pz \eif Rz)$, $\qt{\forall}{y} Py$, $\enot Qa \eand \enot Rb$\}
\end{earg}



\solutions
\problempart
\label{pr.likes}
Write a symbolization key for the following argument, translate it, and prove it:
\begin{quote}
There is someone who likes everyone who likes everyone that first person likes. Therefore, there is someone who likes themself.
\end{quote}

\problempart
\label{pr.identity}
Provide a proof of each claim.
\begin{earg}
\item $\{Pa \eor Qb, Qb \eif b{=}c, \enot Pa\}\vdash Qc$
\item $\{m{=}n \eor n{=}o, An\}\vdash Am \eor Ao$
\item $\{\qt{\forall}{x} \: x{=}m, Rma\}\vdash \qt{\exists}{x} Rxx$
\item $\enot \qt{\exists}{x} \: x {\neq} m \vdash \qt{\forall}{x}\qt{\forall}{y} (Px \eif Py)$
\item $\qt{\forall}{x}\qt{\forall}{y}(Rxy \eif x{=}y)\vdash Rab \eif Rba$
\item $\{\qt{\exists}{x} Jx, \qt{\exists}{x} \enot Jx\}\vdash \qt{\exists}{x} \qt{\exists}{y}\ x{\neq} y$
\item $\{\qt{\forall}{x}(x{=}n \eiff Mx), \qt{\forall}{x}(Ox \eor \enot Mx)\}\vdash On$
\item $\{\qt{\exists}{x} Dx, \qt{\forall}{x}(x{=}p \eiff Dx)\}\vdash Dp$
\item $\{\qt{\exists}{x}\bigl[Kx \eand \qt{\forall}{y}(Ky \eif x{=}y) \eand Bx\bigr], Kd\}\vdash Bd$
\item $\vdash Pa \eif \qt{\forall}{x}(Px \eor x {\neq} a)$
\end{earg}



\solutions
\problempart
\label{pr.QLequivornot}
For each of the following pairs of sentences: If they are logically equivalent in QL, give proofs to show this. If they are not, construct a model to show this.
% TODO: this isn't a great problem set in the context, as ND isn't an appropriate method for demonstrating invalidity. Figure out what to do about this.
\begin{earg}
\item $\qt{\forall}{x} Px \eif Qc$, $\qt{\forall}{x} (Px \eif Qc)$
\item $\qt{\forall}{x} Px \eand Qc$, $\qt{\forall}{x} (Px \eand Qc)$
\item $Qc \eor \qt{\exists}{x} Qx$, $\qt{\exists}{x} (Qc \eor Qx)$
\item $\qt{\forall}{x}\qt{\forall}{y} \qt{\forall}{z} Bxyz$, $\qt{\forall}{x} Bxxx$
\item $\qt{\forall}{x}\qt{\forall}{y} Dxy$, $\qt{\forall}{y}\qt{\forall}{x} Dxy$
\item $\qt{\exists}{x}\qt{\forall}{y} Dxy$, $\qt{\forall}{y}\qt{\exists}{x} Dxy$
\end{earg}

\solutions
\problempart
\label{pr.QLvalidornot}
For each of the following arguments: If it is valid in QL, give a proof. If it is invalid, construct a model to show that it is invalid.
% TODO: this isn't a great problem set in the context, as ND isn't an appropriate method for demonstrating invalidity. Figure out what to do about this.
\begin{earg}
\item $\qt{\forall}{x}\qt{\exists}{y} Rxy$, \therefore\ $\qt{\exists}{y}\qt{\forall}{x} Rxy$
\item $\qt{\exists}{y}\qt{\forall}{x} Rxy$, \therefore\ $\qt{\forall}{x}\qt{\exists}{y} Rxy$
\item $\qt{\exists}{x}(Px \eand \enot Qx)$, \therefore\ $\qt{\forall}{x}(Px \eif \enot Qx)$
\item $\qt{\forall}{x}(Sx \eif Ta)$, $Sd$, \therefore\ $Ta$
\item $\qt{\forall}{x}(Ax\eif Bx)$, $\qt{\forall}{x}(Bx \eif Cx)$, \therefore\ $\qt{\forall}{x}(Ax \eif Cx)$
\item $\qt{\exists}{x}(Dx \eor Ex)$, $\qt{\forall}{x}(Dx \eif Fx)$, \therefore\ $\qt{\exists}{x}(Dx \eand Fx)$
\item $\qt{\forall}{x}\qt{\forall}{y}(Rxy \eor Ryx)$, \therefore\ $Rjj$
\item $\qt{\exists}{x}\qt{\exists}{y}(Rxy \eor Ryx)$, \therefore\ $Rjj$
\item $\qt{\forall}{x} Px \eif \qt{\forall}{x} Qx$, $\qt{\exists}{x} \enot Px$, \therefore\ $\qt{\exists}{x} \enot Qx$
\item $\qt{\exists}{x} Mx \eif \qt{\exists}{x} Nx$, $\enot \qt{\exists}{x} Nx$, \therefore\ $\qt{\forall}{x} \enot Mx$
\end{earg}

\problempart
\label{pr.QLND.trees1}
Look at the arguments given in Chapter \ref{ch.QLTrees}, Problem Part \ref{pr.QL.trees.translation.and.validity} (page \pageref{pr.QL.trees.translation.and.validity}). For those arguments whose QL translations are valid, prove their validity via natural deduction.

\problempart
\label{pr.QLND.trees2}
Look at the entailment claims given in Chapter \ref{ch.identity}, Problem Part \ref{pr.IdentityTrees} (page \pageref{pr.IdentityTrees}). For those entailment claims that are true, prove them via natural deduction.

\problempart
\label{pr.QLND.trees3}
Look at the arguments given in Chapter \ref{ch.identity}, Problem Part \ref{pr.IdentityArguments} (page \pageref{pr.IdentityArguments}). For those arguments whose QL translations are valid, prove their validity via natural deduction.

\fi
