%!TEX root = ../forallx-ubc.tex
\chapter{Truth Tables}
\label{ch.TruthTables}

This chapter introduces a way of evaluating sentences and arguments of SL.
The truth table method is a purely mechanical procedure that requires no intuition or special insight.
Given the (albeit limited) translatability of English into SL, this also amounts to a formal way of evaluating at least some natural language arguments.




\section{Truth-Functional Connectives}

Any sentence of SL that is not a sentence letter is composed of sentence letters together with the sentential connectives.
In Ch. \ref{ch.SL}, we offered truth tables for each connective.
The fact that it is possible to give truth tables like this is very significant.
It means that our connectives are \define{truth-functional}.
That is to say, the only thing that matters for determining the truth value of a given sentence of SL is the truth values of its constituent parts.
To determine the truth value of a sentence $\enot A$, the only thing that matters is the truth value of $A$.
% You don't have to know what $A$ means, or where it came from, or what evidence there is for it and what that evidence might depend on.
Given any interpretation, the truth-value of a negation on that interpretation is a \emph{function} of the truth-value of its negand on that interpretation, and likewise for the other connectives.

We are using the same notion of a \define{function} that you have probably encountered in mathematics.
A function from one set to another associates each member of the first set (the domain) with exactly one member of the second set (the range).
Once the first element is fixed, the function uniquely selects an element of the second set.
For instance, any given numerical value of $x$ will unambiguously determine the value of $x^{2}$, so $f(x)=x^{2}$ is a function.
In the same way, the truth value of $A$ on an interpretation will unambiguously determine the truth value of $\enot A$ on that interpretation.

Truth-functionality is not inevitable.
The syntax of English, for example, permits one to make a new, more complex English declarative sentence by prefixing the phrase `Ted Cruz doesn't care whether' in front of any declarative English sentence.
In this respect this phrase is syntactically similar to `\enot' in SL.
But it is impossible to give a truth-functional characterization of the `Ted Cruz doesn't care whether' operator in English that respects its intuitive meaning in English.
If you want to know whether Ted Cruz cares about fixing Texas's electrical grid, it's not enough to know whether anyone is fixing Texas's electrical grid.
If it is being fixed, he might or might not care; if it isn't be fixed, he might or might not care. 
`Ted Cruz doesn't care whether' is not truth-functional.
But all the connectives of SL are truth-functional: it operates on more than just the truth-value of its argument.\footnote{Recall the other meaning that `argument' has from $\S\ref{sec.Bicon}$.}
By contrast, the sentential connectives included in SL are truth-functional, and it is for this reason that we can construct truth tables to determine the logical features of SL sentences.



\section{Complete Truth Tables}

A truth table for a sentence may be constructed by writing the sentence in question at the top right of a table, and each of the distinct sentence letters immediately to the left on the top row.
We then add $2^n$ rows below the top row where $n$ is the number of distinct sentence letters. 
For instance, if there are only two sentence letters, we will need four rows of truth-values.
Beginning with the sentence letter furthest to the left, we fill out the column with $2^{(n-1)}$ copies of 1 followed by $2^{(n-1)}$ copies of 0.
Moving to the next sentence letter, we fill out the column with $2^{(n-2)}$ copies of 1 followed by $2^{(n-2)}$ copies of 0, and then repeating until all rows in the column are filled.
We then proceed to the next sentence letter (if there is one), following the same pattern as before but with $2^{(n-3)}$ copies of 1 and 0, respectively.
Continue this process until all sentence letters in the table have truth-values below them.

In order to get a more concrete sense of this, we may begin with the following characteristic truth tables where instead of particular sentence letters, we will use metalinguistic variables:

\begin{table}[htb]
\begin{center}
\begin{tabular}{c|c}
\metaA{} & \enot\metaA{}\\
\hline
1 & 0\\
0 & 1 
\end{tabular}
\ \ \ \ 
\begin{tabular}{c|c|c|c|c|c}
\metaA{} & \metaB{} & $\metaA{}\eand\metaB{}$ & $\metaA{}\eor\metaB{}$ & $\metaA{}\eif\metaB{}$ & $\metaA{}\eiff\metaB{}$\\
\hline
1 & 1 & 1 & 1 & 1 & 1\\
1 & 0 & 0 & 1 & 0 & 0\\
0 & 1 & 0 & 1 & 1 & 0\\
0 & 0 & 0 & 0 & 1 & 1
\end{tabular}
\end{center}
\caption{The characteristic truth tables for the connectives of SL.}
\label{table.CharacteristicTTs}
\end{table}

The table above provides a general recipe for calculating truth-values for any sentences \metaA{} and \metaB{}, however complex.
The characteristic truth table for conjunction, for example, gives the truth conditions for any sentence of the form $\metaA{}\eand\metaB{}$.
Even if the conjuncts \metaA{} and \metaB{} are long, complicated sentences, the conjunction is true if and only if both \metaA{} and \metaB{} are true.

Let's construct a truth table for a more complicated sentence.
For instance, consider the sentence $(H\eand I)\eif H$.
We consider all the possible combinations of true and false for $H$ and $I$, which gives us four rows.
We then copy the truth-values for the sentence letters and write them underneath the letters in the sentence.
\begin{center}
\begin{tabular}{c|c|@{\TTon}*{5}{c}@{\TToff}}
$H$&$I$&$(H$&\eand&$I)$&\eif&$H$\\
\hline
 1 & 1 & \TTbf{1} && \TTbf{1} && \TTbf{1}\\
 1 & 0 & \TTbf{1} && \TTbf{0} && \TTbf{1}\\
 0 & 1 & \TTbf{0} && \TTbf{1} && \TTbf{0}\\
 0 & 0 & \TTbf{0} && \TTbf{0} && \TTbf{0}
\end{tabular}
\end{center}
So far all we've done is duplicate the first two columns. We've written the `H' column twice --- once under each `H', and the `I' column once, under the `I'.

Now consider the subsentence $H\eand I$ which is a conjunction. 
Since $H$ and $I$ are both true on the first row, and a conjunction is true when both conjuncts are true, we write a 1 underneath the conjunction symbol.
In the other three rows, at least one of the conjuncts is false, so the conjunction $H \eand I$ is false.
So we write 0s under the conjunction symbol on those rows:
\begin{center}
\begin{tabular}{c|c|@{\TTon}*{5}{c}@{\TToff}}
$H$&$I$&$(H$&\eand&$I)$&\eif&$H$\\
\hline
 1 & 1 & 1 & \TTbf{1} & 1 & & 1\\
 1 & 0 & 1 & \TTbf{0} & 0 & & 1\\
 0 & 1 & 0 & \TTbf{0} & 1 & & 0\\
 0 & 0 & 0 & \TTbf{0} & 0 & & 0
\end{tabular}
\end{center}
The entire sentence $(H \eand I) \eif H$ is a conditional.
On the second row, for example, $H\eand I$ is false and $H$ is true.
Since a conditional is true when the antecedent is false, we write a 1 in the second row underneath the conditional symbol.
Using the truth table for the material conditional where $H \eand I$ is the antecedent and $H$ as the consequent, we may derive the following values for the material conditional claim as a whole:
\begin{center}
\begin{tabular}{c|c|@{\TTon}*{5}{c}@{\TToff}}
$H$&$I$&$(H$&\eand&$I)$&\eif&$H$\\
\hline
 1 & 1 & & 1 & & \TTbf{1} & 1\\
 1 & 0 & & 0 & & \TTbf{1} & 1\\
 0 & 1 & & 0 & & \TTbf{1} & 0\\
 0 & 0 & & 0 & & \TTbf{1} & 0
\end{tabular}
\end{center}
In computing the value for the conditional (the column under $\eif$), it is only important to look at the values for its antecedent (the column under $\eand$) and the value of its consequent (the column under $H$ on the right).
The column of 1s underneath the conditional tells us that the sentence $(H \eand I)\eif H$ is true regardless of the truth-values of $H$ and $I$.
They can be true or false in any combination, and the compound sentence still comes out true.
It is crucial that we have considered all of the possible combinations.
If we only had a two-line truth table, we could not be sure that the sentence was not false for some other combination of truth-values.
Since each row of the truth table represents a different way of interpreting the relevant sentence letters $H$ and $I$, each row corresponds to a distinct interpretation of the sentence letters in question. 
Moreover, every possible combination of truth-values for $H$ and $I$ have been included.
Since the truth-values of all other sentence letters does not effect the truth-value of the sentence in question, we may conclude that $(H \eand I)\eif H$ is \textit{true in all interpretations} whatsoever.
In other words, $(H \eand I)\eif H$ is a \textit{tautology}.

In this example, we have not repeated all of the entries in every successive table, so that it's easier for you to see which parts are new. When actually writing truth tables on paper, however, it is impractical to erase whole columns or rewrite the whole table for every step. Although it is more crowded, the truth table can be written in this way:
\begin{center}
\begin{tabular}{c|c|@{\TTon}*{5}{c}@{\TToff}}
$H$&$I$&$(H$&\eand&$I)$&\eif&$H$\\
\hline
 1 & 1 & 1 & {1} & 1 &\TTbf{1} & 1\\
 1 & 0 & 1 & {0} & 0 &\TTbf{1} & 1\\
 0 & 1 & 0 & {0} & 1 &\TTbf{1} & 0\\
 0 & 0 & 0 & {0} & 0 &\TTbf{1} & 0
\end{tabular}
\end{center}
Most of the columns underneath the sentence are only there for bookkeeping purposes. When you become more adept with truth tables, you will probably no longer need to copy over the columns for each of the sentence letters. In any case, the truth-value of the sentence on each row is just the column underneath the main logical operator of the sentence; in this case, the column underneath the conditional. We've marked it in \textbf{bold}.

A \define{complete truth table} has a row for all the possible combinations of 1 and 0 for all of the sentence letters. The size of the complete truth table depends on the number of different sentence letters in the table. A sentence that contains only one sentence letter requires only two rows, as in the characteristic truth table for negation. This is true even if the same letter is repeated many times, as in the sentence
$[(C\eiff C) \eif C] \eand \enot(C \eif C)$.
The complete truth table requires only two lines because there are only two possibilities: $C$ can be true or it can be false. A single sentence letter can never be marked both 1 and 0 on the same row. The truth table for this sentence looks like this:
\begin{center}
\begin{tabular}{c|@{\TTon}*{15}{c}@{\TToff}}
$C$&$[($&$C$&\eiff&$C$&$)$&\eif&$C$&$]$&\eand&\enot&$($&$C$&\eif&$C$&$)$\\
\hline
 1 &    & 1 &  1  & 1 &   & 1  & 1 & &\TTbf{0}&  0& &   1 &  1  & 1 &   \\
 0 &    & 0 &  1  & 0 &   & 0  & 0 & &\TTbf{0}&  0& &   0 &  1  & 0 &   \\
\end{tabular}
\end{center}
Looking at the column underneath the main connective, we see that the sentence is false on both rows of the table; i.e., it is false regardless of whether $C$ is true or false.
Since the rows of the truth table correspond to the different possible interpretations of the relevant sentence letters, the sentence above is false on all interpretations, and so a \textit{contradiction}.

A sentence that contains two sentence letters requires $2\times 2=$ four lines for a complete truth table, as in the other characteristic truth tables and the table for $(H \eand I)\eif I$ above.
A sentence that contains three sentence letters requires $2\times 2\times 2=$ eight lines. For example:
  
\begin{center}
\begin{tabular}{c|c|c|@{\TTon}*{5}{c}@{\TToff}}
$M$&$N$&$P$&$M$&\eand&$(N$&\eor&$P)$\\
\hline
%           M        &     N   v   P
1 & 1 & 1 & 1 & \TTbf{1} & 1 & 1 & 1\\
1 & 1 & 0 & 1 & \TTbf{1} & 1 & 1 & 0\\
1 & 0 & 1 & 1 & \TTbf{1} & 0 & 1 & 1\\
1 & 0 & 0 & 1 & \TTbf{0} & 0 & 0 & 0\\
0 & 1 & 1 & 0 & \TTbf{0} & 1 & 1 & 1\\
0 & 1 & 0 & 0 & \TTbf{0} & 1 & 1 & 0\\
0 & 0 & 1 & 0 & \TTbf{0} & 0 & 1 & 1\\
0 & 0 & 0 & 0 & \TTbf{0} & 0 & 0 & 0
\end{tabular}
\end{center}
From this table, we know that the sentence $M\eand(N\eor P)$ might be true or false, depending on the truth-values of $M$, $N$, and $P$.
Put otherwise, $M\eand(N\eor P)$ is true on some interpretations and false on others, and so it is \textit{contingent}.

Recall that a complete truth table with $n$ sentence letters will have $2^n$ rows.
A complete truth table for a sentence that contains four different sentence letters requires 16 lines.
This means that the truth table method becomes syntactically unmanageable very quickly.
By contrast, the semantic clauses can much more easily accommodate sentences and arguments with many sentence letters.





\section{Using Truth Tables}
\label{sec.usingtruthtables}

\subsection{Tautologies, contradictions, and contingent sentences}

Recall from \S\ref{sec-tautologydef} that an English sentence is a tautology if it true on all interpretations.
Equivalently, we may define a \define{tautology} of SL is any sentence of SL whose truth table only has 1s under its main connective.
Accordingly, a tautology is a sentence of SL whose truth does not depend on the particular truth-values of the sentence letters from which it was built, but rather follows from the \textit{logical form} of that sentence.
Similarly, we could define a sentence as a \define{contradiction} in SL just in case the column under its main connective is 0 on every row of a complete truth table.
Instead of being true in virtue of its logical form, a contradiction is false in virtue of its logical form.
Recall that a sentence is \define{contingent} in SL if it is neither a tautology nor a contradiction.
Thus the contingent sentences of SL will have 1 on at least one row while also having 0 on at least one row.



\subsection{Logical equivalence}

Two sentences are logically equivalent in English if they have the same truth value on all interpretations.
Alternatively, we could define two sentences to be \define{logically equivalent} in SL if the truth-values under their main connectives are the same on every row of a complete truth table.
Since the rows of a complete truth table exhaust the different interpretations of the relevant sentence letters, this amounts to requiring the two sentences of SL to have the same truth-value on every interpretation.

Consider the sentences $\enot(A \eor B)$ and $\enot A \eand \enot B$.
Are they logically equivalent? 
To find out, we construct a composite truth table which includes both sentences.
\begin{center}
\begin{tabular}{c|c|@{\TTon}*{4}{c}@{\TToff}|@{\TTon}*{5}{c}@{\TToff}}
$A$&$B$&\enot&$(A$&\eor&$B)$&\enot&$A$&\eand&\enot&$B$\\
\hline
 1 & 1 & \TTbf{0} & 1 & 1 & 1 & 0 & 1 & \TTbf{0} & 0 & 1\\
 1 & 0 & \TTbf{0} & 1 & 1 & 0 & 0 & 1 & \TTbf{0} & 1 & 0\\
 0 & 1 & \TTbf{0} & 0 & 1 & 1 & 1 & 0 & \TTbf{0} & 0 & 1\\
 0 & 0 & \TTbf{1} & 0 & 0 & 0 & 1 & 0 & \TTbf{1} & 1 & 0
\end{tabular}
\end{center}
Look at the columns for the main connectives; negation for the first sentence, conjunction for the second. On the first three rows, both are 0. On the final row, both are 1. Since they match on every row, the two sentences are logically equivalent.





\subsection{Consistency}
\label{sub:consistency}

Recall that a set of sentences in English is consistent if there is an interpretation which makes them all true at once.
Thus we may say that a set of sentences in SL is \define{consistent} just in case there is at least one line of a complete truth table including every sentence in the set on which all of the sentences are true, and \define{inconsistent} otherwise.
For instance, look again at the truth table above.
We can see that $\enot(A \eor B)$ and $\enot A \eand \enot B$ are consistent, because there is at least one row, namely the last one, where both are assigned true.

To take another example, are $A$, $B$, and $\enot A \eand \enot B$ logically consistent?
No.
If they were, there would have to be a row where all three sentences are assigned true.
But examination of the truth table above reveals that there is no such row, i.e., no such interpretation.





\subsection{Validity}
\label{sub:validity}
 
So far we have identified the rows of a truth-table for a relevant sentence, or set of sentences, with the relevant range of interpretations for that sentence, or set of sentences.
Of course, truth tables are finite in size, and so cannot specify truth-values for every sentence letter whatsoever, much less for every sentence of SL.
Rather, the rows of a truth table provide partial interpretations of SL by specifying all combinations of truth-values for some finite set of sentence letters.
Insofar as the truth table includes all of the sentence letters that occur in the sentence(s) in question, the truth-values for all other sentence letters do not make a difference, and so may be safely ignored.
Nevertheless, we cannot define the interpretations of SL as the rows of a truth table since no finite truth table specifies truth-values for every sentence letter.
This motivates a slightly more general approach.

Officially, we will take an \define{interpretation} of SL to be any function $\I$ which maps sentence letters to truth-values, thereby assigning every sentence letter to exactly one truth-value (either 1 or 0).
Although interpretations only specify the truth-values of sentence letters, we may extend the domain of an interpretation to all sentences of SL by appealing to the characteristic truth tables given above.
Somewhat more precisely, we may use any interpretation $\I$ to recursively define a \define{valuation} function $\V{\I}$ by way of the following semantic clauses for the connectives included in SL:

\begin{enumerate}[labelsep=.15in]
  \item[($A$)] $\V{\I}(\metaA{})=\I(\metaA{})$ just in case $\metaA{}$ is a sentence letter of SL.
  \item[(\enot)] $\V{\I}(\enot\metaA{})=1$ just in case $\V{\I}(\metaA{})=0$.
  \item[(\eor)] $\V{\I}(\metaA{} \eor \metaB{})=1$ just in case $\V{\I}(\metaA{})=1$ or $\V{\I}(\metaB{})=1$ (or both).
  \item[(\eand)] $\V{\I}(\metaA{} \eand \metaB{})=1$ just in case $\V{\I}(\metaA{})=1$ and $\V{\I}(\metaB{})=1$.
  \item[(\eif)] $\V{\I}(\metaA{} \eif \metaB{})=1$ just in case $\V{\I}(\metaA{})=0$ or $\V{\I}(\metaB{})=1$ (or both).
  \item[(\eiff)] $\V{\I}(\metaA{} \eiff \metaB{})=1$ just in case $\V{\I}(\metaA{})=\V{\I}(\metaB{})$.
\end{enumerate}

The clauses above hold for all sentences \metaA{} and \metaB{} of SL, thereby extending any interpretation $\I$ of SL to $\V{\I}$ which specifies unique truth-values for every sentence of SL.
Whereas the characteristic truth tables for the connectives specifies the truth-values of complex sentences visually, the semantic clauses specify the same information functionally.

Formal languages are built from three kinds of elements: \define{logical symbols}, \define{non-logical symbols}, and \define{punctuation} i.e., the left and right parentheses.
Connectives like `\eand' and `\eif' are logical symbols (also called \define{logical constants}) because their meaning is specified by semantic clauses which hold their meanings fixed.
When interpreting a formal argument, you are not allowed to change the meaning of the logical symbols.
You cannot say, for instance, that the `\enot' symbol will mean what `\eand' usually does.
Rather, the `\enot' symbol will always have the same semantic clause, and so will always express negation.

The sentence letters in SL are non-logical symbols because their meaning is not specified by the semantics for SL.
When we translate an argument from English into SL, the sentence letter `$M$' (for example) does not have its meaning fixed as a result.
Instead, we rely on interpretations to assign truth-values to `$M$' (and all other sentence letters), where the truth-values provide a rough way to model what those sentence letters mean.

An argument in SL is \define{logically valid} just in case for every interpretation $\I$ of SL, if the valuation $\V{\I}$ makes the premises true (i.e., $\V{\I}(\metaA{})=1$ for every premise $\metaA{}$), then $\V{\I}$ also makes the conclusion true (i.e., $\V{\I}(\metaB{})=1$ where $\metaB{}$ is the conclusion).
Alternatively, we could take an argument in SL to be \define{logically valid} just in case every line in a complete truth table which includes every sentence in the argument is such that if the premises are true on that line, the conclusion is also true on that line.
Even though the lines of a truth table do not specify truth-values for all sentence letters of SL, only the sentence letters that occur in the argument are relevant, and so the truth-values of all other sentence letters may be safely ignored.
Accordingly, these two definitions are equivalent.
Nevertheless, it is definitionally simpler to quantify over all interpretations $\I$ of SL rather than the lines of an appropriately constructed complete truth table for the argument in question.

It will often be convenient to drop `logically' from `logically valid' and to leave reference to the valuation function corresponding to an interpretation implicit.
Given these simplifications, it follows by the lights of the first definition of validity that an argument in SL is valid just in case there is no interpretation $\I$ of SL in which the premises are true and the conclusion is false.\footnote{Or more completely, it follows that an argument in SL is valid just in case there is no interpretation $\I$ where $\V{\I}(\metaA{})=1$ for every premise $\metaA{}$ and yet $\V{\I}(\metaB{})=1$ for the conclusion $\metaB{}$.}
Accordingly, an argument whose premises are inconsistent is \textit{vacuously valid} since there is no interpretation $\I$ in which its premises are true, and so trivially no interpretation $\I$ in which its premises are true and its conclusion is false.
For instance, consider:
    
\begin{earg}
  \item[] $\neg A \eand B$
  \item[] $\enot B$
  \item[\therefore] $B$
\end{earg}

Is it valid? 
Ask yourself if there's a way for the two premises to be 1 while the conclusion is 0.
To check your work, we can construct the following truth table:

\begin{center}
\begin{tabular}{c|c|@{\TTon}*{4}{c}@{\TToff}|@{\TTon}*{2}{c}@{\TToff}|c}
  $A$&$B$&\enot&$A$&\eand&$B$&\enot&B&B\\
\hline
% A   B   -   A      &       B         -    B     B     
  1 & 1 & 0 & 1 & \TTbf{0} & 1 & \TTbf{0} & 1 & \TTbf{1}\\
  1 & 0 & 0 & 1 & \TTbf{0} & 0 & \TTbf{1} & 0 & \TTbf{0}\\
  0 & 1 & 1 & 0 & \TTbf{1} & 1 & \TTbf{0} & 1 & \TTbf{1}\\
  0 & 0 & 1 & 0 & \TTbf{0} & 0 & \TTbf{1} & 0 & \TTbf{0}
\end{tabular}
\end{center}

It is easy to see that there is no row in which the premises are all 1, and so it follows trivially that there are no rows in which the premises are 1 and the conclusion is 0.
Thus the argument is valid.
Instead of appealing to the truth table for this argument, we may prove that the argument is valid by assuming that there is an interpretation $\I$ which makes the premises true and the conclusion false. 
Accordingly $\V{\I}(\enot A \eand B)=\V{\I}(\enot B)=1$ and $\V{\I}(B)=0$.
It follows by the semantic clause for conjunction that $\V{\I}(B)=1$, and from the semantic clause for negation that $\V{\I}(B)=0$, and so both $\I(B)=1$ and $\I(B)=0$ by the semantic clause for sentence letters.
This is a contradiction, since $B$ cannot be both true and not true on any given interpretation.
Thus there is no such interpretation $\I$, and so the argument is valid.
More generally, any argument with inconsistent premises is valid.

It is worth contrasting the case above with the following argument:

\begin{earg}
\item[] $\enot L \eif (J \eor L)$
\item[] $\enot L$
\item[\therefore] $J$
\end{earg}

It is good practice to consult your intuitions in evaluating arguments before beginning to compute its truth table.
Once you have a guess about its validity, consider the following:

\begin{center}
\begin{tabular}{c|c|@{\TTon}*{6}{c}@{\TToff}|@{\TTon}*{2}{c}@{\TToff}|@{\TTon}c@{\TToff}}
$J$&$L$&\enot&$L$&\eif&$(J$&\eor&$L)$&\enot&L&J\\
\hline
%J   L   -   L      ->     (J   v   L)
 1 & 1 & 0 & 1 & \TTbf{1} & 1 & 1 & 1 & \TTbf{0} & 1 & \TTbf{1}\\
 1 & 0 & 1 & 0 & \TTbf{1} & 1 & 1 & 0 & \TTbf{1} & 0 & \TTbf{1}\\
 0 & 1 & 0 & 1 & \TTbf{1} & 0 & 1 & 1 & \TTbf{0} & 1 & \TTbf{0}\\
 0 & 0 & 1 & 0 & \TTbf{0} & 0 & 0 & 0 & \TTbf{1} & 0 & \TTbf{0}
\end{tabular}
\end{center}

To determine whether the argument is valid, check to see whether there are any rows on which both premises are assigned 1, but where the conclusion is assigned 0.
Notice that unlike the previous argument, there is a row in which both premises are 1.
Nevertheless, the only row in which both the premises are 1 is the second row, and in that row the conclusion is also 1.
So the argument is valid in SL, though it is not vacuously valid as before.\footnote{Can you use the semantics to prove that the argument is valid in the style presented above?}

Here is another example.
Is this argument valid?
Again, try to think about it first.

\begin{earg}
\item[] $P \eif Q$
\item[] $\enot P$
\item[\therefore] $\enot Q$
\end{earg}

To evaluate it, construct a truth table and check whether there is a row that assigns 1 to the premises and 0 to the conclusion:

\begin{center}
\begin{tabular}{@{ }c@{ }@{ }c | c@{ }@{ }c@{ }@{ }c@{ }@{ }c@{ }@{ }c | c@{ }@{ }c | c@{ }@{ }c}
$P$ & $Q$ &  & $P$ & $\eif$ & $Q$ &  & $\enot$ & $P$ & $\enot$ & $Q$\\
\hline 
1 & 1 &  & 1 & \TTbf{1} & 1 &  & \TTbf{0} & 1 & \TTbf{0} & 1\\
1 & 0 &  & 1 & \TTbf{0} & 0 &  & \TTbf{0} & 1 & \TTbf{1} & 0\\
0 & 1 &  & 0 & \TTbf{1} & 1 &  & \TTbf{1} & 0 & \TTbf{0} & 1\\
0 & 0 &  & 0 & \TTbf{1} & 0 &  & \TTbf{1} & 0 & \TTbf{1} & 0\\
\end{tabular}
\end{center}

On the third row, the premises are true and the conclusion is false.
Thus the argument is invalid in SL.
We may establish much the same by taking $\I$ to be an interpretation of SL which makes the premises true and the conclusion false. 
Thus $\V{\I}(P \eif Q)=\V{\I}(\enot P)=1$ and $\V{\I}(\enot Q)=0$. 
By the semantic clause for negation we know that $\V{\I}(P)=0$ and $\V{\I}(Q)=1$, and so $\I(P)=0$ and $\I(Q)=1$ by the semantic clause for sentence letters.
Moreover, this is perfectly consistent with $\V{\I}(P \eif Q)=1$.
Accordingly, any interpretation $\I$ in which $\I(P)=0$ and $\I(Q)=1$ where the truth-values of all other sentence letters are arbitrary counts as a counterexample to the validity of the argument above. 

Taking the truth-values of the sentence letters that do not occur in a given argument to be arbitrary is akin to simply ignoring all other sentence letters as we do in constructing complete truth tables for arguments.
Although the functional definition of an interpretation and valuation provides an elegant account of validity in SL, evaluating sentences and arguments by constructing truth tables provides a simple mechanical procedure that is easy to employ.
For this reason, the remainder of this chapter will focus on constructing truth tables.




\section{Partial Truth Tables}

In order to show that a sentence is a tautology, we need to show that it is assigned 1 on every row of its complete truth table, or equivalently, that it is true on all interpretations of SL.
So we need a complete truth table.
To show that a sentence is \emph{not} a tautology, however, we only need one line: a line on which the sentence is 0.
Therefore, in order to show that something is not a tautology, it is enough to provide a \emph{partial truth table} regardless of how many sentence letters the sentence might include.

Consider, for example, the sentence $(U \eand T) \eif (S \eand W)$.
We want to show that it is \emph{not} a tautology by providing a partial truth table.
We fill in 0 for the entire sentence.
The main connective of the sentence is a conditional.
In order for the conditional to be false, the antecedent must be true (1) and the consequent must be false (0).
So we fill these in:
\begin{center}
\begin{tabular}{c|c|c|c|@{\TTon}*{7}{c}@{\TToff}}
$S$&$T$&$U$&$W$&$(U$&\eand&$T)$&\eif    &$(S$&\eand&$W)$\\
\hline
   &   &   &   &    &  1  &    &\TTbf{0}&    &   0 &   
\end{tabular}
\end{center}
In order for $(U\eand T)$ to be true, both $U$ and $T$ must be true. So we put a 1 under those letters:
\begin{center}
\begin{tabular}{c|c|c|c|@{\TTon}*{7}{c}@{\TToff}}
$S$&$T$&$U$&$W$&$(U$&\eand&$T)$&\eif    &$(S$&\eand&$W)$\\
\hline
   & 1 & 1 &   &  1 &  1  & 1  &\TTbf{0}&    &   0 &   
\end{tabular}
\end{center}
Remember that each instance of a given sentence letter must be assigned the same truth value in a given row of a truth table.
You can't assign 1 to one instance of $U$ and 0 to another instance of $U$ in the same row.
So here we put a 1 under \emph{each} instance of $U$ and $T$.

Now we just need to make $(S\eand W)$ false.
To do this, we need to make at least one of $S$ and $W$ false.
We can make both $S$ and $W$ false if we want.
All that matters is that the whole sentence turns out false on this line.
Making an arbitrary decision, we finish the table:
\begin{center}
\begin{tabular}{c|c|c|c|@{\TTon}*{7}{c}@{\TToff}}
$S$&$T$&$U$&$W$&$(U$&\eand&$T)$&\eif    &$(S$&\eand&$W)$\\
\hline
 0 & 1 & 1 & 0 &  1 &  1  & 1  &\TTbf{0}&  0 &   0 & 0  
\end{tabular}
\end{center}

Showing that something is a tautology requires a complete truth table.
Showing that something is \emph{not} a tautology requires only a one-line partial truth table, where the sentence is false on that one line.
That's what we've just done.
In the same way, to show that something is a contradiction, you must show that it is false on every row; to show that it is not a contradiction, you need only find one row where it is true.

A sentence is contingent if it is neither a tautology nor a contradiction.
Showing that a sentence is contingent requires a \emph{two-line} partial truth table where the sentence is true on one line and false on the other.
For example, we can show that the sentence above is contingent:
\begin{center}
\begin{tabular}{c|c|c|c|@{\TTon}*{7}{c}@{\TToff}}
$S$&$T$&$U$&$W$&$(U$&\eand&$T)$&\eif    &$(S$&\eand&$W)$\\
\hline
 0 & 1 & 1 & 0 &  1 &  1  & 1  &\TTbf{0}&  0 &   0 & 0 \\
 0 & 1 & 0 & 0 &  0 &  0  & 1  &\TTbf{1}&  0 &   0 & 0
\end{tabular}
\end{center}
Note that there are many combinations of truth values that would have made the sentence true, so there are many ways we could have written the second line.

Showing that a sentence is \emph{not} contingent requires providing a complete truth table, because it requires showing that the sentence is a tautology or that it is a contradiction.
If you do not know whether a particular sentence is contingent, then you do not know whether you will need a complete or partial truth table.
You can always start working on a complete truth table.
If you complete rows that show the sentence is contingent, then you can stop.
If not, then complete the truth table. Even though two carefully selected rows will show that a contingent sentence is contingent, there is nothing wrong with filling in more rows.

Showing that two sentences are logically equivalent requires providing a complete truth table.
Showing that two sentences are \emph{not} logically equivalent requires only a one-line partial truth table: find a line (i.e. an interpretation of the sentence letters) where one sentence is true and the other false.

Showing that a set of sentences is consistent requires providing one row of a truth table on which all of the sentences are true.
The rest of the table is irrelevant, so a one-line partial truth table will do.
Showing that a set of sentences is inconsistent, on the other hand, requires a complete truth table: you must show that on every row of the table at least one of the sentences is false.

Showing that an argument is valid requires a complete truth table.
Showing that an argument is \emph{invalid} only requires providing a one-line truth table: if you can produce a line on which the premises are all true and the conclusion is false, then the argument is invalid.

\begin{table}[ht]
\begin{center}
\begin{tabular}{c|c|c|}
\cline{2-3}
 & YES & NO\\
\cline{2-3}
tautology? & complete truth table & one-line partial truth table\\
contradiction? &  complete truth table  & one-line partial truth table\\
contingent? & two-line partial truth table & complete truth table\\
equivalent? & complete truth table & one-line partial truth table\\
consistent? & one-line partial truth table & complete truth table\\
valid? & complete truth table & one-line partial truth table\\
\cline{2-3}
\end{tabular}
\end{center}
\caption{When to use a partial truth table}
\label{table.CompleteVsPartial}
\end{table}

Table \ref{table.CompleteVsPartial} summarizes when a complete truth table is required and when a partial truth table will do.
If you are trying to remember whether you need a complete truth table or not, the general rule is, if you're looking to establish a claim about \emph{every} interpretation, you need a complete table.




\section{Evaluating English Arguments in SL}
  \label{sec:forms}

Arguments in English have an intended interpretation insofar as they are meaningful to us in the form they are presented purely in virtue of our understanding of English.
The same cannot be said for SL which includes such sentences as $A$, $\enot (B \eor \enot C)$, $A \eif \enot (B \eif C)$, etc., which do not \textit{already} mean something to us.
This gap is filled by: (1) providing a symbolization key which specifies the English sentences that some sentences in SL are intended to regiment; and (2) interpreting the relevant sentences of SL by specifying truth-values for the sentence letters that they contain.
If an argument in English can be naturally regimented by an SL argument that is valid, we have good reason to take the argument in English to be valid.

As we have already seen, sentences and arguments in English can be regimented in many different ways, some better than others.
Accordingly, we cannot conclude that an English argument is invalid just because it has an invalid regimentation in SL since there could be a better regimentation that is valid.
Even when an English argument does not have any valid regimentation in SL, this does not mean that it could not have a valid regimentation in some expressively more powerful language like QL which we will study later on in this course.
For the time being, we will focus on regimenting and evaluating the validity of arguments in English with the resources of SL.
Consider the following example:

\begin{earg}
  \item[] Either the butler is the murderer or the gardener isn't who he says he is. 
  \item[] The gardener is who he says he is.
  \item[\therefore] The butler is the murderer.
\end{earg}

In order to determine its validity, let's translate this argument into SL and evaluate the resulting formal argument for validity with a truth table.
We begin with a symbolization key:

\begin{ekey}
  \item[B:] The butler is the murderer.
  \item[G:] The gardener is who he says he is.
\end{ekey}

With this key, the argument, regimented in SL, looks like this:

\begin{earg}
  \item $B\eor\enot G$
  \item $G$
  \item[\therefore] $B$
\end{earg}

We can now evaluate this argument in SL for validity using a truth table.
We'll set up a table with the two sentence letters included above, and check to see whether there is a row that assigns `1' to both premises and assigns `0' to the conclusion.
Thus we have:

\begin{center}
  \begin{tabular}{c|c|@{\TTon}*{4}{c}@{\TToff}|@{\TTon}c@{\TToff}|@{\TTon}c@{\TToff}}
    $B$&$G$&$(B$&\eor&\enot&$G$)&$G$&$B$\\
    \hline
    1 & 1 & 1 & \TTbf{1} & 0 & 1 & \TTbf{1} & \TTbf{1}\\
    1 & 0 & 1 & \TTbf{1} & 1 & 0 & \TTbf{0} & \TTbf{1}\\
    0 & 1 & 0 & \TTbf{0} & 0 & 1 & \TTbf{1} & \TTbf{0}\\
    0 & 0 & 0 & \TTbf{1} & 1 & 0 & \TTbf{0} & \TTbf{0}\\
  \end{tabular}
\end{center}

If the argument were invalid, there would be a line on which the first two bold values are `1' but the third is `0'.
There is no such line, so the argument is valid.
This helps explain why the English argument is valid: it can be regimented by a valid argument in SL.

There are at least two advantages to evaluating a natural language argument for validity by translating it into SL.
For one thing, using truth tables to evaluate arguments is a formal method that does not require any particular rational insight or intuition.
Although it is sometimes easy to tell whether an argument in English is valid, there are many complex arguments where it is next to impossible.
It is an advantage to have a mechanical procedure by which to check an argument for validity that is easy to carry out without running into errors.
A second advantage, alluded to in Chapter \ref{ch.SL}, is that regimenting English arguments in SL can help to identify a common logical form.
For example, consider this argument:

\begin{earg}
  \item Either Barney is a purple dinosaur or I don't have a really weird-looking cat.
  \item I do have a really weird-looking cat.
  \item[\therefore] Barney is a purple dinosaur.
\end{earg}

This argument can be regimented as follows:

\begin{ekey}
  \item[D:] Barney is a purple dinosaur.
  \item[C:] I have a really weird-looking cat.
\end{ekey}

\begin{earg}
  \item $D\eor\enot C$
  \item $C$
  \item[\therefore] $D$
\end{earg}

Although we have used different sentence letters, both arguments in SL are instances of the following argument form:

\begin{earg}
  \item $\metaA{}\eor\enot \metaB{}$
  \item $\metaB{}$
  \item[\therefore] $\metaA{}$
\end{earg}

Any argument which has this logical form is valid.
More generally, we may say that:

\factoidbox{
Any English argument that can be regimented by a valid SL argument is valid.
}

What we have not commented on is what does and does not count as a proper regimentation, where one might hope to specify this as well so as to remove all indeterminacy.
To do so, one would have to be able to specify the logical form of English sentences and the arguments that they form.
However, we cannot even manage to provide an account of which expressions count as English sentences, much less agree about their true logical form.
Despite this shortcoming, it is often possible to provide natural regimentations of English arguments in SL, where doing so is a matter of practice and judgement rather than the mechanical application of some broader theory.
Even for complex arguments, it is sometimes easy to provide a valid regimentation in SL or some other formal language.
For instance, consider the following case:

\begin{earg}
  \item Either Canada is a democracy if and only if Poland is neither part of the European Union nor majority Catholic, or my dog is not not lazy.
  \item My dog is not lazy.
  \item[\therefore] Canada is a democracy if and only if Poland is neither part of the European Union nor majority Catholic.
\end{earg}

One could translate this argument by identifying atomic sentences, symbolising them by sentence letters, and building up the complex sentences in these terms.
In this instance, however, that extra structure isn't needed to capture the validity of the argument.
Instead, we can use this symbolization key:

\begin{ekey}
\item[A:] Canada is a democracy if and only if Poland is neither part of the European Union nor majority Catholic.
\item[L:] My dog is not lazy.
\end{ekey}

For many purposes, this would be a poor choice of symbolization keys.
It ignores the internal structure of two central sentences.
But if, as here, that structure is irrelevant, you can save yourself some work by engaging at a higher level of abstraction.




\iffalse

\practiceproblems
If you want additional practice, you can construct truth tables for any of the sentences and arguments in the exercises for the previous chapter.



\problempart
\label{HW2.E}
Provide the truth table for the complex formula:
$$((P \eif (( P \eif Q) \eiff (P \eand \enot R))) \eor R)$$
Indicate whether the formula is tautological, contradictory, or contingent.
If it is contingent, provide an interpretation in which it is true as well as an interpretation in which it is false.


\begin{tabular}{@{ }c@{ }@{ }c@{ }@{ }c | c@{ }@{}c@{}@{ }c@{ }@{ }c@{ }@{}c@{}@{}c@{}@{ }c@{ }@{ }c@{ }@{ }c@{ }@{}c@{}@{ }c@{ }@{}c@{}@{ }c@{ }@{ }c@{ }@{ }c@{ }@{ }c@{ }@{}c@{}@{}c@{}@{}c@{}@{ }c@{ }@{ }c@{ }@{ }c}
$P$ & $Q$ & $R$ &  & ( & $P$ & $\eif $ & ( & ( & $P$ & $\eif $ & $Q$ & ) & $\eiff $ & ( & $P$ & $\&$ & $\enot$ & $R$ & ) & ) & ) & $\lor$ & $R$ & \\
\hline 
 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & & \\
 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & & \\
  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & & \\
 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & & \\
 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & & \\
  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & & \\
 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & & \\
  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & & \\
\end{tabular}




\problempart
\label{HW3.A}
Provide the complete truth table for this SL sentence:
$$((P \eor Q) \eand (\enot P \eor \enot Q)) \eiff R$$
Indicate whether it is tautological, contradictory, or contingent. 
If it is contingent, provide an interpretation in which it is true as well as an interpretation in which it is false.



\solutions
\problempart
\label{pr.TT.TTorC}
Determine whether each sentence is a tautology, a contradiction, or a contingent sentence. Justify your answer with a complete or partial truth table where appropriate.
\begin{earg}
\item $A \eif A$ %taut
\item $\enot B \eand B$ %contra
\item $C \eif\enot C$ %contingent
\item $\enot D \eor D$ %taut
\item $(A \eiff B) \eiff \enot(A\eiff \enot B)$ %tautology
\item $(A\eand B) \eor (B\eand A)$ %contingent
\item $(A \eif B) \eor (B \eif A)$ % taut
\item $\enot[A \eif (B \eif A)]$ %contra
\item $(A \eand B) \eif (B \eor A)$  %taut
\item $A \eiff [A \eif (B \eand \enot B)]$ %contra
\item $\enot(A \eor B) \eiff (\enot A \eand \enot B)$ %taut
\item $\enot(A\eand B) \eiff A$ %contingent
\item $\bigl[(A\eand B) \eand\enot(A\eand B)\bigr] \eand C$ %contradiction
\item $A\eif(B\eor C)$ %contingent
\item $[(A \eand B) \eand C] \eif B$ %taut
\item $(A \eand\enot A) \eif (B \eor C)$ %tautology
\item $\enot\bigl[(C\eor A) \eor B\bigr]$ %contingent
\item $(B\eand D) \eiff [A \eiff(A \eor C)]$%contingent
\end{earg}


% Chapter 3 Part D
\solutions
\problempart
\label{pr.TT.equiv}
Determine whether each pair of sentences is logically equivalent. Justify your answer with a complete or partial truth table where appropriate.
\begin{earg}
\item $A$, $\enot A$ %No
\item $A$, $A \eor A$ %Yes
\item $A\eif A$, $A \eiff A$ %No
\item $A \eor \enot B$, $A\eif B$ %No
\item $A \eand \enot A$, $\enot B \eiff B$ %Yes
\item $\enot(A \eand B)$, $\enot A \eor \enot B$ %Yes
\item $\enot(A \eif B)$, $\enot A \eif \enot B$ %No
\item $(A \eif B)$, $(\enot B \eif \enot A)$ %Yes
\item $[(A \eor B) \eor C]$, $[A \eor (B \eor C)]$ %Yes
\item $[(A \eor B) \eand C]$, $[A \eor (B \eand C)]$ %No
\end{earg}

% Chapter 3 Part E
\solutions
\problempart
\label{pr.TT.consistent}
Determine whether each set of sentences is consistent or inconsistent. Justify your answer with a complete or partial truth table where appropriate.
\begin{earg}
\item $A\eif A$, $\enot A \eif \enot A$, $A\eand A$, $A\eor A$ %consistent
\item $A \eand B$, $C\eif \enot B$, $C$ %inconsistent
\item $A\eor B$, $A\eif C$, $B\eif C$ %consistent
\item $A\eif B$, $B\eif C$, $A$, $\enot C$ %inconsistent
\item $B\eand(C\eor A)$, $A\eif B$, $\enot(B\eor C)$  %inconsistent
\item $A \eor B$, $B\eor C$, $C\eif \enot A$ %consistent
\item $A\eiff(B\eor C)$, $C\eif \enot A$, $A\eif \enot B$ %consistent
\item $A$, $B$, $C$, $\enot D$, $\enot E$, $F$ %consistent
\end{earg}




\problempart
\label{HW3.B}

Use a complete truth table to evaluate this argument form for validity:

\begin{earg}
\item[] $(P \eif Q) \eor (Q \eif P)$
\item[] $P$
\item[\therefore] $P\eiff Q$
\end{earg}

Indicate whether it valid or invalid.
If it is invalid, provide an interpretation in which the premises are true and the conclusion is false.




\solutions
\problempart
\label{pr.TT.valid}
Determine whether each argument form is valid or invalid. Justify your answer with a complete or partial truth table where appropriate.
\begin{earg}
\item $A\eif A$ \therefore\ $A$ %invalid
\item $A\eor\bigl[A\eif(A\eiff A)\bigr]$ \therefore\ A %invalid
\item $A\eif(A\eand\enot A)$ \therefore\ $\enot A$ %valid
\item $A\eiff\enot(B\eiff A)$ \therefore\ $A$ %invalid
\item $A\eor(B\eif A)$ \therefore\ $\enot A \eif \enot B$ %valid
\item $A\eif B$, $B$ \therefore\ $A$ %invalid
\item $A\eor B$, $B\eor C$, $\enot A$ \therefore\ $B \eand C$ %invalid
\item $A\eor B$, $B\eor C$, $\enot B$ \therefore\ $A \eand C$ %valid
\item $(B\eand A)\eif C$, $(C\eand A)\eif B$ \therefore\ $(C\eand B)\eif A$ %invalid
\item $A\eiff B$, $B\eiff C$ \therefore\ $A\eiff C$ %valid
\end{earg}

\solutions
\problempart
\label{pr.TT.concepts}
Answer each of the questions below and justify your answer.
\begin{earg}
\item Suppose that \metaA{} and \metaB{} are logically equivalent for some sentences of SL $\metaA$ and $\metaB$. What can you say about $\metaA{}\eiff\metaB{}$?
%\metaA{} and \metaB{} have the same truth value on every line of a complete truth table, so $\metaA{}\eiff\metaB{}$ is true on every line. It is a tautology.
\item Suppose that $(\metaA{}\eand\metaB{})\eif\metaC{}$ is contingent for some sentences of SL $\metaA, \metaB,$ and $\metaC$. What can you say about the argument ``\metaA{}, \metaB{}, \therefore\metaC{}''?
%The sentence is false on some line of a complete truth table. On that line, \metaA{} and \metaB{} are true and \metaC{} is false. So the argument is invalid.
\item Suppose that $\{\metaA{},\metaB{}, \metaC{}\}$ is inconsistent for some sentence of SL $\metaA, \metaB,$ and $\metaC$. What can you say about $(\metaA{}\eand\metaB{}\eand\metaC{})$?
%Since there is no line of a complete truth table on which all three sentences are true, the conjunction is false on every line. So it is a contradiction.
\item Suppose that \metaA{} is a contradiction for some sentence of SL $\metaA$. What can you say about the argument ``\metaA{}, \metaB{}, \therefore\metaC{}''?
%Since \metaA{} is false on every line of a complete truth table, there is no line on which \metaA{} and \metaB{} are true and \metaC{} is false. So the argument is valid.
\item Suppose that \metaC{} is a tautology for some sentence of SL $\metaC$. What can you say about the argument ``\metaA{}, \metaB{}, \therefore\metaC{}''?
%Since \metaC{} is true on every line of a complete truth table, there is no line on which \metaA{} and \metaB{} are true and \metaC{} is false. So the argument is valid.
  \item Suppose that \metaA{} and \metaB{} are logically equivalent for some sentences of SL $\metaA$ and $\metaB$. What can you say about $(\metaA{}\eor\metaB{})$?
%Not much. $(\metaA{}\eor\metaB{})$ is a tautology if \metaA{} and \metaB{} are tautologies; it is a contradiction if they are contradictions; it is contingent if they are contingent.
\item Suppose that \metaA{} and \metaB{} are \emph{not} logically equivalent for some sentences of SL $\metaA$ and $\metaB$. What can you say about $(\metaA{}\eor\metaB{})$?
%\metaA{} and \metaB{} have different truth values on at least one line of a complete truth table, and $(\metaA{}\eor\metaB{})$ will be true on that line. On other lines, it might be true or false. So $(\metaA{}\eor\metaB{})$ is either a tautology or it is contingent; it is \emph{not} a contradiction.
\end{earg}

\problempart
\phantomsection\label{pr.altConnectives}
We could leave the biconditional (\eiff) out of the language. If we did that, we could still write `$A\eiff B$' so as to make sentences easier to read, but that would be shorthand for $(A\eif B) \eand (B\eif A)$. The resulting language would be formally equivalent to SL, since $A\eiff B$ and $(A\eif B) \eand (B\eif A)$ are logically equivalent in SL.

There are a number of languages that are expressively equivalent to SL that only include two connectives.
It would be enough to have only negation and the material conditional.
Show this by writing sentences that are logically equivalent to each of the following using only parentheses, sentence letters, negation (\enot), and the material conditional (\eif):
\begin{earg}
\item\leftsolutions\ $A\eor B$
%$\enot A \eif B$
\item\leftsolutions\ $A\eand B$
%$\enot(A \eif \enot B)$
\item\leftsolutions\ $A\eiff B$
%$\enot [(A\eif B) \eif \enot(B\eif A)]$
\end{earg}
%...
% Break out of the {earg} environment to give new instructions. 

We could have a language that is expressively equivalent to SL with only negation and disjunction as connectives.
Show this by using only parentheses, sentence letters, negation (\enot), and disjunction (\eor) to write sentences that are logically equivalent to each of the following:
% Resume the {earg} environment and restore the counter.
%...
\begin{earg}
\setcounter{eargnum}{\arabic{OLDeargnum}}
\item $A \eand B$
%$\enot(\enot A \eor \enot B)$
\item $A \eif B$
%$\enot A \eor B$
\item $A \eiff B$
%$\enot(\enot A \eor \enot B) \eor \enot(A \eor B)$
\end{earg}
%...
The \emph{Sheffer stroke} is a logical connective with the following characteristic truthtable:
\begin{center}
\begin{tabular}{c|c|c}
\metaA{} & \metaB{} & \metaA{}$|$\metaB{}\\
\hline
1 & 1 & 0\\
1 & 0 & 1\\
0 & 1 & 1\\
0 & 0 & 1
\end{tabular}
\end{center}
%...
\begin{earg}
\setcounter{eargnum}{\arabic{OLDeargnum}}
\item Write a sentence using the connectives of SL that is logically equivalent to $(A|B)$.
\end{earg}
%...
Every sentence written using a connective of SL can be rewritten as a logically equivalent sentence using one or more Sheffer strokes. Using no connectives other than the Sheffer stroke, write sentences that are equivalent to each of the following. 
%...
\begin{earg}
\setcounter{eargnum}{\arabic{OLDeargnum}}
\item $\enot A$
\item $(A\eand B)$
\item $(A\eor B)$
\item $(A\eif B)$
\item $(A\eiff B)$
\end{earg}


\problempart
\label{HW2.F}


The connective `\eor' indicates \emph{inclusive disjunction}; it is true if either \emph{or both} of the disjuncts is true. One might be interested in \emph{exclusive disjunction}, which requires that exactly one of the disjuncts be true. Let us temporarily extend SL to include a connective for exclusive disjunction, allowing sentences of the form $(\metaA{} \oplus \metaB{})$, where \metaA{} and \metaB{} are sentences, meaning that exactly one of \metaA{} and \metaB{} are true.
\begin{earg}
  \item Provide the truth table for $(\metaA{} \oplus \metaB{})$.

  \begin{tabular}{@{ }c@{ }@{ }c | c@{ }@{ }c@{ }@{ }c@{ }@{ }c@{ }@{ }c}
    $\metaA{}$ & $\metaB{}$ &  & $\metaA{}$ & $\oplus$ & $\metaB{}$ & \\
    \hline 
     &  &  &  &  & & \\
     &  &  &  &  &  & \\
     &  &  &  &  &  & \\
     &  &  &  &  &  & \\
  \end{tabular}\\

  \item $\oplus$ is \emph{definable} in terms of \eor, \eand, and \enot. This means that there is a formula using only these latter connectives that has the same truth table. Provide such a formula.
\end{earg}


\fi




% %!TEX root = ../forallx-ubc.tex
% \chapter{Logical Entailment in SL}
% \label{ch.SLmodels}

In Ch.~\ref{ch.SL} we defined the sentences of SL, and in Ch.~\ref{ch.TruthTables} we defined the interpretations of SL and provided semantic clauses for the logical connectives.
Given these definitions, we are now in a position to introduce the notion of \textit{logical entailment}, relating this notion to the semantic concepts of validity, tautology, contradiction, consistency, and logical equivalence.






\section{Satisfaction}
\label{sec:satisfaction}

Recall that an \define{interpretation} is any function which assigns a truth-value to every sentence letter of SL.
We will also refer to interpretations of SL as \define{models} of SL since interpretations provide an extensional way to represent the meanings of the sentence letters in SL.\footnote{Intensional and hyperintensional semantic frameworks provide much more fine-grained representations of meanings, but this doesn't make extensional frameworks irrelevant. After all, first-order set theory is an extensional theory which many take to provide a foundation for mathematics.}

Whereas a sentence $\metaA{}$ may be either true of false on a given interpretation $\I$ (i.e., the valuation function $\V{\I}$ induced by $\I$ assigns that sentence to $1$), sets of sentences do not have truth-values.
Accordingly, we may say that an SL interpretation $\I$ \define{satisfies} a set of SL sentences $\Gamma=\set{\metaA_{1},\metaA_{2},\ldots}$ just in case $\V{\I}(\metaA)=1$ for all $\metaA \in \Gamma$.
Derivatively, it is convenient to say that an interpretation $\I$ of SL \define{satisfies} a single sentence $\metaA$ just in case it satisfies the singleton set $\set{\metaA}$, i.e., the set which includes $\metaA$ as its only member. 





\section{Entailment}
  \label{sec:entailment}

A set of SL sentences $\Gamma$ \define{logically entails} $\metaA$ just in case every interpretation that satisfies $\Gamma$ also satisfies $\metaA$.
Logical entailment is also called the \define{logical consequence} relation, or \define{semantic consequence}, and is written: $\Gamma \models \metaA$. 
An entire chapter is named after this relation for good reason: it is the most important semantic concept that we will introduce and will later be shown to have the same extension as a corresponding syntactic notion.

Note that the double turnstile `$\models$' is--- like the metavariable `\metaA{}'--- part of the \emph{metalanguage} we use to discuss SL, and not a part of SL.
For ease of exposition, we will often drop `logically', speaking simply of entailment.
Although officially $\models$ takes a set of SL sentences on the left together with a single SL sentence on the right, it is both common and convenient to drop the set notation, writing `$\metaA_1,\ldots,\metaA_n \models \metaB$' instead of `$\set{\metaA_1,\ldots,\metaA_n} \models \metaB$'.
% Even though entailment is connected in important ways to the validity of arguments, it is important to remember to apply the definitions rigorously and precisely.

Recall that an argument in SL is a sequence of SL sentences, and so a completely different type of thing than a set of sentences of SL.
After all, sets do not specify the order of their members.
Nevertheless, we may say that for any SL argument, that argument is valid if and only if it's premises entail it's conclusion.
What we cannot say is that for any set of SL sentences $\Gamma$ and further sentence $\metaA$, if $\Gamma \models \metaA$, then \textit{the} argument whose premises are the sentences in $\Gamma$ and whose conclusion is $\metaA$ is valid.
This is because there may fail to be a unique argument that we can construct from a set of SL sentences $\Gamma$ and a further SL sentence $\metaA$.
For instance, assuming $\Gamma$ includes at least two sentences, we can construct different arguments by ordering the premises in different ways.
Instead, we may claim something general: if $\Gamma \models \metaA$, then \textit{every} argument where the sentence in $\Gamma$ are the premises (in some order or other) and $\metaA$ is the conclusion is valid.

It will help to consider a simple example.
For instance, take the following entailment claim: 
  $$P, Q \models P\eor Q.$$ 
The entailment above is true since every interpretation that satisfies the set $\set{P, Q}$ also satisfies $P\eor Q$.
Accordingly, we may say that the argument with $P$ as its first premise, $Q$ as its second premise, and $P\eand Q$ as its conclusion is logically valid. 
Although closely related, this is a different claim than our original entailment, one to do with arguments.
For instance, there is a distinct argument which takes $Q$ to be its first premise, $P$ as its second premise, and $P\eand Q$ as its conclusion, though this second argument is just as valid as the first.
By contrast, permuting $P$ and $Q$ in the entailment claim above does not amount to a distinct entailment claim, but rather a distinct means of expressing the very same entailment claim. 
This is because sets do not preserve order: $\set{P,Q}=\set{Q,P}$.




\section{Tautologies}

What should we make of the following claim:

\begin{quote}
  $P\eand Q \models A\eiff\enot\enot A$.
\end{quote}

Notice that the sentence letters on the left-hand-side are completely different letters from those on the right-hand-side.
So there is a straightforward sense in which the two sides of the entailment have \emph{nothing to do with one another}.
Nevertheless, the entailment above is true: every interpretation that satisfies the sentences on the left, also satisfes the sentence on the right for the simple reason that every interpretation whatsoever satisfies $A\eiff\enot\enot A$.

Whereas before we said that an SL sentence $\metaA$ is a tautology just in case it was true on all interpretations of SL (equivalently, all lines of a complete truth table for that sentence), we may now define the SL tautologies in terms of entailment.
Officially, a sentence $\metaA$ of SL is a \define{tautology} just in case $\metaA$ is entailed by the empty set, i.e., $\varnothing \models \metaA$.
Dropping set notation, it is typical to leave off the empty set entirely, writing $\models \metaA$ for brevity.

In order to see why this definition makes sense, we may observe that every SL interpretation satisfies the empty set $\varnothing$.
After all, an SL interpretation $\I$ could only fail to satisfy a set $\Gamma$ of SL sentences if there were some sentence in $\Gamma$ that fails to be true on $\I$.
Since there are no sentences in $\varnothing$, the empty set $\varnothing$ is vacuously satisfied by every SL interpretation whatsoever.
By definition, an SL sentence $\metaA$ is entailed by the empty set (i.e., $\models \metaA$) just in case every interpretation to satisfy the empty set $\varnothing$ also satisfies $\metaA$.
Since we have shown that every interpretation satisfies the empty set, this is equivalent to claiming that every SL interpretation satisfies $\metaA$. 
Thus, $\models \metaA$ if and only if $\V{\I}(A)=1$ for all SL interpretations $\I$.   

Consider the following claims:

\begin{earg}
  \item[] $\models P \eor \enot P$
  \item[] $\models P \eiff P$
  \item[] $\models (P \eand\enot P)\eif (A \eor B)$
\end{earg}

Although for different reasons, each of the entailments above are true, and so the SL sentences on the right are tautologies.
For contrast, the following claims are not tautologies:

\begin{earg}
  \item[] $\models P$
  \item[] $\models P \eand \enot P$
  \item[] $\models \enot(P \eif \enot P)$
\end{earg}

If you ever want to compute whether a sentence is a tautology, you can always write out its truth table.
This can be practical so long as it does not include too many sentence letters.


\section{Weakening}

If the right-hand-side of an entailment claim is a tautology, it doesn't matter what's on the left for the entailment to hold.
For instance, given that $\models P \eor \enot P$, we may conclude that $Q \models P \eor \enot P$.
More generally, we may observe the following:
$$\text{If}~ \Gamma \models \metaA, ~\text{then}~ \Gamma \cup \Sigma\models \metaA.$$
This principle is referred to as \define{weakening}.
As a special case (i.e., $\Gamma=\varnothing$), we may conclude that if $\metaA$ is a tautology (i.e., $\models \metaA$), then every set of SL sentences $\Sigma$ entails $\metaA$ (i.e., $\Sigma \models \metaA$).

In particular, we may draw the following conclusions from the entailments above:

\begin{earg}
  \item[] $Q \models P \eor \enot P$
  \item[] $R \eif (Q \eand \enot Q)\models P \eiff P$
  \item[] $A \eand \enot A \models (P \eand\enot P)\eif (A \eor B)$
\end{earg}

In $\S\ref{sec:entailment}$, we said that if an argument is valid, then its premises entail its conclusion.
Given weakening, it follows that if an argument is valid, then any set containing the arguments premises will entail the argument's conclusion.




\section{Unsatisfiable}

Having defined what it is for a sentence to be a tautology in terms of entailment, it is natural to consider how we might use the notion of entailment to define what it is for a sentence to be a contradiction.
Here it will help to begin by considering the following entailment:
$$P \eand \enot P \models Q.$$
This statement is true.
It says that every interpretation satisfying $P \eand \enot P$ also satisfies $Q$.
This follows vacuously since no interpretation satisfies $P \eand \enot P$, and so every interpretation which satisfies $P \eand \enot P$ (all zero of them) also satisfies $Q$.
Or to take another approach, think about what it would take for the entailment above to be false: there would have to be some interpretation which satisfies $P \eand \enot P$ but does not satisfy $Q$.
But there are no interpretations that satisfy $P \eand \enot P$, and so the entailment above is true.

Observe that the reason that the entailment above is true has nothing to do with the sentence $Q$.
Thus the same considerations would demonstrate that $P \eand \enot P \models \metaA{}$ for any sentence \metaA{} of SL.
Moreover, the same conclusion holds were we to replace $P \eand \enot P$ with any other SL sentence that is not true on any interpretation.
For instance, consider:

\begin{earg}
\item[] $A \eand \enot A \models \enot Q \eif R$.
\item[] $\enot (P \eor \enot P) \models (A_1 \eor A_2) \eif \enot (A_3 \eiff (A_4 \eand \enot A_2))$.
\end{earg}

Since there are no interpretations that satisfy the sentences on the left, you do not need to examine the sentence on the right to confirm that the entailment claims above are true.
Given that the sentences on the right do not matter, it would be nice to have a way to represent that the sentences on the left entail any sentence whatsoever.
There are two common ways to do this, but both make use of the same notation where $\Gamma$ is a set of SL sentences:
$$\Gamma \models \bot.$$
One way to interpret the entailment above is as a universal claim that $\Gamma$ entails every sentence of SL whatsoever. 
Another way to interpret this entailment is to take `$\bot$' to abbreviate some particular sentence of SL (it doesn't matter which) that is not true on any SL interpretation.
These conventions turn out to amount to the very same thing.
For simplicity, we will assume the latter convention where `$\bot$' abbreviates `$A \eand \enot A$' for definiteness.

A sentence $\Gamma$ of SL is \define{unsatisfiable} just in case $\Gamma \models \bot$.
In order to see why this definition makes sense, we may show that a set of SL sentences $\Gamma$ is unsatisfiable just in case there is no SL interpretation $\I$ which satisfies $\Gamma$.
To do so, suppose that $\Gamma$ is unsatisfiable, and so $\Gamma \models \bot$.
It follows that every SL interpretation that satisfies $\Gamma$ also satisfies $\bot$.
However, by design, there is no interpretation that satisfies $\bot$.
Thus there is no SL interpretation $\I$ that satisfies $\Gamma$, for otherwise $\I$ would have to satisfy $\bot$.
Conversely, suppose that there is no SL interpretation $\I$ that satisfies $\Gamma$.
It follows vacuously that every SL interpretation that satisfies $\Gamma$ (all zero of them) also satisfies $\bot$.
Hence $\Gamma \models \bot$, and so $\Gamma$ is unsatisfiable.
This shows that $\Gamma$ is unsatisfiable if and only if there is no SL interpretation $\I$ that satisfies $\Gamma$.
% Haven taken unsatisfiability to be the basic notion, we may now define a set of SL sentences $\Gamma$ to be \define{satisfiable} just in case $\Gamma$ is not unsatisfiable. 
It follows that $\Gamma$ is \define{satisfiable} just in case there is an SL interpretation $\I$ that satisfies $\Gamma$.

Consider the following examples:

\begin{earg}
\item[] $A \eand \enot A \models \bot$.
\item[] $P, \enot P \models \bot$.
\item[] $P \eiff Q, Q \eiff\enot P \models \bot$.
\end{earg}

The sets of sentences on the left of each entailment above are unsatisfiable.\footnote{Recall that we have omitted set notation for ease of exposition.}
As a special case, we may say that an SL sentence $\metaA$ is a \define{contradiction} just in case its singleton set $\set{\metaA}$ is unsatisfiable, i.e., $\metaA \models \bot$.
Whereas contradictions are sentences of SL, only \textit{sets} of sentences of SL may be said to be unsatisfiable.
Nevertheless, it follows by the weakening principle given above that any set of SL sentences which contains a contradiction is unsatisfiable.
By contrast, there are lots of unsatisfiable sets of sentences that do not contain contradictions.
For instance, neither $P \eiff Q$ nor $Q \eiff \neg P$ are contradictions. 
Nevertheless, the set $\set{P \eiff Q, Q \eiff \neg P}$ is unsatisfiable. 
Compare the following examples to those given above:

\begin{earg}
\item[] $(P \eor \enot P) \models\bot$
\item[] $P, \enot Q, (R \eor Q) \models\bot$
\item[] $\enot P, \enot Q, (P \eif \enot\enot Q) \models\bot$
\end{earg}

Since the sentences on the left can be satisfied, the three entailments given above are false.



\section{Consistency}
  \label{sec:consistency}

Recall that the definition of consistency given in $\S\ref{sub:consistency}$ appealed to complete truth-tables: a set of SL sentences $\Gamma$ is \define{consistent} just in case there is at least one line of a complete truth table including every sentence in $\Gamma$ on which all of the sentences in $\Gamma$ are true.
Alternatively, we may avoid appealing to complete truth tables by saying that a set of SL sentences $\Gamma$ is \define{consistent} just in case there is an interpretation $\I$ of SL where every sentence in $\Gamma$ is true, i.e., $\V{\I}(\metaA)$ for all $\metaA$ in $\Gamma$.\label{def.consistencySL}
Accordingly, we may show that any set of SL sentences $\Gamma$ is consistent just in case it is satisfiable. 
Put otherwise, consistency and satisfiablility have the same \textit{extension} insofar as they apply to the very same sets of SL sentences.
As a result, if you ever need help seeing whether a given set of sentences can be satisfied, you can always draw out its truth table to check if any row assigns a `1' every sentence in the set.
If there is no row which assigns a `1` to every sentence in the set, then the set is unsatisfiable.




% \section{Defining truth-conditions in SL}
% \label{sec:truthSL}
% \label{sec.semanticsSL}
%
% % %JH: this section seems to have some conceptual problems. Try to find an analog in the Logic Book or Calgary book and rewrite this! 
% %Could honestly make more sense to just get right to notions of truth-functional entailment, etc. It's not like we're really explaining `truth' in a first-semester logic class. Would need to get into disquotation theory. 
% %so maybe move this and the next section to the end of the chapter! Ultimately, I'd like to combine this stuff w/ the truth tables anyway, like in the logic book! 
% %alternatively, I could combine this section and the next w/ recursion/induction in a chapter on that. 
%
% {\color{black}This section formally characterizes the \emph{truth-conditions} of well-formed formulae (wffs) in SL. These are the logical conditions under which a sentence is true or false.} We build on what we already know from constructing truth tables. In Chapter~\ref{ch.TruthTables}, we used truth tables to reliably test whether a sentence is a tautology in SL, whether two sentences are equivalent, whether an argument is valid, and so on. For instance: \metaA{} is a tautology in SL if and only if it is assigned `1' on every line of a complete truth table.
%
% Truth tables work because each line of a truth table corresponds to a way the world might be, at least conceptually or logically. We consider all the logically possible combinations of 1s and 0s for the sentence letters that compose the sentences we care about. A truth table allows us to determine what would happen given these different combinations. 
%
% {\color{black}To formally define truth-conditions in SL, we introduce a function \textit{\textbf{a}} that assigns---for each interpretation---a 1 or 0 to each of the atomic sentences of SL. We call this function a \textit{truth-value assignment}. We proceed to use the function \textit{\textbf{a}} to construct a more general function \textit{\textbf{v}} called a `valuation function'. Unlike \textit{\textbf{a}}, \textit{\textbf{v}} is defined on arbitrarily complex wffs in SL. We show it is possible to construct the valuation function \textit{\textbf{v}} such that it has the following desirable property:} for any wff \metaA{}, \textit{\textbf{v}}(\metaA{})$=1$ if \metaA{} is true and \textit{\textbf{v}}(\metaA{})$=0$ if \metaA{} is false. 
%
% %It does this by means of a valuation function $\mathbf{v}$, that acts on atomic sentences 
% %We can interpret this function as accurately defining the truth-conditions for SL if it assigns 1 to all of the true sentences of SL and 0 to all of the false sentences of SL. 
%
% Recall that the recursive definition of a wff of SL has two stages: The first step says that atomic sentences (solitary sentence letters) are wffs. The second stage considers wffs that are constructed out of more basic wffs. There is a clause in the definition for each of the sentential connectives. For example, if \metaA{} is a wff, then \enot\metaA{} is a wff.

% \subsection{Truth for Atomic Sentences}
%
% Our strategy for defining the valuation \textit{\textbf{v}} will also be in two steps. The first step will handle truth-conditions for atomic sentences; the second step will handle truth-conditions for compound sentences.
%
% How can we define the truth-conditions for an atomic sentence of SL? Consider, for example, the sentence $M$. Without an interpretation, we cannot say whether $M$ is true or false. It might mean anything. If we use `$M$' to symbolize `The moon orbits the Earth', then $M$ is true. If we use `$M$' to symbolize `The moon is a giant turnip', then $M$ is false.
%
% When we give a symbolization key for SL, we provide a translation into English of the sentence letters that we use. In this way, the interpretation specifies what each of the sentence letters \emph{means}. However, this is not enough to determine whether or not that sentence is true. Assessing the sentences about the moon, for instance, requires that you know some rudimentary astronomy. Imagine a small child who became convinced that the moon is a giant turnip. She could understand what the sentence `The moon is a giant turnip' means, but mistakenly think that it were true.
%
% So a symbolization key alone does not determine whether a sentence is true or false. Truth or falsity depends also on what the world is like. If `$M$' meant `The moon is a giant turnip' and the real moon were a giant turnip, then $M$ would be true. To determine a truth value via the symbolization key, one has to first translate the sentence into English, and then rely on one's knowledge of what the world is like.
%
% We want a logical system that can proceed without astronomical investigation. Moreover, we want to abstract away from the specific commitments of a given symbolization key. So our characterization of truth-conditions proceeds in a different way. We ignore any proffered symbolization key, and take, from a given interpretation, a \emph{truth value assignment}. Formally, this is just a function that tells us the truth value of all the atomic sentences. Call this function `\textit{\textbf{a}}' (for `assignment'). We define \textit{\textbf{a}} for all atomic sentence letters \script{P}, such that
% \begin{displaymath}
% a(\script{P}) =
% \left\{
% 	\begin{array}{ll}
% 	1 & \mbox{if \script{P} is true},\\
% 	0 & \mbox{otherwise.}
% 	\end{array}
% \right.
% \end{displaymath}
% This means that \textit{\textbf{a}} takes any atomic sentence of SL and assigns it either a one or a zero; one if the sentence is true, zero if the sentence is false. 
%
% You can think of \textit{\textbf{a}} as being like a row of a truth table. Whereas a truth table row assigns a truth value to a few atomic sentences, the truth value assignment assigns a value to every atomic sentence of SL. There are infinitely many sentence letters, and the truth value assignment gives a value to each of them {\color{black}(if you're worried about infinity, this might trouble you!)}. When constructing a truth table, we only care about sentence letters that affect the truth value of sentences that interest us. As such, we ignore the rest.
%
% It is important to note that the truth value assignment, \textit{\textbf{a}}, is not part of the language SL. Rather, it is part of the mathematical machinery that we are using to describe SL. It encodes which atomic sentences are true and which are false.
%
% \subsection{Truth for arbitrary SL sentences}
%
% We now define the valuation function, \textit{\textbf{v}}, using the same recursive structure that we used to define a wff of SL.
%
% \begin{enumerate}
% \item If \metaA{} is a sentence letter, then \textit{\textbf{v}}(\metaA{}) $=$ \textit{\textbf{a}}(\metaA{}).
% %\setcounter{Example}{\arabic{enumi}}\end{enumerate}
% %...
% % Break out of the {enumerate} environment to say something about what is
% % going on. Using \setcounter in this way preserves the numbering, so
% % that the list can resume after the comments.
%
% %This is a mathematical equals sign, not the identity predicate we defined for QL.
%
% % Resume the {enumerate} environment and restore the counter.
% %...
% %\begin{enumerate}\setcounter{enumi}{\arabic{Example}}
%
% \item If \metaA{} is ${\enot}\metaB{}$ for some sentence \metaB{}, then
% \begin{displaymath}\textit{\textbf{v}}(\metaA{}) =
% 	\left\{\begin{array}{ll}
% 	1 & \mbox{if \textit{\textbf{v}}(\metaB{}) $= 0$},\\
% 	0 & \mbox{otherwise.}
% 	\end{array}\right.
% \end{displaymath}
%
% \item If \metaA{} is $(\metaB{}\eand\metaC{})$ for some sentences \metaB{}, \metaC{}, then
% \begin{displaymath}\textit{\textbf{v}}(\metaA{}) =
% 	\left\{\begin{array}{ll}
% 	1 & \mbox{if \textit{\textbf{v}}(\metaB{}) $= 1$ and \textit{\textbf{v}}(\metaC{}) $= 1$,}\\
% 	0 & \mbox{otherwise.}
% 	\end{array}\right.
% \end{displaymath}
% \setcounter{Example}{\arabic{enumi}}\end{enumerate}
% %...
% \label{truthdefinition}
% You may be tempted to worry that this definition is circular, because it uses the word `and' in trying to define `and.' But remember, we are not attempting to give a definition of the English word `and'; we are giving a definition of truth-conditions for sentences of SL containing the logical symbol `\eand.' We define truth-conditions for object language sentences containing the symbol `\eand' using the metalanguage word `and.' There is nothing circular about that.
%
% %...
% \begin{enumerate}\setcounter{enumi}{\arabic{Example}}
%
% \item If \metaA{} is $(\metaB{}\eor\metaC{})$ for some sentences \metaB{}, \metaC{}, then
% \begin{displaymath}\textit{\textbf{v}}(\metaA{}) =
% 	\left\{\begin{array}{ll}
% 	0 & \mbox{if \textit{\textbf{v}}(\metaB{}) $= 0$ and \textit{\textbf{v}}(\metaC{}) $= 0$,}\\
% 	1 & \mbox{otherwise.}
% 	\end{array}\right.
% \end{displaymath}
% %\setcounter{Example}{\arabic{enumi}}\end{enumerate}
% %...
% %Notice that this defines truth for sentences containing the symbol `\eor' using the word `and.'
% %...
% %\begin{enumerate}\setcounter{enumi}{\arabic{Example}}
%
% \item If \metaA{} is $(\metaB{}\eif\metaC{})$ for some sentences \metaB{}, \metaC{}, then
% \begin{displaymath}\textit{\textbf{v}}(\metaA{}) =
% 	\left\{\begin{array}{ll}
% 	0 & \mbox{if \textit{\textbf{v}}(\metaB{}) $= 1$ and \textit{\textbf{v}}(\metaC{}) $= 0$,}\\
% 	1 & \mbox{otherwise.}
% 	\end{array}\right.
% \end{displaymath}
%
% \item If \metaA{} is $(\metaB{}\eiff\metaC{})$ for some sentences \metaB{}, \metaC{}, then
% \begin{displaymath}\textit{\textbf{v}}(\metaA{}) =
% 	\left\{\begin{array}{ll}
% 	1 & \mbox{if \textit{\textbf{v}}(\metaB{}) $=$ \textit{\textbf{v}}(\metaC{})},\\
% 	0 & \mbox{otherwise.}
% 	\end{array}\right.
% \end{displaymath}
% \end{enumerate}
%
% Since the definition of \textit{\textbf{v}} has the same structure as the definition of a wff, we know that \textit{\textbf{v}} assigns a value to \emph{every} wff of SL. Since the sentences of SL and the wffs of SL are the same, this means that \textit{\textbf{v}} returns the truth value of every sentence of SL.
%
% Setting aside tautologies and contradictions, the truth or falsity of a sentence in SL is always \emph{relative to} some interpretation. This is because the sentence's truth-conditions do not say whether it is true or false. Rather, the truth-conditions specify how the truth of that sentence relates to a truth value assignment \textit{\textbf{a}} to atomic sentence letters.




%************************JH******************************
%stuff I cut from Ichikawa's version or additional concerns I had about it: 

%JH: following seems unnecessary
%(Technical side note: one might be tempted to \emph{identify} interpretations with assignments of truth values to atomic sentences. (In past versions of this book, that's actually what I did.) For a variety of reasons, this is not (any longer) my preference. One reason is that there can be different ways to assign truth values to atomic sentences, corresponding to one and the same row of the truth table, if one includes values for atoms that are not mentioned in the truth table. In a truth table for a sentence that doesn't include an $R$, for instance, these two assignments of truth values to atoms are effectively equivalent, and correspond to the same row of the truth table: \{$P=1$, $Q=1$, $R=1$\}, \{$P=1$, $Q=1$, $R=0$\}. So there could be different interpretations corresponding to the same row of the truth table, but an interpretation \emph{determines} a row of a truth table.

%A more complex motivation for my terminological choice here has to do with the relationship between SL and QL, a more complex language we'll learn later in the textbook. I'll return to this connection in \S\ref{sec.0PlaceModels}.)

%JH: I don't understand the following paragraph or the point of it...
%Once we construct a truth table, the symbols `1' and `0' are divorced from their metalinguistic meaning of `true' and `false'. We interpret `1' as meaning `true', but the formal properties of 1 are defined by the characteristic truth tables for the various connectives.  The symbols in a truth table have a formal meaning that we can specify entirely in terms of how the connectives operate. For example, if $A$ is value 1, then $\enot A$ is value 0.

%JH: part of the following `defN of truth' seems circular, since we appeal to a pretheoretic notion of `true sentences of SL' when we say ``We can interpret this function as a definition of truth for SL if it assigns 1 to all of the true sentences of SL and 0 to all of the false sentences of SL". Indeed, we could flip the valuation and we would syntactically have just as good a characterization of truth conditions. We just wouldn't have a `match' with the world. But this modeling principle/norm is separate from the abstract project of characterizing truth-conditions recursively, i.e. showing the compositionality of truth-conditions in SL. 

%JH: it seems a bit misleading to describe this construction as giving a definition of `truth' in sentential logic (indeed as the last paragraph of this section itself seems to indicate!). Rather, we are showing that sentential logic has a compositionality principle: the truth value of a sentence is determined by the truth values of component parts. 

%JH: following seems to indicate that we're not really defining `truth' in SL. we're showing that truth in SL is compositional. Nice illustration of recursive reasoning, but that's about it! so could be a good warmup for the week on induction/recursion. but not essential for the HW problems for ch. 2 and 3 on truth tables, entailment, validity. 


\iffalse

\practiceproblems



\problempart
\label{HW3.C}
Each of the following claims can be evaluated with truth tables. For each, what would you look for in a completed truth table to evaluate it? The Greek letters can stand for any arbitrary sentence of SL. The first claim has the answer filled out for you.

\begin{earg}
		\item[0.] $\Phi$ is a tautology.
		To evaluate this claim, check to see whether the main connective of $\Phi$ has a 1 under it in every row. If so, it is true.
		\item $\Phi \models \Psi$. 
		To evaluate this claim, check to see whether... 
		
		\item $\Phi$ is contingent.
\item $\Phi \models \bot$
		\item $\emptyset \models \Phi$
	\end{earg}


\problempart
Determine whether each entailment claim is true. You may construct a truth table to test it if you like, but these examples are simple enough so that you may be able to just think it through and get the right answer.
\begin{earg}
\item $Q \models (P \eor Q)$
\item $P, Q \models (P \eor P)$
\item $P \eiff Q, P \models Q$ %  \textcolor{red}{True.}
\item $S \models (Q \eif Q)$   %\textcolor{red}{True.}
\item $P \eand \enot P \models (Q \eor \enot Q)$%   \textcolor{red}{True.}
\item $(P \eand \enot P) \models (Q \eand \enot Q)$
\item $(P \eor \enot P) \models \bot$
\item $(P \eor \enot P) \models Q$%   \textcolor{red}{False: $\{P=1, Q=0\}$.}
\item $\models (P \eor \enot P)$
\item $\models (P \eand \enot P)$
\item $(A \eor B) \eif \enot P \models (P \eor \enot P)$
\item $(P \eiff Q) \models ((P \eand Q) \eor \enot (P \eor Q))$
\end{earg}

\fi 

